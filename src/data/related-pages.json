{
  "/build-apps/add-time-picker-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.20226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a <em>time</em> <em>picker</em> to your <em>app</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-07-27T16:07:58Z",
      "updated_at": "2021-07-09T12:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: New Relic APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.49079,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Android <em>app</em> UI",
        "sections": "Android <em>app</em> UI",
        "tags": "Mobile <em>apps</em>",
        "body": " <em>picker</em> to choose a <em>time</em> range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android <em>app</em> to view your New Relic Synthetics data, including charts of your monitor&#x27;s availability, load times, and load sizes. Select the caret icon to view more detailed charts. You"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.31024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": ": <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access"
      },
      "id": "6091fa39196a67a4ead52a4b"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.092094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "sections": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "info": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "body": " NewsletterSignups component&#x27;s render() <em>method</em>: import React from &#x27;react&#x27;; import { HeadingText, LineChart, NrqlQuery, <em>PlatformStateContext</em>, } from &#x27;nr1&#x27;; const ACCOUNT_ID = 123456 &#x2F;&#x2F; &lt;YOUR NEW RELIC ACCOUNT ID&gt; export default class NewsletterSignups extends React.Component { render() { return &lt;div&gt; &lt;HeadingText"
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-07-27T16:10:09Z",
      "updated_at": "2021-07-09T11:42:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: New Relic APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.25241,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS mobile <em>app</em>",
        "sections": "Introduction to iOS mobile <em>app</em>",
        "tags": "Mobile <em>apps</em>",
        "body": "The user interface for New Relic&#x27;s iPhone and iPad <em>app</em> provides functionality similar to New Relic&#x27;s standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-<em>time</em> information about your apps, hosts, and more. Features New Relic&#x27;s iOS <em>app</em> includes"
      },
      "id": "6044161628ccbc96b62c6092"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Automate workflows",
      "updated_at": "2021-07-29T01:39:17Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.56659,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " Toolkit. Guides to automate workflows Quickly <em>tag</em> resources 5 min Add <em>tags</em> to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up <em>New</em> <em>Relic</em> using the Kubernetes operator 20"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-07-30T01:44:23Z",
      "updated_at": "2021-07-30T01:44:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.3513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tags</em> (attributes)",
        "body": "Our StatsD integration lets you easily get StatsD-format data into <em>New</em> <em>Relic</em>. You can also add any arbitrary <em>tags</em> (key-value pairs) to your data. Once your metrics are in <em>New</em> <em>Relic</em>, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a <em>New</em>"
      },
      "id": "6043a32364441fa554378eee"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.39093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " application. You should copy it or write it down. Step 6 of 10 Add a simple <em>tag</em> to your application. Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using"
      },
      "id": "6091f7ca196a67b841d52a33"
    },
    {
      "sections": [
        "Connect AWS to New Relic infrastructure monitoring",
        "Connect AWS to New Relic",
        "Connect multiple AWS integrations",
        "Connect multiple AWS accounts",
        "Add or edit custom tags",
        "Disconnect your AWS integrations",
        "Regional support"
      ],
      "title": "Connect AWS to New Relic infrastructure monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "Get started"
      ],
      "external_id": "a00c91900961871b2c48d88bca610d5457473f11",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/get-started/connect-aws-new-relic-infrastructure-monitoring/",
      "published_at": "2021-07-28T07:09:39Z",
      "updated_at": "2021-07-28T07:09:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To start receiving Amazon data with New Relic AWS integrations, connect your Amazon account to New Relic. Connect AWS to New Relic To connect your Amazon account to infrastructure monitoring in New Relic: Go to one.newrelic.com > Infrastructure > AWS. Click on one of the available service tiles. From the IAM console, click Create role, then click Another AWS account. For Account ID, use 754728514883. Check the Require external ID box. For External ID, enter your New Relic account ID. Do not enable the setting to Require MFA (multi-factor authentication). Attach the Policy: Search for ReadOnlyAccess, select the checkbox for the policy named ReadOnlyAccess, then click Next: Review. Alternatively, you can create your own managed policy and limit the permissions you grant New Relic according to the AWS services you want to monitor. For the Role name, enter NewRelicInfrastructure-Integrations, then click Create role. Select the newly created role from the listed roles. On the Role summary page, select and copy the entire Role ARN (required later in this procedure). Configure a Budgets policy: While viewing the Role summary for your new role, select Add inline policy. Create a Custom policy: Enter a policy name (for example, NewRelicBudget), add the following permission statement, and then select Apply policy. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"budgets:ViewBudget\" ], \"Resource\": \"*\" } ] } Copy Return to the New Relic UI to enter your AWS account name and the ARN for the new role. Select the Amazon Web Services to be monitored with New Relic infrastructure integrations, then Save. Connect multiple AWS integrations To connect multiple AWS integrations to a single New Relic account: If you previously set up an ARN with the more restrictive AmazonEC2ReadOnlyAccess policy, first unlink your existing integration, then create a new one with a broader policy. Follow the instructions to connect your Amazon account to New Relic . Provide the ARN that contains the ReadOnlyAccess policy. Once setup is complete, select the integrations you want to monitor: Go to one.newrelic.com > Infrastructure > AWS. Select the edit icon. Select the checkbox for each integration you want to monitor. Connect multiple AWS accounts By default, the Amazon EC2 AmazonEC2ReadOnlyAccess permission grants New Relic access to all EC2 instances in the individual Amazon account you specify during the setup steps. If you have multiple AWS accounts, follow the steps to connect an AWS account for each AWS account you want to associate with New Relic. Add or edit custom tags New Relic automatically imports any custom tags you have added or edited for your EC2 instances. Custom EC2 tags are labeled ec2Tag_TAG_NAME in the Infrastructure UI. If you do not see EC2 tags in the Add filter menu of the Filter sets sidebar within a few minutes, delete the integration and try again: Go to one.newrelic.com > Infrastructure > AWS. Select the edit icon. Remove individual integrations or the entire account linkage as needed. Disconnect your AWS integrations You can disable one or more integrations anytime and still keep your AWS account connected to New Relic. However, New Relic recommends that you do not disable EC2 or EBS monitoring. These two integrations add important metadata to your EC2 instances and EBS volumes in New Relic. To uninstall your services completely from New Relic infrastructure Integrations, unlink your AWS account. Regional support China regions are not supported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.39662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Connect AWS to <em>New</em> <em>Relic</em> infrastructure monitoring",
        "sections": "Connect AWS to <em>New</em> <em>Relic</em> infrastructure monitoring",
        "body": " in the individual Amazon account you specify during the setup steps. If you have multiple AWS accounts, follow the steps to connect an AWS account for each AWS account you want to associate with <em>New</em> <em>Relic</em>. Add or edit custom <em>tags</em> <em>New</em> <em>Relic</em> automatically imports any custom <em>tags</em> you have added or edited for your EC2"
      },
      "id": "6045079f196a679cc1960f2d"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-fdf7e1be9e4142c700009219a7dfd19b.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-07-30T01:39:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-06-09T01:38:14Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 32 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.9777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    }
  ],
  "/terms": [
    {
      "sections": [
        "Developer Program Resources"
      ],
      "title": "Developer Program Resources",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "New Relic Developer edition"
      ],
      "external_id": "8a2f08905c7dcd10e50e975783ca3cf0071324c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources/",
      "published_at": "2021-07-27T15:54:06Z",
      "updated_at": "2021-03-13T03:24:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer, you are eligible to participate in New Relic’s Developer Program. Additional information and resources are available at New Relic’s Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.7092,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you."
      },
      "id": "6044e7bb196a676d20960f4d"
    },
    {
      "sections": [
        "Preview access for New Relic One"
      ],
      "title": "Preview access for New Relic One",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "New Relic One"
      ],
      "external_id": "5a11f3d0ff23ad22ec459a0115a70ddbb2964d1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one/",
      "published_at": "2021-07-27T16:42:17Z",
      "updated_at": "2021-03-16T04:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.56085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "603e891464441f2af14e883b"
    },
    {
      "sections": [
        "New Relic One pricing: Definitions",
        "Account",
        "Commitment Term",
        "Customer Data",
        "Customer Properties",
        "Documentation",
        "GB Ingested",
        "Incident event",
        "Login Credentials",
        "Monthly Provisioned User",
        "Order",
        "Paid Terms of Service",
        "Product(s)",
        "Software",
        "Terms",
        "Third-Party Services",
        "Unpaid Terms of Service",
        "Usage Plan"
      ],
      "title": "New Relic One pricing: Definitions",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Product definitions"
      ],
      "external_id": "609575acd671fecf7899378157eabc57bc8d68e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions/",
      "published_at": "2021-07-27T15:13:08Z",
      "updated_at": "2021-05-22T17:25:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a glossary of terms that appear in contracts for our New Relic One pricing plan (for a glossary for our original pricing, see Original pricing definitions. Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer’s websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‘Documentation’ page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Incident event An incident event is an alerting event (open, closed, etc.) created by an alerting engine that is sent into the New Relic Applied Intelligence platform (non-unique) for de-duplication, flapping detection, smart suppression, enrichment, and correlation. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer’s Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. In our public docs, this is referred to as a full user. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic’s customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. To learn more about this pricing plan, see New Relic One pricing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.5757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Paid <em>Terms</em> of Service",
        "body": " into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid <em>Terms</em> of Service Paid <em>Terms</em> of Service means the legal <em>terms</em> and <em>conditions</em> located at: https:&#x2F;&#x2F;newrelic.com&#x2F;termsandconditions&#x2F;paid. Product(s) Product(s) mean the purchase"
      },
      "id": "6044e6e528ccbc26f22c6084"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions."
      ],
      "published_at": "2021-07-30T01:51:04Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2021-03-20T01:55:45Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "External Projects Highlighted Projects New Relic Projects Standards Menu External Projects Highlighted Projects New Relic Projects Standards NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (“New Relic”). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.40326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.53217,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>and</em> configure the New Relic One CLI",
        "sections": "Install <em>and</em> configure the New Relic One CLI",
        "info": "Install <em>and</em> configure the New Relic One CLI",
        "body": " developer <em>terms</em> and <em>conditions</em>: Even if you install the CLI, you won&#x27;t be able to use it without first accepting these <em>terms</em> and <em>conditions</em>. Step 4 of 5 Choose your operating system and click Download installer: Once you&#x27;ve installed the SDK, you&#x27;ll have access to the nr1 CLI. Verify this by checking your"
      },
      "id": "6091faf1196a6714b4d52a39"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-30T01:43:08Z",
      "title": "Collect data",
      "updated_at": "2021-07-30T01:43:08Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source 15 min APIs, agents, OS emitters - get any data Add custom attributes   Use custom attributes for deeper analysis Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.48927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " data - any source 15 min APIs, agents, OS emitters - get any data Add <em>custom</em> <em>attributes</em>   Use <em>custom</em> <em>attributes</em> for deeper analysis Create <em>custom</em> events 5 min Define, visualize, and get alerts on the data you want using <em>custom</em> events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with <em>NRQL</em> 10 min Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Handled exceptions: Analyze trends, prevent crashes",
        "Handled exceptions workflow",
        "Exception percentage charts",
        "Exception percentage charts example",
        "Groups and filters",
        "Groups and filters example",
        "Top five exception locations",
        "Top five exception locations example",
        "Query builder links",
        "Exception locations table",
        "Exception locations table example"
      ],
      "title": "Handled exceptions: Analyze trends, prevent crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "d325744648613b771d7dd39de3f1448fe8a54ab9",
      "image": "https://docs.newrelic.com/static/5891a9437b94b543d81ee04a70ebe876/8c557/mobile-handled-exceptions-ui.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/handled-exceptions-analyze-trends-prevent-crashes/",
      "published_at": "2021-07-27T16:12:26Z",
      "updated_at": "2021-07-21T21:33:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Handled exceptions help you identify significant factors contributing to poor mobile application experience, and use filterable data to find a resolution more quickly. You can also use the handled exceptions API to customize the data you send, and use NRQL to query and share the data. Handled exceptions workflow To get the most out of the Handled exceptions UI, use this basic workflow: Go to one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions. Use any of New Relic's standard page functions to drill down into detailed information; for example, zoom into any area of a chart. Look for obvious or general trends in the Users affected and Sessions affected percentage charts. Adjust the types of exceptions shown by using groups and filters. Optional: Query or share the chart data. Look for similar patterns where exceptions appear in stack traces with the Top 5 exception locations table. To view stack trace thread details for each occurrence of the exception, select a record from the Top 5 exceptions location table. one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: As you explore the wealth of data in the charts and table, use groups and filters to discover patterns that help you determine the root cause of mobile app exceptions. Exception percentage charts Start with the Users affected and Sessions affected percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with exceptions in general. (If the Users affected chart is empty, there were no user sessions during the selected time period.) For example: Are there any spikes near a recent version release? Is there a time period when the percentage of users has been affected significantly by the exception? Are there uneventful periods? To examine data in greater detail: Below any chart, select Expand chart. Exception percentage charts example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: The percentage charts help you quickly see any unexpected spikes, dips, or patterns with exceptions in general. Groups and filters Use the groups and filters to examine attributes for crashes, devices, locations, or other custom attributes in more detail. You can select a group, then filter to specific data. For example: Group the list by exception location (default), cause, app build or version, devices, connections, or other custom attributes. This lets you discover patterns in your exceptions to determine the root cause. Use the time picker to adjust the currently selected time period. Filter by a specific Version or by one or more attribute Filter, such as appVersion, exceptionLocationMethod, lastInteraction, or any of the longer list of standard and custom attributes. The currently selected filters appear at the top of the UI page. You can close them, add other filters, or select other groups and filters. Groups and filters example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: Group the data by attributes that matter to the most to you, then select one or more filters to help pinpoint specific causes behind the exceptions. Top five exception locations Use the Top 5 exception locations table to find or sort patterns in the type of exception you selected from the groups and filters. This includes: Recurring locations in the stack trace Mobile app version Number of occurrences Number of users affected during the selected time period For example, you can group by Exception Message, filter to timeout message, then select individual timeout locations from the table to review the stack trace thread and details about each occurrence. To filter or group by other attributes, use the table's search window, or select any of the available filters. For example, filter by type of occurrence, device, a specific location, or any custom attributes. To look for other historical patterns, change the selected time period. Top five exception locations example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: This example shows the Expand chart button and links to the query builder, where you can query, create dashboards, and share the handled exceptions data. Query builder links Handled exceptions charts use default attributes for mobile events (including MobileHandledException), along with any custom attributes you have added to this event type. When you mouse over the charts, direct links appear below them. These links to the query builder allow you to analyze your mobile app data even deeper. View query link: View the NRQL query used to calculate the chart data. View in query builder link: View the chart, and share it with others. Exception locations table The Exception locations table supplements the charts. It lists where the top five handled exceptions appear in their stack trace thread, and links them to relevant details. Each row helps you find answers to questions such as: How many of this exception occurred within the selected time period? Does a specific app version have a higher (or lower) number of users affected? Which exception has the fewest number of occurrences? You can change the sort order or filter options to focus on just the types of exceptions that matter the most to you and your teams. To view additional thread details for each occurrence of the exception, select a record from the Top 5 exceptions location table. Exception locations table example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: To continue to the handled exception's Occurrences page, select any row on the table.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.30796,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Groups and filters Use the groups and filters to examine <em>attributes</em> for crashes, devices, locations, or other <em>custom</em> <em>attributes</em> in more detail. You can select a group, then filter to specific data. For example: Group the list by exception location (default), cause, app build or version, devices"
      },
      "id": "604505ae28ccbc783e2c6085"
    },
    {
      "sections": [
        "App data NRQL query examples",
        "Unique users",
        "Unique user trends",
        "Pageview trends",
        "OS version",
        "Key account Apdex"
      ],
      "title": "App data NRQL query examples",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "54b651240956896f8bdc7d9c3fbb7b6096f455a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/app-data-nrql-query-examples/",
      "published_at": "2021-07-27T22:26:42Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL to query the application data collected by APM, browser monitoring, and mobile monitoring. You can then use this data to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago Copy Unique user trends Were your unique user sessions up or down last week compared to the week before? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago COMPARE WITH 1 week ago Copy Pageview trends How can I graph the number of unique users yesterday compared to the day before? SELECT count(*) FROM PageView SINCE 1 day ago COMPARE WITH 1 day ago TIMESERIES AUTO Copy OS version How many of your mobile users are on the latest OS version? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy Key account Apdex What is the Apdex score for a particularly important customer? If you have defined some custom attributes, you can query to monitor how this customer experiences your app from a performance standpoint: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.57708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "App data <em>NRQL</em> query examples",
        "sections": "App data <em>NRQL</em> query examples",
        "tags": "<em>NRQL</em>: New Relic Query Language",
        "body": " is the Apdex score for a particularly important customer? If you have defined some <em>custom</em> <em>attributes</em>, you can query to monitor how this customer experiences your app from a performance standpoint: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName=&#x27;ReallyImportantCustomer&#x27; SINCE 1 day ago Copy"
      },
      "id": "60445a0f64441f5a46378eec"
    },
    {
      "sections": [
        "Install Kubernetes events integration",
        "Requirements",
        "Install the Kubernetes events integration",
        "View your Kubernetes events",
        "Query events",
        "Get attributes names",
        "See event details",
        "Search events in New Relic",
        "View events in the Kubernetes cluster explorer",
        "Optional: Collect metrics of the event collector",
        "Optional: Define custom attributes",
        "Troubleshooting",
        "Get logs on event collection",
        "Get logs on sending events"
      ],
      "title": "Install Kubernetes events integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Kubernetes events"
      ],
      "external_id": "a19259cc9ac093cc7acf401c1201e48d5daa9682",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/kubernetes-events/install-kubernetes-events-integration/",
      "published_at": "2021-07-27T13:46:47Z",
      "updated_at": "2021-07-27T13:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Kubernetes events integration watches for events happening in your Kubernetes clusters and sends those events to New Relic. To visualize your event data, use the Kubernetes cluster explorer in New Relic One platform, or use the infrastructure events UI. Requirements The Kubernetes events integration requires you to: Install and activate the New Relic Kubernetes integration. Configure a Kubernetes pod with the label app.kubernetes.io/name=nri-kube-events and two containers, one used to capture events in the Kubernetes cluster and the other to forward the events to New Relic. Install the Kubernetes events integration To install the New Relic Kubernetes events integration in a Kubernetes environment: Download the integration manifest YAML file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/nri-kube-events-latest.yaml Copy Edit the nri-kube-events-latest.yaml manifest file, adding both a cluster name, to identify your Kubernetes cluster (required), and your New Relic license key (required). clusterName: \"YOUR_CLUSTER_NAME\" [...] - name: \"NRIA_LICENSE_KEY\" value: \"YOUR_LICENSE_KEY\" Copy Deploy the integration in your Kubernetes cluster: kubectl apply -f nri-kube-events-latest.yaml Copy To confirm that the integration has been configured correctly, wait a few minutes, then go to one.newrelic.com > Query builder, and run the following NRQL query to see if data has been reported: FROM InfrastructureEvent SELECT count(*) WHERE clusterName = 'YOUR_CLUSTER_NAME' since 1 hour ago Copy View your Kubernetes events Once you have successfully installed the Kubernetes event integration, you can view and query your events in New Relic. To add events to your New Relic One dashboard: Add a chart to a new or existing dashboard or create a chart using the New Relic query builder. When creating or updating your chart, select the chart type table and use the following event query, replacing YOUR_CLUSTER_NAME with the name of your cluster: FROM InfrastructureEvent SELECT event.involvedObject.kind,event.involvedObject.name,event.reason,event.message WHERE clusterName = 'YOUR_CLUSTER_NAME' limit 100 Copy Query events Here are a few examples to query your data: Get attributes names To see all the attributes names, use the following query: FROM InfrastructureEvent SELECT keyset() WHERE category = 'kubernetes' Copy See event details To see details about the latest events in a cluster, use the following query, replacing YOUR_CLUSTER_NAME with the name of your cluster: FROM InfrastructureEvent SELECT event.involvedObject.kind, event.involvedObject.name, event.type, event.message, event.reason WHERE category = 'kubernetes' AND clusterName='YOUR_CLUSTER_NAME'​ Copy The events collected by New Relic will have the exact same attributes as given by Kubernetes. For a reference of these attributes, see the Kubernetes event v1 core documentation. Search events in New Relic To search events in the New Relic Infrastructure UI: Navigate to the Infrastructure event page: Go to one.newrelic.com > Infrastructure > Events. In Category, select kubernetes. Use the Search events field to look for specific events. To focus on a specific set of events, select or change the filter set. View events in the Kubernetes cluster explorer To view events in the Kubernetes cluster explorer, use either of these methods: In New Relic One: Go to one.newrelic.com > Kubernetes cluster explorer. Then, to view the pod details: In the Kubernetes cluster explorer, select a pod. Select Show pod events. Optional: Collect metrics of the event collector To collect metric data for the event collector itself, install the New Relic Prometheus OpenMetrics integration. To get started: Install the New Relic Prometheus OpenMetrics integration. Label the deployment of your Kubernetes events integration with your configured scrape label (default is prometheus.io/scrape=true). Optional: Define custom attributes To add custom attributes to the events sent by the integration these need to be specified as environment variables following the nomenclature NRI_KUBE_EVENTS_attributeKey=attributeValue. These environment variables should be defined as part of the spec for the kube-events container. For example, to add the attribute environment with value staging to all the events, add the following to your manifest: env: - name: NRI_KUBE_EVENTS_environment value: dev Copy Be sure to specify the environment in the spec for the kube-events container, making your manifest look something like this: ... kind: Deployment ... spec: ... template: ... spec: containers: - name: kube-events ... env: - name: NRI_KUBE_EVENTS_environment value: dev Copy Troubleshooting Here are some troubleshooting tips when using the Kubernetes events integration. Get logs on event collection To check the logs of our event collector: kubectl logs deploy/nr-kube-events kube-events Copy To add more details, enable verbose mode by adding verbose: \"true\" in the config section of you configuration file, either before or after the clusterName. Get logs on sending events To check the logs of the agent responsible for sending the events to New Relic: kubectl logs deploy/nr-kube-events infra-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.53693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Optional: Define <em>custom</em> <em>attributes</em>",
        "body": " is prometheus.io&#x2F;scrape=true). Optional: Define <em>custom</em> <em>attributes</em> To add <em>custom</em> <em>attributes</em> to the events sent by the integration these need to be specified as environment variables following the nomenclature NRI_KUBE_EVENTS_attributeKey=attributeValue. These environment variables should be defined as part"
      },
      "id": "603eae45196a67b26ba83d8f"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-07-29T01:43:52Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.52017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> events and <em>attributes</em>",
        "sections": "Report browser monitoring <em>custom</em> events and <em>attributes</em>",
        "tags": "<em>Custom</em> events",
        "body": " to run and report relevant PageAction events. Run a <em>NRQL</em> query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated <em>attributes</em> you sent along with the action). Add <em>custom</em> <em>attributes</em> to PageView event The PageView event is a default browser"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/terraform/terraform-modules": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.22687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.42902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "6091fa9964441fe25f2f36f4"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-07-27T14:08:28Z",
      "updated_at": "2021-07-22T04:34:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more child accounts, the notification channel includes only users for the currently selected parent or child account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.8445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-07-30T01:41:42Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.85991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091b486196a675dc3d52a6f"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.86888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091fa9928ccbc8a70a268ac"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Automate workflows",
      "updated_at": "2021-07-29T01:39:17Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.07935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " min Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Getting started with <em>New</em> <em>Relic</em> and Terraform 30 min Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform Set up <em>New</em> <em>Relic</em>"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-07-30T01:43:07Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.61034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "6091f7c828ccbc8813a268b2"
    },
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-07-30T01:44:23Z",
      "updated_at": "2021-07-30T01:44:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.95056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tags</em> (attributes)",
        "body": "&#x27; address = &#x27;https:&#x2F;&#x2F;metric-<em>api</em>.newrelic.com&#x2F;metric&#x2F;v1&#x27; <em>api</em>-<em>key</em> = &#x27;$<em>NEW_RELIC_API_KEY</em>&#x27; Copy To use the configMap, declare a volume on your <em>deployment</em> spec template and then declare a volumeMount on your container spec. Example: <em>api</em>Version: apps&#x2F;v1 kind: <em>Deployment</em> spec: template: spec: containers"
      },
      "id": "6043a32364441fa554378eee"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-29T01:40:31Z",
      "updated_at": "2021-07-27T11:27:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.38013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> NerdGraph, our GraphQL <em>API</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> NerdGraph, our GraphQL <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": " and execute queries. To use GraphQL, you’ll need a user-specific <em>New</em> <em>Relic</em> <em>API</em> <em>key</em> called a user <em>key</em>. You can generate one or find an existing one from the GraphiQL explorer’s <em>API</em> <em>key</em> dropdown. To find the GraphiQL explorer: If your <em>New</em> <em>Relic</em> account uses an EU data center, go to <em>api</em>"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-fdf7e1be9e4142c700009219a7dfd19b.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-07-30T01:39:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-06-09T01:38:14Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 32 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.66072,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Automate workflows",
      "updated_at": "2021-07-29T01:39:17Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.8854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " Toolkit. Guides to <em>automate</em> workflows Quickly <em>tag</em> resources 5 min Add tags to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> 30 min See how easy it is to leverage automation in <em>your</em> DevOps environment! Set up New Relic using the Kubernetes operator 20"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and add tags",
        "Overview",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity"
      ],
      "title": "NerdGraph tutorial: View and add tags",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b62313b6fa10ab235c031feae23d6fe52163b703",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial/",
      "published_at": "2021-07-27T11:27:09Z",
      "updated_at": "2021-06-09T05:59:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use our NerdGraph API to add tags to your data to help improve data organization and findability. Overview This doc explains how to use our NerdGraph API to add and manage tags. Note that this is only one way to add tags. For other methods, see How tags are added. For how to automate tags using our CLI tool, see our developer site. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } Copy The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Copy Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Copy Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Copy Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace the entity’s entire set of tags with the provided tag set: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.20876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph tutorial: View and add <em>tags</em>",
        "sections": "NerdGraph tutorial: View and add <em>tags</em>",
        "body": " of deleting an <em>entire</em> <em>tag</em> and all of its values, you can delete a single <em>tag</em> value. Go to the NerdGraph GraphiQL explorer at api.newrelic.com&#x2F;graphiql. Use entitySearch() to locate the GUID for the entity with the <em>tag</em> you want to remove. Use the <em>taggingDeleteTag</em>ValuesFromEntity mutation. The following"
      },
      "id": "603ec1c6196a67eeada83d9a"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.96829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Impact <em>of</em> accounts on the workload permissions and content",
        "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across <em>your</em> <em>entire</em> <em>stack</em>. Workloads help you understand the status of complex systems, detect"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.95303,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query <em>your</em> data more easily",
        "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-<em>Stack</em> Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout <em>your</em> <em>entire</em> system. To access New Relic One: Go to one.newrelic.com"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-06-08T19:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region), and you can also add your own custom tags. You can use tags in the UI to filter down to relevant data, as shown here: Here you can see an accountId tag being used to filter workloads to a specific account. You can use tags to: Help organize data coming from a large number of sources and/or to a large number of New Relic accounts Identity teams, roles, environment, or regions to know who’s responsible for what (see example use cases) Better organize and search dashboards and workloads Help you query and chart APM data Tags are useful for organizing data at a high level. If you wanted to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events would be a better solution. Tip At New Relic, tags were previously called \"labels.\" You may sometimes see \"label\" used in our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, read the best practices below to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Be consistent with capitalization. For example, avoid using both env: staging and env: Staging (although tag searching is case-insensitive in the UI and API) Tips on cross-team implementation: One reason for using tags is to improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Keep this reference manual up-to-date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in Tag sources, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.84024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "sections": "<em>Automate</em> <em>tags</em> with our CLI",
        "body": " that identify entities that are non-compliant with <em>your</em> <em>tagging</em> standards. <em>Tag</em> examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible"
      },
      "id": "603ebd1228ccbc6278eba754"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-07-29T01:47:07Z",
      "updated_at": "2021-07-27T06:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.43326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": " Relic data types Metrics: see the <em>Metric</em> <em>API</em> Logs: see the Log <em>API</em> Traces: see the <em>Trace</em> <em>API</em> Events: see the <em>Event</em> <em>API</em> Write your own <em>Telemetry</em> <em>SDK</em> or contribute to an existing one If you need a <em>Telemetry</em> <em>SDK</em> in a language that does not currently exist or want to contribute to an existing library"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Tip",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-07-29T01:42:55Z",
      "updated_at": "2021-07-27T05:55:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve mobile monitoring data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, child accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.57896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "<em>Telemetry</em> <em>APIs</em> for core data types",
        "tags": "<em>APIs</em>",
        "body": " synthetics monitors, use the Alerts <em>API</em>. <em>Telemetry</em> APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed <em>agent</em>. Data type Description <em>Trace</em> <em>API</em> Send distributed tracing data to New Relic"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "FedRAMP-compliant endpoints",
        "Customer FedRAMP obligations",
        "Overview of data sources",
        "Agents",
        "APM agents",
        "Mobile monitoring agents",
        "Infrastructure monitoring",
        "Infrastructure agent versions below 1.15.0",
        "Browser agent",
        "Data-ingest APIs",
        "Metric API",
        "Telemetry integrations",
        "Telemetry SDKs",
        "Event API",
        "Log API",
        "Log forwarders",
        "Trace API"
      ],
      "title": "FedRAMP-compliant endpoints",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "ffce8ad6f802717392aca80e0965c9f3fe77ffdf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/fedramp-compliant-endpoints/",
      "published_at": "2021-07-29T01:47:07Z",
      "updated_at": "2021-07-10T03:00:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides information on FedRAMP-compliant endpoints in New Relic. For more information about our security accreditation for the Federal Risk and Authorization Management Program (FedRAMP), see our data encryption documentation. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features (see below). Overview of data sources There are multiple ways to get data into New Relic. This doc has two sections: Agent settings: for our APM agents, infrastructure agent, browser agent, and mobile agent. Data-ingest APIs: for our Metric API, Event API, Trace API, and Log API, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents, and browser agent. Setting these agents to send FedRAMP-compliant data involves setting a configuration setting to use the relevant FedRAMP endpoint. APM agents To ensure FedRAMP compliance, all APM agent configurations must report to gov-collector.newrelic.com rather than the default. Depending on the agent, you can either use code-based configuration or an environment variable. Here are details on enabling this: Language Code or environment variable C SDK In code: strcpy(_newrelic_app_config_t->redirect_collector, \"gov-collector.newrelic.com\"); Copy Environment variable: none Go In code: app, err = newrelic.NewApplication( newrelic.ConfigAppName(\"App Name\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), func(cfg *newrelic.Config) { cfg.Host = \"gov-collector.newrelic.com\" }, ) Copy Environment variable: NEW_RELIC_HOST Java In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Or set a system property of: newrelic.config.host Copy Environment variable: NEW_RELIC_HOST .NET In your XML config next to the license key: <service licenseKey=\"YOUR_LICENSE_KEY\" host=\"gov-collector.newrelic.com\"/> Copy Environment variable: NEW_RELIC_HOST Node.js In newrelic.js: host: 'gov-collector.newrelic.com' Copy Environment variable: NEW_RELIC_HOST PHP In newrelic.ini: newrelic.daemon.collector_host = gov-collector.newrelic.com Copy Environment variable: none Python In newrelic.ini: [newrelic] host = gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Ruby In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Elixir (open source agent) In config.exs: config :new_relic_agent, host: \"gov-collector.newrelic.com\" Copy Environment variable: NEW_RELIC_HOST For more on configuring APM agents, see APM configuration. Mobile monitoring agents To ensure FedRAMP compliance when using our mobile monitoring agents, all agent configurations must report to gov-mobile-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables are not available. Framework-specific configurations: Agent Code or environment variable Android In code: NewRelic.withApplicationToken({APP_TOKEN}) .usingCollectorAddress(\"gov-mobile-collector.newrelic.com\") .usingCrashCollectorAddress(\"gov-mobile-crash.newrelic.com\") .start(this.getApplication()); Copy Environment variable: none iOS In code: [NewRelic startWithApplicationToken:@\"{APP_TOKEN}\" andCollectorAddress:@\"gov-mobile-collector.newrelic.com\" andCrashCollectorAddress:@\"gov-mobile-crash.newrelic.com\"]; Copy Environment variable: none Infrastructure monitoring If you have infrastructure agent version 1.15.0 or higher, simply enable the FedRAMP configuration option. If you have an older agent version, use the following values to edit your YAML configuration: Infrastructure agent versions below 1.15.0 If you have an infrastructure agent version below 1.15.0, you must change three of the endpoints used for reporting. To set these endpoints, you can change your YAML configuration or use environment variables. YAML config field Endpoint URL collector_url https://gov-infra-api.newrelic.com Copy identity_url https://gov-identity-api.newrelic.com Copy command_channel_url https://gov-infrastructure-command-api.newrelic.com Copy To edit environment variables, use these values: Environment variable Endpoint URL NRIA_COLLECTOR_URL https://gov-infra-api.newrelic.com Copy NRIA_IDENTITY_URL https://gov-identity-api.newrelic.com Copy NRIA_COMMAND_CHANNEL_URL https://gov-infrastructure-command-api.newrelic.com Copy Browser agent To configure the browser agent to use a FedRAMP-compliant endpoint, you must use the copy-paste method method (other browser agent install methods are not supported) and edit the browser code’s script element tag so that the domain is gov-bam.nr-data.net for both beacon and errorBeacon, like this: window.NREUM||(NREUM={});NREUM.info={\"beacon\":\"gov-bam.nr-data.net\",\"errorBeacon\":\"gov-bam.nr-data.net\"... Copy Note: You only need to modify the beacon and errorBeacon properties in the NREUM.info object. These values will override the default values found in the NR loader script. Data-ingest APIs Below are details about the FedRAMP endpoint for our ingest APIs: Metric API, the Event API, the Log API, and the Trace API. Metric API To ensure FedRAMP compliance when using the Metric API, instead of sending metric data to the default Metric API endpoint of https://metric-api.newrelic.com/metric/v1, it must be sent to https://gov-metric-api.newrelic.com/metric/v1. The Metric API can be used directly but it's mainly used by various New Relic tools. Below are instructions showing where to edit the configuration for setting the FedRAMP endpoint. Telemetry integrations Here are instructions for our open source telemetry integrations that report metric data: Dropwizard: use the overrideUri configuration. Kamon: use the metric-ingest-url configuration. See Override endpoints. Micrometer: override the public String uri() method on your NewRelicRegistryConfig to return the new endpoint. See an example. Prometheus: Prometheus OpenMetrics: if you are using our nri-prometheus helm chart, you can change the endpoint in your values.yml file, like in this example. If you're using the nri-bundle chart, you need to nest this value under the nri-prometheus key to propagate it to the sub-chart. Remote write integration: not available. Telemetry SDKs Here are instructions for our Telemetry SDKs that report metric data: Go: use the MetricsURLOverride configuration. Java: in the MetricBatchSender section, configure the endpoint. See an example. .NET: use the MetricUrlOverride configuration. Node.js: edit the METRIC_HOST = 'metric-api.newrelic.com' configuration. Python: edit the HOST = \"metric-api.newrelic.com\" configuration. Event API To ensure FedRAMP compliance for the Event API, all traffic reporting to insights-collector.newrelic.com must instead report to gov-insights-collector.newrelic.com. The Event API endpoint is configurable for the following Telemetry SDKs. The Telemetry SDKs are used by our open-source telemetry integrations. Language Solution Java Telemetry SDK In code: SenderConfiguration configuration = SenderConfiguration .builder( \"gov-insights-collector.newrelic.com\", EventBatchSender.EVENTS_PATH) .build(); EventBatchSender eventBatchSender = EventBatchSender.create(configuration); Copy Python Telemetry SDK In code: event_client = EventClient(host=\"gov-insights-collector.newrelic.com\") Copy For more information, see our Telemetry API documentation in GitHub. Log API To ensure FedRAMP compliance for data sent via the Log API, the solution for almost all our logging tools is to replace the https://log-api.newrelic.com/log/v1 endpoint with https://gov-log-api.newrelic.com/log/v1. Here are details for various tools: Log forwarders Here are details on changing the endpoint for our log forwarders: AWS Firelens: Add the endpoint property to the options field of the logConfiguration, similar to to the EU account endpoint change shown in these Firelens endpoint configuration instructions. Fluentbit: Use our Fluentbit endpoint configuration. Fluentd: Use our Fluentd endpoint instructions. Infrastructure agent: See FedRAMP for infrastructure. Kubernetes: Our Kubernetes integration logs are based on fluentbit’s output plugin. Use these endpoint instructions. Logstash: Use our Logstash endpoint configuration. Syslog: For configuring syslog clients, see TCP endpoint configuration. S3: Not available. Vector: Not available. To use the Log API directly, you'd edit the Log API endpoint configuration. Trace API To ensure FedRAMP compliance for data sent via the Trace API (including telemetry integrations that use this API), replace the https://trace-api.newrelic.com/trace/v1 endpoint with https://gov-trace-api.newrelic.com/trace/v1. Notes about FedRAMP compliance for other trace data: Trace data is reported by some of our agents, like our APM agents, browser agent, and mobile agent. To enable FedRAMP compliance for that data, you would enable FedRAMP for the applicable agent. Currently Infinite Tracing is not FedRAMP compliant.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.60912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> <em>API</em>",
        "body": " APM agents, infrastructure <em>agent</em>, browser <em>agent</em>, and mobile <em>agent</em>. Data-ingest APIs: for our <em>Metric</em> <em>API</em>, <em>Event</em> <em>API</em>, <em>Trace</em> <em>API</em>, and Log <em>API</em>, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents"
      },
      "id": "603e945164441f64384e8872"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-custom-event-data/",
      "sections": [
        "Report custom events and attributes",
        "Requirements",
        "Avoid rate limits",
        "Example use cases",
        "Using custom attributes",
        "Using custom events",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "published_at": "2021-07-29T01:48:01Z",
      "title": "Report custom events and attributes",
      "updated_at": "2021-07-09T20:06:23Z",
      "type": "docs",
      "external_id": "e50a9be8b3df5859c6307c8642942006f537578d",
      "document_type": "page",
      "popularity": 1,
      "body": "One of the ways to report custom data to New Relic is with custom events and attributes. Have questions about why you'd use custom data? See Introduction to custom data. Requirements For event and attribute formatting requirements and best practices, see Limits and requirements. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Example use cases Two popular custom data solutions are custom events and custom attributes. There are several ways to accomplish this (more on that later in this doc), depending on your New Relic implementation and tools. Here are some common use cases for implementing custom events and attributes. Using custom attributes Custom attributes are often used to add important business and operational context to existing events. Business context might include: Customer token Customer market segment Customer value classification Workflow control values not obvious in the URIStem User/product/account privilege context Operational context might include: Which feature flags were used What datastore was accessed What cache was accessed What errors were detected and ignored (fault partitioning) Using custom events Event data is one of New Relic's four core data types. We recommend reading that definition to understand what we mean by \"event\" and why that data type is most used for reporting specific types of activity. The use cases for custom events varies widely: basically they are used for any type of activity that an organization deems important and that is not already being monitored. A couple examples: An event might represent an activity involving multiple actions, like a customer purchasing a certain combination of products. An event might record backup activity. For example, they might set up reporting of events that represent production backups of their SOLR instances into an event table, with a timestamp of when it occurred, which cluster, and the duration. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the browser API call addCustomAttribute. Send PageAction event and attributes via browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.95012,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>events</em> and attributes",
        "sections": "Report custom <em>events</em> and attributes",
        "body": " custom attributes to the SyntheticCheck <em>event</em> via the $util.insights tools. For ways to report other types of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em> <em>API</em> Extend data retention To learn how to extend how long events are retained in your account, see our documentation about <em>event</em> data retention."
      },
      "id": "609fa5fb64441f9ebfd2a1db"
    },
    {
      "sections": [
        "Query system limits",
        "Important",
        "What happens when you reach a limit",
        "Tip",
        "Create a dashboard to view your limit status",
        "Resource Consumption Limits as a %",
        "Max % Consumption in an hour",
        "APM Agent API transaction events request per minute",
        "Trace API With limit line",
        "Impact FACET",
        "NrIntegrationError by limit",
        "Multi-Account limits (on time series charts only)",
        "Limit list and NrIntegrationError",
        "Limit metrics",
        "newrelic.resourceConsumption.limitValue",
        "newrelic.resourceConsumption.currentValue",
        "newrelic.resourceConsumption.impact",
        "Metric attributes",
        "Set alerts on resource metrics",
        "Limits faceted by LimitName and scoped by Timewindow",
        "Alert on a single limit",
        "Alert on limit impact faceted by dataType, impact, resource, and reason",
        "Alert on impact of a single dataType"
      ],
      "title": "Query system limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest data manage data",
        "Manage data",
        "Resource metrics",
        "system limits"
      ],
      "external_id": "f8ca2368c70e4e339cd838d0ad192dd2c40fac0a",
      "image": "https://docs.newrelic.com/static/16cb17d5244a118d794df354f67bab81/c1b63/limits-dashboard.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/query-limits/",
      "published_at": "2021-07-29T01:48:00Z",
      "updated_at": "2021-07-22T06:31:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has resource limits in place to protect your experience, our systems, and our other customers. These limits range from the maximum number of characters you can have in a query, to API request rates, to how many events your queries inspect, and more. This page describes the limit metrics and NrIntegrationError events that enable you to view your limits, your current data usage and overall resource consumption as compared to those limits, and the impact of experiencing a limit event. We also provide a handful of queries that, when compiled into a dashboard, can give you consistent insight into your limits status. Important While NrIntegrationError events cover many limits, resource metrics currently only cover request rate ingestion limits. What happens when you reach a limit Our response to reaching a limit depends on a handful of factors: the type of limit that’s reached, as well as the duration, frequency, and amount at which you exceed the limit. Exceeding a limit doesn’t always mean you experience a limit event, such as dropped data, rejected traffic, or having your data turned off for the rest of the day. We sometimes allow a small buffer before enforcing a limit. That said, any resource consumed above 100% is at risk for limit impact at any time. Many of our rate limits apply proportionally. That means if you’re barely exceeding the limit, we will take less action than if you're exceeding by 200%. Limit metrics are only visible if you're sending data in to a corresponding dataType or limitName API. For example, if you send in data via the Metric API, you’ll see the Metric API resource metrics, but if you don't send any APM data in, you won't see APM resource metrics. Tip Impact metrics will be generated regardless of impact; if there's no impact, you’ll see a 0. An NrIntegrationError is generated when you experience impact and is a good way to quickly see if you’re experiencing any limit events. See View System Limits for more information. Create a dashboard to view your limit status Using three limit metrics together on a dashboard, you can quickly see detailed visuals of your Ingest Resource Request Per Minute limits, and with NrIntegrationError get a view into more limits. Dashboard displaying limits status using a handful of queries. We used the following queries to create this dashboard. To make a dashboard like this in New Relic One, select Dashboards, and then Create a dashboard. Then, add a new chart for each query you want to regularly monitor. The three limits metrics included in these queries are described in a separate section, below. From left to right, top to bottom: Resource Consumption Limits as a % FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) /latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName where limitTimeInterval = '1 minute' timeseries limit max Copy Max % Consumption in an hour SELECT max(`usage`) FROM (FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 as 'usage' facet limitName timeseries ) facet limitName limit max Copy APM Agent API transaction events request per minute FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) where limitName = 'APM Agent API transaction events requests per minute' TIMESERIES Copy Trace API With limit line FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'usage', latest(newrelic.resourceConsumption.limitValue) as 'limit' where limitName = 'Trace API requests per minute' TIMESERIES Copy Impact FACET From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource TIMESERIES 1 minute limit max Copy NrIntegrationError by limit FROM NrIntegrationError select count(*) facet limitName TIMESERIES MAX since 1 day ago limit max Copy Multi-Account limits (on time series charts only) If you want to see limits for multiple accounts on one chart: run this query from one of the accounts: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Click Add another query. Select a different account. Then run this query again: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Finally, save it. Limit list and NrIntegrationError FROM Metric, NrIntegrationError select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'Per Minute Count',latest(newrelic.resourceConsumption.limitValue) as ' limit Value',(rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue)*100)as 'Percent Used', filter (count(*), where NrIntegrationError.limitValue is not null) as 'limit reached count' facet limitName limit 1000 Copy Limit metrics These metrics, used in the dashboard queries above, can hone in on a single limit or resource. Or, with the help of FACET limitName or resource provide a view across all your limits. newrelic.resourceConsumption.limitValue limitValue allows you to see the setting for a limit by limitName and understand more about what resource is linked to this limit. The following examples use the limit value metric in the query: Example for Metric API requests per minute. FROM Metric select latest(newrelic.resourceConsumption.limitValue) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select latest(newrelic.resourceConsumption.limitValue) WHERE limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.currentValue currentValue shows you how much of a given resource you’re currently consuming. To get a better glimpse into how our systems are viewing your consumption, use a rate() function with the time period that aligns with the limitTimeInterval. Limit 200. Example for Metric API request per minute: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.impact impact lets you know for any given resource what impact limit events are having. Zeros mean you are not currently impacted. The most granular we have is dataType. It is possible for multiple instances of limitName to impact a single type, such as Metric RPM and DPM. If we know, we will display limitName. From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, resource, impact, limitName TIMESERIES limit max Copy Metric attributes Attributes on newrelic.resourceConsumption.limitValue and newrelic.resourceConsumption.currentValue: limitName - The Name of the limit for the metric data, i.e RPM Metric API. dataType - What kind of data the metric is tracking, i.e Metric, Log, or APM. Resource - What resource is being consumed, i.e. Requests, or DPM. limitTimeInterval - What time window this resource is evaluated for limiting. consumingAccountId - The New Relic account where the resource is being consumed. Attributes on newrelic.resourceConsumption.impact dataType - The kind of data that is being impacted, i.e Metric, Log, APM. Resource - What resource is being impacted, i.e Request Rate. Impact - A count of what is happening when resource has exceeded set limit, i.e dropped requests. consumingAccountId - The New Relic account where the resource is being consumed. Set alerts on resource metrics While building a dashboard to see all your limits is handy, being able to automate it is even better. You can set alerts on your limit metrics to provide updates on limits changes. Tip Because we currently only have metrics on 1 minute time windows, setting TimeWindow = 1 minute, will cover them all. Eventually, we make more metrics available, you might want to set separate alerts for limits that are enforced by different time windows. You can use the following NRQL queries to create alerts. Learn about creating alerts with NRQL queries here. Limits faceted by LimitName and scoped by Timewindow From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 facet limitName Copy Alert on a single limit From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 where limitName = 'my limit' Copy Alert on limit impact faceted by dataType, impact, resource, and reason From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason Copy Alert on impact of a single dataType From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason WHERE dataType = 'important things' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.5285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "APM <em>Agent</em> <em>API</em> transaction <em>events</em> request per minute",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": " limitName = &#x27;APM <em>Agent</em> <em>API</em> transaction events requests per minute&#x27; TIMESERIES Copy <em>Trace</em> <em>API</em> With limit line FROM <em>Metric</em> select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as &#x27;usage&#x27;, latest(newrelic.resourceConsumption.limitValue) as &#x27;limit&#x27; where limitName = &#x27;<em>Trace</em> <em>API</em> requests"
      },
      "id": "608abed9196a67a63064a7a6"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Create a \"Hello, World!\" application",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Customize your visualization with SDK components",
        "Nerdpack permissions",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-05-11T01:42:22Z",
      "title": "Build apps",
      "updated_at": "2021-05-11T01:41:00Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Customize your visualization with SDK components 25 min Customize your visualization Nerdpack permissions   Learn about permissions for using and subscribing accounts to Nerdpacks Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.08965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " Customize your visualization Nerdpack permissions   Learn about permissions for using and subscribing accounts to Nerdpacks Create a custom map view 30 min Build an <em>app</em> to show page view data on a map <em>Publish</em> and <em>deploy</em> <em>apps</em> 30 min Start sharing the <em>apps</em> you build Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure and deploy",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "28df1194ff848b2c26e5c966843d2bf5f0adbf9e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:50:44Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Copy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Copy Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 31.253109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "6043d8da28ccbc08242c60a6"
    },
    {
      "sections": [
        "Install the Go agent in GAE flexible environment",
        "Important",
        "Build a custom runtime using Docker",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure a Dockerfile",
        "4. Build a Docker image",
        "5. Deploy Docker image to initialized GAE flexible environment",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE"
      ],
      "title": "Install the Go agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Installation"
      ],
      "external_id": "9d2ddffb83697c6191c0b6abaed8839516b3aa54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-go-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:50:22Z",
      "updated_at": "2021-03-11T07:58:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our Go agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. Here we explain how to add New Relic to your GAE flex app by configuring a custom runtime, and give an example of deploying a Go app with Docker. Important The Go agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the Go agent, building a custom Go runtime for Docker, and deploying a golang application. For more information about deploying and configuring your Go app in the GAE flexible environment, see: Google App Engine's documentation for Go Google App Engine's tutorials to deploy a Go app 1. Set up the GAE project and install dependencies Follow standard procedures to install the Go agent for your specific app server, including your license key. Follow Google App Engine procedures for Go to create a new Cloud Platform project, create an App Engine application, download and install git, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example code defines the golang version used. FROM golang:1.8-onbuild CMD go run main.go Copy 4. Build a Docker image To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . Copy 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud --project go-app-name app deploy Copy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Copy Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see GAE's documentation for debugging an instance. To redirect New Relic Go agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 23.883669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "2. Configure your <em>app.yaml</em>",
        "body": " the gcloud command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure your <em>app</em>.yaml The <em>app</em>.yaml configuration file is required for a GAE flexible environment <em>app</em> with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy 3. Configure a Dockerfile The Dockerfile"
      },
      "id": "6043cd7164441fc312378efe"
    },
    {
      "sections": [
        "Install the Python agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure a Dockerfile",
        "4. Deploy Docker image to initialized GAE flexible environment",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE"
      ],
      "title": "Install the Python agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Hosting services"
      ],
      "external_id": "263d4c02b1f69a2acfd5949eb949045802324be4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/hosting-services/install-python-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:49:55Z",
      "updated_at": "2021-03-16T05:26:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Python agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding agent data to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic One. This document explains how to add agent data to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. For example, to deploy with native support for a Flask/Django app: Follow standard procedures to install the Python agent, including your license key. Set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to newrelic.ini. Once the agent and configuration file have been installed, the Python agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add agent data to your GAE flex app by building a custom runtime for Docker. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Our GAE flex examples on Github for Python Google App Engine's documentation for Python Google App Engine's tutorials to deploy a Python app 1. Set up the GAE project and install dependencies When building a custom runtime using Docker, set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to the Dockerfile instead of to your Python app's newrelic.ini. Follow standard procedures to install the Python agent, including your license key. Follow Google App Engine procedures Python to create a Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK also provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom Copy 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example shows the Python agent installed for an application served with gunicorn. These procedures are similar to the Python quick start guide. The Dockerfile will contain customer-specific code, including Python version, installation requirements, etc). # [START dockerfile] FROM gcr.io/google_appengine/python # Install the fortunes binary from the debian repositories. RUN apt-get update && apt-get install -y fortunes # Optional: Change the -p argument to use Python 2.7. RUN virtualenv /env -p python3.5 # Set virtualenv environment variables. This is equivalent to running # source /env/bin/activate. ENV VIRTUAL_ENV /env ENV PATH /env/bin:$PATH ADD requirements.txt /app/ RUN pip install -r requirements.txt ADD . /app/ CMD NEW_RELIC_CONFIG_FILE=newrelic.ini newrelic-admin run-program gunicorn -b :$PORT main:app # [END dockerfile] Copy 4. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Copy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse Copy To view your GAE flex app data, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Copy Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect Python agent logs to Stackdriver in the Cloud Platform Console, add the following statement to the newrelic.ini configuration: log_file = stderr Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 19.625206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "body": " explains how to <em>add</em> agent data to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime <em>Deploy</em> using GAE&#x27;s native support When using Google <em>App</em> Engine &quot;native mode&quot; installation, you provide"
      },
      "id": "603e8457196a675796a83dcc"
    },
    {
      "sections": [
        "Install New Relic Ruby agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "Tip",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure a Dockerfile",
        "4. Build a Docker image",
        "5. Deploy Docker image to initialized GAE flexible environment",
        "Recommendation: Handle health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Ruby agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Installation"
      ],
      "external_id": "3b7b7ad122a7ba4b37d5edf892bd462bac8fbe62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/installation/install-new-relic-ruby-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:50:23Z",
      "updated_at": "2021-03-13T07:26:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With APM's Ruby agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view using Full-Stack Observability options like APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime The custom runtime method includes an example of deploying a Sinatra app. If you need specific libraries or headers, New Relic recommends using the custom runtime method. Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. To deploy with native support for Sinatra or Rails: Follow New Relic's standard procedures to install the gem, including your license key. Install the Ruby agent configuration file. Once the gem and configuration file have been installed, the Ruby agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker Tip If your Ruby app needs specific libraries or headers, New Relic recommends using the custom runtime method. In addition, New Relic recommends that you allow Google App Engine to handle health checks. See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. The example uses a Sinatra app for Ruby. For more information about deploying and configuring your Ruby app in the GAE flexible environment, see: Google App Engine's documentation for Ruby Google App Engine's tutorials for Ruby 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Ruby agent, including your license key. Follow Google App Engine procedures for Ruby to create a new Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom entrypoint: bundle exec ruby app.rb Copy 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the recommended base image for apps monitored by the New Relic Ruby agent: FROM gcr.io/google-appengine/ruby:latest Copy 4. Build a Docker image Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build -f Dockerfile -t custom_ruby_app_container:latest . Copy After running this command, verify that you have a Docker image named custom_ruby_app_container and tagged latest. 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Copy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse Copy To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Handle health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. New Relic recommends that you allow health checks for Ruby apps so that Google can check that your service is up and balanced properly. However, if excessive health checks cause congested transaction traces, you can set the Ruby agent to ignore the health check requests. To handle health checks, add a route for _ah/health in your app. To ignore health check requests, set the rules.ignore_url_regexes config setting in the application’s Ruby agent config to include '_ah/health'. Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Ruby agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 19.500391,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "body": " like APM and browser monitoring. This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime The custom runtime method includes an example"
      },
      "id": "604404a6196a6738b9960f75"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "46f2be93b0c4daf40da9b93cfe0fbf5f235eecb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-07-29T01:47:07Z",
      "updated_at": "2021-07-16T03:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.97142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": "This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements may apply based on the method you use. You can report <em>custom</em> <em>events</em> to New Relic in several ways, including: APM <em>agent</em> <em>APIs</em> <em>Event</em> <em>API</em>"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-07-29T01:43:52Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.44548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser <em>API</em>&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "30a7ec0f78ddde237cb20265ab9702582f5bc2ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-07-29T01:43:51Z",
      "updated_at": "2021-07-09T22:19:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.36404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " and <em>events</em> You can create <em>custom</em> session-level attributes for default mobile monitoring <em>events</em> using the mobile <em>agent</em> SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute <em>API</em> (Android | iOS). These attributes are session-related"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-07-29T01:44:57Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.56905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " of <em>events</em> can increase the memory overhead of the <em>agent</em>. New Relic enforces an upper limit of 833 <em>custom</em> <em>events</em> every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the <em>custom</em> <em>event</em> limit. You can also send <em>custom</em> <em>events</em> using the <em>Event</em> <em>API</em>"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Tip",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-07-29T01:42:55Z",
      "updated_at": "2021-07-27T05:55:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve mobile monitoring data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, child accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.87195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "Introduction to New Relic <em>APIs</em>",
        "tags": "<em>APIs</em>",
        "body": " and original pricing plans that use the term &quot;Insights&quot; for these historical reasons. Insights-related <em>APIs</em> include: Resource Details <em>Event</em> <em>API</em> To report <em>custom</em> <em>events</em>, use the <em>Event</em> <em>API</em>. Query <em>API</em> To query your data using NRQL-format queries, you can use the Query <em>API</em>. Note that this <em>API</em> is deprecated"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/try-our-apis": [
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-29T01:40:31Z",
      "updated_at": "2021-07-27T11:27:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 563.3523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": "<em>NerdGraph</em> is our <em>GraphQL</em>-format <em>API</em> that lets you query <em>New</em> <em>Relic</em> data and configure some <em>New</em> <em>Relic</em> features. What is <em>NerdGraph</em>? <em>New</em> <em>Relic</em> has several <em>APIs</em>. <em>NerdGraph</em> is our preferred <em>API</em> for querying <em>New</em> <em>Relic</em> data, and for performing some specific configurations (learn more about features"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Tip",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-07-29T01:42:55Z",
      "updated_at": "2021-07-27T05:55:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve mobile monitoring data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, child accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 540.08966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>APIs</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>APIs</em>",
        "tags": "<em>APIs</em>",
        "body": " developer.newrelic.com. <em>NerdGraph</em> (<em>GraphQL</em>) <em>NerdGraph</em> is <em>New</em> <em>Relic</em>&#x27;s <em>GraphQL</em>-format <em>API</em>, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. <em>NerdGraph</em> is the preferred <em>API</em> for querying <em>New</em> <em>Relic</em> data and making a range of feature"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 503.09586,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add the <em>NerdGraphQuery</em> component to an application",
        "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and <em>GraphQL</em>, you can create custom views tailored to your business. These guides are designed to help you start"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Introduction to querying data in New Relic",
        "Important",
        "Our open door to your data",
        "Browse your data in the UI",
        "Query data in the UI",
        "Tip",
        "Query data via API"
      ],
      "title": "Introduction to querying data in New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Understand data"
      ],
      "external_id": "f3f9efbd4d9565c83ad8224f1f1524f9a5957650",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/get-started/introduction-querying-new-relic-data/",
      "published_at": "2021-07-27T22:23:05Z",
      "updated_at": "2021-07-27T22:23:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is a powerful observability platform that gives you access to all your data throughout your entire system. We host telemetry data sent by your entities, which basically is anything we can identify that has data you can monitor, including applications, services, hosts, etc. You name it! While we provide you with an out of the box experience to see your data with curated dashboards, you can tailor the access to your data and custom the visibility in several ways, including in the UI or via API. Important To better understand your data stored in New Relic, see Data types. Our open door to your data Regardless of your experience with New Relic, we’ll help you discover, understand and visualize your data. You... Then do this... Just installed an agent and want to see your data in New Relic. Browse your data easily without building queries. With the data explorer, you can understand the data we’ve stored, see its cardinality, or build charts in a few clicks. Know what data is available, but you want to understand more about what else is coming with that data. If you’re an advanced user, use our query builder to tailor the data you want to retrieve. Have a specific question and you want to deep dive on the data to get the answer. Refine your NRQL query to dig down to the bottom of your issues. Want to build a dashboard. Create a custom dashboard easily from the data explorer or the query builder. Browse your data in the UI New Relic One offers several experiences that don't require knowledge of NRQL or any query language. On the UI, go to the Query your data button, or click the Browse data dropdown, then select the data type (metrics, events, logs, and traces) you want to explore. For events and metrics, use the data explorer, an intuitive data navigator to create visualizations. From the explorer you can switch to the query builder to see and refine your query. Distributed tracing query: a specialized UI for querying traces. Logs query: a specialized UI for querying New Relic Logs data. Query data in the UI If you're ready to do more than browsing data, become an all-hands actor and personalize your queries in the New Relic UI. Use query languages, including our New Relic query language or our PromQL-style query language, to edit queries with full flexibility. For example, you can add more WHERE clauses, modify the returned value, change to other types of visualizations, etc. Tip Are you new to querying languages? Start browsing data in the data explorer, then turn to the query builder to see the query you built, and refine it. There are two ways to write your own queries to retrieve data and build charts: Query builder in NRQL mode: Query using New Relic query language (NRQL), the same language we use to build most of our UI experiences, and the most advanced way of querying data in New Relic. Query builder in PromQL-style mode: Write basic queries using a PromQL-style query. Query data via API When getting into the New Relic platform is not an option, you can use APIs to retrieve and query your data in New Relic. For example, you can run NRQL (our query language) queries with NerdGraph (our GraphQL API). For more information, see the introduction to New Relic APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 494.08795,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to querying data in <em>New</em> <em>Relic</em>",
        "sections": "Introduction to querying data in <em>New</em> <em>Relic</em>",
        "tags": "<em>Telemetry</em> Data <em>Platform</em>",
        "body": " is not an option, you can use <em>APIs</em> to retrieve and query your data in <em>New</em> <em>Relic</em>. For example, you can run NRQL (our query language) queries with <em>NerdGraph</em> (our <em>GraphQL</em> <em>API</em>). For more information, see the introduction to <em>New</em> <em>Relic</em> <em>APIs</em>."
      },
      "id": "609f9e1de7b9d2c96ac3eb08"
    },
    {
      "sections": [
        "Introduction to Alerts",
        "Build a comprehensive alerting solution",
        "Unique, intelligent features",
        "Data security and privacy",
        "What's next?"
      ],
      "title": "Introduction to Alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "7c546ec2cc72b64dac931609e315b2121ffeab78",
      "image": "https://docs.newrelic.com/static/e3443ab0a75369f185c84676e46c0ee0/c1b63/new-relic-set-thresholds-example_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/introduction-alerts/",
      "published_at": "2021-07-27T08:51:52Z",
      "updated_at": "2021-07-27T08:51:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts lets you set up robust and customizable alert policies for anything that you can monitor. Receive notifications for fluctuations in key performance metrics as data streams in from all of our products, including APM, infrastructure, browser, mobile, and NRQL queries. Build a comprehensive alerting solution Go to one.newrelic.com, then click Alerts & AI > Create condition: This shows the threshold-setting UI page when creating an alert condition. We give you control over every part of creating a robust alerting solution for your applications and architecture: Decision Steps Decide what to monitor. You can set up alert conditions for any monitored data source. Whether your architecture has just a few components or many, you'll be able to create an effective alerting solution. Define how it will be monitored. You can define exactly what data source behavior opens a violation. Unique features include: Extensive control over the time and frequency settings that opens a violation and a notification. Set critical thresholds for obvious performance problems and optional warning thresholds for when behavior is approaching critical. Baseline alert conditions that automatically adjust to your system's behavior. You decide how sensitive you want the thresholds to be. Decide how incidents are generated. To reduce notification fatigue, incident preference settings give you control over how notifications are created. For example, you may want to receive a notice for every violation or only want a single notification for a series of consecutive violations. Decide how notifications are sent. We offer customizable notification channels via many common services, including email, mobile push notifications, OpsGenie, Slack, and more. To see supported services, see Notification channels. Unique, intelligent features Besides the standard controls you'd expect from a complete alerting solution, we offer some unique and powerful features, including: Feature Details Self-adjusting monitoring Baseline alert conditions allow you to create intelligent, self-adjusting conditions. Anomaly detection An anomalous behavior indicator automatically detects when a violation has occurred within a few minutes of major changes in key database or external service activity. Detect outliers from group behavior Use outlier detection to detect when one or more data sources in a defined group deviate from the behavior you expect from that group. Custom query conditions Using our NRQL query language, create a customized query, and then monitor the results of that query for deviations over time. NerdGraph API Use our GraphQL NerdGraph API to interact with alerts. We recommend the NerdGraph API over the REST API because it has the latest features. Alerts REST API Use the REST API to return information about your alert settings or to create alert policies and conditions. We recommend you start with the NerdGraph API to see if it has the options you need. Webhooks Customizable webhooks allow you to define custom headers, basic authentication, custom payloads, and more. Incident scoping and rollups Every alert policy can be configured to use one of three violation grouping strategies to control the number of alert incidents created, and therefore the number of notifications sent. Cross-product events A dedicated Events page that shows operational events across all of your products. Data security and privacy By default, Alerts doesn't record any personal data. In addition, it automatically sets default permissions for individual account users and access levels within account structures. For more information about our security measures, see our security and privacy documentation, or visit our security website. What's next? If you're new to using Alerts and want to learn more, see: The basic process Best practices",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 458.4673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> Alerts",
        "body": " deviate from the behavior you expect from that group. Custom query conditions Using our NRQL query language, create a customized query, and then monitor the results of that query for deviations over time. <em>NerdGraph</em> <em>API</em> Use our <em>GraphQL</em> <em>NerdGraph</em> <em>API</em> to interact with alerts. We recommend the <em>NerdGraph</em>"
      },
      "id": "603ed00c28ccbc6f03eba79d"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-07-30T01:43:07Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 631.0598,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple tags to one"
      },
      "id": "6091f7c828ccbc8813a268b2"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Automate workflows",
      "updated_at": "2021-07-29T01:39:17Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 570.26636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Partial or missing logs for RDS, VPC, AWS Lambda",
        "Problem",
        "Solution"
      ],
      "title": "Partial or missing logs for RDS, VPC, AWS Lambda",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "Troubleshooting"
      ],
      "external_id": "66a81a2fa3b8b27bf6172c9bb2c3ecf28bbe13e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/troubleshooting/partial-or-missing-logs-rds-vpc-aws-lambda/",
      "published_at": "2021-07-28T07:17:09Z",
      "updated_at": "2021-03-13T01:15:24Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You are using NewRelic-log-ingestion, the lambda function for pushing logs from AWS to our RDS Enhanced Monitoring, VPC Flow Logs integrations, or early versions (alpha and beta) of monitoring for AWS Lambda. It is not working or it is sending partial data. Solution The NewRelic-log-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the New Relic CLI or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update the function using the New Relic CLI. You can also update the function manually: Avoid false positives in alerting: Follow UI procedures or API procedures to disable all alert conditions associated with monitoring integrations with AWS Lambda, RDS Enhanced Monitoring, and VPC Flow Logs. Remove the outdated lambda version of the lambda: Go to your AWS Lambda Console, and remove newrelic-log-ingestion. Be aware that this stops the RDS Enhanced Monitoring and the VPC Flow Logs integration until the next step is completed. Re-enable the service: Follow the instructions in RDS Enhanced Monitoring or VPC Flow Logs, or follow the step to configure CloudWatch logs to stream to New Relic Lambda. Check that your data is flowing through the new lambda.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 384.29404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the <em>New</em> <em>Relic</em> <em>CLI</em> or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update"
      },
      "id": "60450c97196a672ffa960f57"
    },
    {
      "sections": [
        "Secrets management",
        "Define secrets",
        "Important",
        "Tip",
        "Using environment variables",
        "Secrets variables",
        "AWS KMS secrets",
        "Vault secrets",
        "tls_config properties",
        "CyberArk command line interface",
        "CyberArk REST API",
        "New Relic CLI Obfuscation"
      ],
      "title": "Secrets management",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "Installation"
      ],
      "external_id": "8e05204a80a9475aee87d85a4be07cff710faa31",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management/",
      "published_at": "2021-07-27T15:33:33Z",
      "updated_at": "2021-03-16T06:02:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and New Relic CLI obfuscation are supported. Define secrets To use secrets in a configuration YAML file: Define a variables section, where each entry is a name for a secret object. In each entry, include the source of the secret and the proper configuration to retrieve those secrets. In the general configuration section, set ${variable.property} placeholders that will be automatically replaced by the properties of the secret object. The secret object can be defined as a simple string or json object. Important If the secrets retrieval fails, the integration won't be executed, as the infrastructure agent does not have all the data it requires to execute. For example, the following configuration will retrieve an object named creds from Vault (you can define the object's name for the secret.) Let's assume that the stored object is a valid JSON with a property named user and another property named password. We want to use them to set the basic HTTP credentials of the status_url property from an Nginx on-host integration: integration_name: com.newrelic.nginx variables: creds: vault: http: url: http://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true labels: env: production role: load_balancer Copy Tip Both simple strings and valid JSON objects can be retrieved from variables. When using JSON objects make sure both keys and values are enclosed with double-quotes. Using environment variables Environment variables can be used into the variables section with the {{MY_ENV_VAR}} notation. When doing so, environment variables are expanded and their value is replaced at runtime. Use this method to avoid having sensitive values such as tokens or obfuscation keys included in the configuration file. When using environment variables in on-host integration configuration files the passthrough_environment setting must be defined. Secrets variables Define secrets in each configuration under a variables section. Each entry is a user-defined secret name that will store the properties of the retrieved secrets. Each variable can contain the following properties: YAML key Description ttl Type: String Amount of time before a secret is refreshed. This can be a number followed by a time unit (s, m or h). Examples: 30s, 10m, 1h Default: 1h aws-kms AWS KMS secret retrieval configuration vault Vault secret retrieval configuration cyberark-cli CyberArk command line interface configuration cyberark-api CyberArk REST API configuration obfuscated New Relic CLI obfuscation AWS KMS secrets To retrieve your secrets from Amazon KMS, you can set the following properties in your aws-kms section. Not all fields are required. For example, you will need either data, file, or http to provide the encoded KMS string. YAML key Description data Type: String Base64 encoded KMS string to decrypt file Type: String Path to file containing Base64 encoded KMS string to decrypt http Type: YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file region Type: String AWS KMS region type Type: String (plain, equal, or json) Secret value format: plain: a raw string to be stored directly into the destination variable. equal: a key=property one-line string to be stored as object properties into the destination variable. json: a JSON object to be stored as properties into the destination variable. Secrets of type plain or json use dot notation; for example, ${mysecret.nestedkey}. The following example will allow retrieving a plain password string from AWS KMS. It must be decrypted from the provided data encoded string. variables: myPassword: aws-kms: data: T0hBSStGTEVY region: ap-southeast-2 credential_file: \"./my-aws-credentials-file\" config_file: \"./my-aws-config-file\" type: plain Copy Vault secrets Vault must enable an http field containing the HTTP configuration used to connect to Vault. The http entry can contain the following entries: YAML key Description url Type: String URL to request data from tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers tls_config properties Important Secrets must use dot notation, for example, ${mysecret.nestedkey}. YAML key Description enable Type: Boolean Enable TLS Default: false insecure_skip_verify Type: Boolean Skip verifying server’s certificate chain and host Default: false min_version Type: UInt16 The minimum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.0) max_version Type: UInt16 The maximum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.3) ca Type: String TLS certificate \"\" The following example will retrieve a secret using a Vault token from a secured server, and skip the server certificates verification: variables: mydata: vault: http: url: https://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token tls_config: insecure_skip_verify: true Copy CyberArk command line interface To retrieve secrets from the CyberArk command line interface (CLI) use the following configuration, all keys are required YAML Key Description cli Type: string Full path to the CyberArk CLI executable Default: \"\" app-id Type: string Application id of the secret holder Default: \"\" safe Type: string Safe containing the secret Default: \"\" folder Type: string Folder containing the secret Default: \"\" object Type: string The object the secret is associated with Default: \"\" The following example will retrieve a CyberArk secret using the command line interface: variables: credentials: cyberark-cli: cli: /full/path/to/clipasswordsdk app-id: my-appid safe: my-safe folder: my-folder object: my-object Copy CyberArk REST API To retrieve secrets using the CyberArk REST API there must be a http key containing the HTTP configuration. The http key contains these sub-keys, only url is required: YAML key Description url Type: String URL to request data from, this key is required Default: none tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers The following example will retrieve a secret using the CyberArk REST API, skipping server certificate verification: variables: credentials: cyberark-api: http: url: https://hostname/AIMWebService/api/Accounts?AppID=myAppID&Query=Safe=mySafe;Object=myObject tls_config: insecure_skip_verify: true Copy New Relic CLI Obfuscation Important We recommend using any of the supported secrets providers instead of the simple obfuscation when possible. See our guidelines below to define environment variables to avoid having the obfuscation key in configuration files. Tip Infrastructure Agent 1.14.0 or above is required You can use the New Relic CLI obfuscate command to obscure sensitive information in the infrastructure agent or any on-host integration configuration file. Steps: Install the New Relic CLI on any host (it can be your development host). Run the CLI obfuscate command in order to generate the obfuscated value: newrelic agent config obfuscate --value '<plain_text_config_value>' --key '<obfuscation_key>' Copy Copy the result of the cli command into the text argument in the obfuscated section as shown in the examples below. YAML key Description key Type: String The string used when obfuscating the clear-text value using New Relic CLI Default: none secret Type: String The output of the newrelic-cli command Default: none Integrations configuration example The following example will allow retrieving the Nginx user and password that has been obfuscated using the New Relic CLI: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy It's recommended to use environment variables for the obfuscation arguments as shown in the example below: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: {{OBFUSCATION_KEY}} secret: {{OBFUSCATION_TEXT}} instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy Agent configuration example This example allows retrieving a string that contains the proxy details (user, password and host): variables: obfuscated_proxy: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' proxy: ${obfuscated_proxy} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.7945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Obfuscation",
        "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and <em>New</em> <em>Relic</em> <em>CLI</em> obfuscation are supported. Define secrets"
      },
      "id": "603eaeeae7b9d28cdf2a07dd"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-05-05T01:53:28Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 355.1606,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> One app",
        "body": "To build a <em>New</em> <em>Relic</em> One app, you must install the <em>New</em> <em>Relic</em> One <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> One <em>CLI</em> (command line interface). This page explains how to use <em>CLI</em> commands to: Generate"
      },
      "id": "6091fa9864441feb412f36d4"
    }
  ],
  "/terraform/terragrunt-configuration": [
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-06-25T01:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostConditions directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_policy\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your main.tf and provider.tf to the stage for commit: bash Copy $ git add main.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.69788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "6091fa98e7b9d2063e506919"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.22687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-07-27T14:08:28Z",
      "updated_at": "2021-07-22T04:34:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more child accounts, the notification channel includes only users for the currently selected parent or child account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.8445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-07-30T01:41:42Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.85991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091b486196a675dc3d52a6f"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.86888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091fa9928ccbc8a70a268ac"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table/",
      "sections": [
        "Table",
        "Usage",
        "Examples",
        "Props",
        "Type definitions",
        "Cursor",
        "SelectedCallbackArgument"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "Table",
      "updated_at": "2021-06-25T01:44:11Z",
      "type": "developer",
      "external_id": "878b3ab08dbd0a7df42558a970648013adde957f",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table with a fixed header and rows. The table implements the following features: Flexible layout: table headers accept a variety of sizes to enable fluid and fixed layouts. You can find more information on how to customize your columns checking TableHeaderCell. Sorting: items passed can be internally sorted by the table according to the current sorting state of the table. You can find more information about sorting by checking TableHeaderCell. Row selection: rows can be selected through checkboxes on the right hand side. You can find more information in the selected prop. Row actions: contextual actions can be triggered per row, enabling users to achieve functionality over them. You can find more information on how to add them in TableRow. Custom pre-defined cells: some very common patterns for cells (entity title, metrics, etc.) are already provided by the platform, so that you only need to return it as part of your row. Virtualization: cells are only rendered if they are shown on screen. This enables the table to work with a large dataset with almost no performance penalty. Usage import { Table } from 'nr1' Copy Examples Props ariaLabelstring Provide an accessibility label that describes the purpose of the table, e.g. \"All entities\". children(node|function)[] Contents of the table. Table can only contain as children <TableHeader> and a function returning <TableRow>s. classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. compactboolean DEFAULT false Establishes whether the table should render in compact mode (compact mode has narrower rows). In general, use the standard mode, since compact is reserved for data representation, e.g. in a dashboard. itemsany[] DEFAULT [] The items to be used when rendering. They are required when rendering items with a render callback. Each item can have any structure and type possible, and will the corresponding one will be provided when rendering each element list. mainColumnnumber DEFAULT 0 Column containing the main data identifying the row. Often the first column (index 0) is the relevant one, but actions (like favorites) could be placed before it. onLoadMorefunction Callback fired when more items must be loaded. This happens when you're lazy loading the items and the items that are about to render cannot be found in the items array. This callback should be used to fetch/load the missing items from the backend or other sources. The returned Promise should be resolved once item data has finished loading. It will be used to determine when to refresh the list with the newly-loaded data. This callback may be called multiple times in reaction to a single scroll event. function ( cursor : Cursor // Items to load. ) onSelectfunction Function called when the user clicks over a row checkbox. It is called with the event of the checkbox, as well as with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. When the user selects or unselects the header checkbox (select / unselect all), the callback will be called once for every item, representing individual clicks over each row. The header checkbox state is automatically controlled by the table. function ( event : React.ChangeEvent, selectedItem : SelectedCallbackArgument ) rowCountnumber Number of rows. By default it's equal to length of array passed in the items prop. You should specify the rowCount when you know the total number of items but you want to lazy load them while scrolling. selectedfunction Function that returns whether a row is selected. It needs to return a boolean representing the state of the row. It is called with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. function ( item : SelectedCallbackArgument ) => boolean selectionTypeenum DEFAULT Table . SELECTION_TYPE . BULK Sets the selection mode of the Table. Use it along with onSelect and selected props to determine which row is checked by the user. Table.SELECTION_TYPE.BULK displays checkboxes per each row, along with a checkbox in the header to select all items. When an item is selected, header actions become available. Table.SELECTION_TYPE.SINGLE doesn't display checkboxes, the user picks a row by just clicking on it. Though not enforced in the component, the selected callback should return true only for one item. Check the examples of the component to see how it works. <One of Table.SELECTION_TYPE.BULK , Table.SELECTION_TYPE.SINGLE , > spacingTypeenum[] Spacing property. Spacing is defined as a tuple of zero to four values, which follow the same conventions as CSS properties like margin or padding. To omit a value, use SPACING_TYPE.OMIT. <Array of <One of Table.SPACING_TYPE.EXTRA_LARGE , Table.SPACING_TYPE.LARGE , Table.SPACING_TYPE.MEDIUM , Table.SPACING_TYPE.NONE , Table.SPACING_TYPE.OMIT , Table.SPACING_TYPE.SMALL , > > styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. Type definitions Cursor { startIndex : number, // First index of the range of items to load. stopIndex : number, // Last index of the range of items to load. } SelectedCallbackArgument { item : any, // Item to check. index : number, // Index of the item in the items array. items : any[], // Array of all items passed. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 745.1166,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Table</em>",
        "sections": "<em>Table</em>",
        "body": " be internally sorted by the <em>table</em> according to the current sorting state of the <em>table</em>. You can find more information about sorting by checking <em>TableHeaderCell</em>. <em>Row</em> selection: rows can be selected through checkboxes on the right hand side. You can find more information in the selected prop. <em>Row</em>"
      },
      "id": "6091f91ee7b9d24aff506897"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-header-cell/",
      "sections": [
        "TableHeaderCell",
        "Usage",
        "Props"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "TableHeaderCell",
      "updated_at": "2021-06-25T01:44:11Z",
      "type": "developer",
      "external_id": "2a4be1419d1a6e501a8eed915b8acf7c9798259d",
      "document_type": "page",
      "popularity": 1,
      "body": "Wraps the content of a table cell located in the header of the table, by keeping them at the top and adding additional controls as required, e.g. sorting mechanisms. Usage import { TableHeaderCell } from 'nr1' Copy Props alignmentTypeenum DEFAULT TableHeaderCell . ALIGNMENT_TYPE . LEFT Defines the text alignment inside the cell. <One of TableHeaderCell.ALIGNMENT_TYPE.CENTER , TableHeaderCell.ALIGNMENT_TYPE.LEFT , TableHeaderCell.ALIGNMENT_TYPE.RIGHT , > childrennode Contents of the table cell. If left empty, make sure you pass title so that users get a reference about the data the column shows. classNamestring Appends class names to the component. onClickfunction Callback fired any time the user clicks on the header. When clicked, sorting information (and the next sorting state) will be passed as the second parameter. Use it rather than computing it yourself. function ( event : React.MouseEvent, sortingData : Object ) sortableboolean DEFAULT false Whether the column is sortable. This means that the up and down arrows will be shown, side to the heading text. Sorting is a controlled component interface, you are in charge of listening for the sorting event and applying the sorting to the corresponding column, by changing its sortingOrder prop. sortingFunctionfunction Method for sorting rows. The default method will usually do the right thing (alphabetical ordering for text, numerical ordering for numbers and boolean grouping), but if needed this can be overridden. The function takes two parameters (a and b) and has to return a negative number if a is considered to appear before b, a positive one if it's considered to appear after, and zero if both values are identical. Each of the objects passed to the callback contains the value for the given row (i.e. the result of calling value over the row), the row item (as item), the index of the row (as index) and all the items in the items array (as items). Generally you will compare rows using a.item and b.item. function ( a : object, b : object ) => number sortingOrdernumber DEFAULT Number . MAX_SAFE_INTEGER Establishes the sorting order. A lowest number indicates a highest sorting priority, meaning that 0 will be the first column sorted, and if two items are identical, we will use column 1 and so on. Columns that do not have an explicit sorting order are used after all columns that do have it, and they are applied in order of appearance. sortingTypeenum DEFAULT TableHeaderCell . SORTING_TYPE . NONE Establishes the sorting for the column. Columns are sorted based on the element returned by the value prop. <One of TableHeaderCell.SORTING_TYPE.ASCENDING , TableHeaderCell.SORTING_TYPE.DESCENDING , TableHeaderCell.SORTING_TYPE.NONE , > styleobject Inline style for custom styling. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. titlestring Establishes the title of the cell. This is used for tooltip purposes, when the width of the column is small enough to not show the entire heading. Defaults to the stringified version of the provided children. valuefunction Function that is used to extract the raw value representing a column. The raw value may be a boolean (e.g. if you render a checkbox), a number (if you render a metric) or text for others. It is called with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. This function is used for sorting the table (by the given value) as well as for the heuristics of 'fit-content' widths. widthstring DEFAULT 1fr Represents the width of the column. It is always a string, and it can be of one of the following types: 'fit-content': the column will take the minimum required space to allocate all items in the column. For virtualized lists, a heuristic will be used to avoid rendering all cells. 'YYpx': where YY is a number, represents the width of the column in pixels. 'YY%': where YY is a number, represents the width of the column in percentage, relative to the size of the available space where the table is being rendered. 'YYfr': where YY is a number, it represents a fraction of the available width. Fractions are proportional ones to others; for instance, a table with two columns (1fr and 2fr) will have the second column twice as large as the first one. If, after computing the widths, the overall size of the table does not cover the available space, all columns will be proportionally stretched to fit all available space.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 605.97107,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableHeaderCell</em>",
        "sections": "<em>TableHeaderCell</em>",
        "body": "Wraps the content of a <em>table</em> <em>cell</em> located in the <em>header</em> of the <em>table</em>, by keeping them at the top and adding additional controls as required, e.g. sorting mechanisms. Usage import { <em>TableHeaderCell</em> } from &#x27;nr1&#x27; Copy Props alignmentTypeenum DEFAULT <em>TableHeaderCell</em> . ALIGNMENT_TYPE . LEFT Defines"
      },
      "id": "6091f91d196a67fb19d52a35"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-row-cell/",
      "sections": [
        "TableRowCell",
        "Usage",
        "Examples",
        "Props",
        "shape"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "TableRowCell",
      "updated_at": "2021-06-25T01:44:11Z",
      "type": "developer",
      "external_id": "2a8a8520a7c1bbcba96ca9a96de7918d74adb7f2",
      "document_type": "page",
      "popularity": 1,
      "body": "Wraps the content of a table cell located in the body of the table. This component is only expected to be used as a children of <TableRow>. Cells take care automatically of ellipsifying the content that does not fit and vertically centering it. This component is the base cell. For common cases, the SDK also provides a set of additional cells so that they always painted consistently across the UI (e.g. entity name with a status, or a user). Usage import { TableRowCell } from 'nr1' Copy Examples Props alignmentTypeenum DEFAULT TableRowCell . ALIGNMENT_TYPE . LEFT Defines the text alignment inside the cell. <One of TableRowCell.ALIGNMENT_TYPE.CENTER , TableRowCell.ALIGNMENT_TYPE.LEFT , TableRowCell.ALIGNMENT_TYPE.RIGHT , > childrennode DEFAULT null Contents of the table cell. classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. ellipsisTypeenum DEFAULT TableRowCell . ELLIPSIS_TYPE . RIGHT Defines how values are ellipsified within the cells; i.e. where the ellipsis is placed: RIGHT: at the end of the text, preserving its beginning. LEFT: at the beginning of the text, preserving its end. <One of TableRowCell.ELLIPSIS_TYPE.LEFT , TableRowCell.ELLIPSIS_TYPE.RIGHT , > onClickfunction Callback fired any time the user clicks on the table cell. function ( event : React.MouseEvent ) styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. toshape|string Location object or url string to link to. Linked TableRowCells are unstyled and will not show icons for external links. If the same styling as the Link component is what is desired, then use a Link instead as a child component within the cell. shape pathnamerequiredstring searchstring hashstring",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 476.66623,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableRowCell</em>",
        "sections": "<em>TableRowCell</em>",
        "body": "Wraps the content of a <em>table</em> <em>cell</em> located in the body of the <em>table</em>. This <em>component</em> is only expected to be used as a children of &lt;<em>TableRow</em>&gt;. Cells take care automatically of ellipsifying the content that does not fit and vertically centering it. This <em>component</em> is the base <em>cell</em>. For common cases"
      },
      "id": "6091f91de7b9d2307a50690b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 352.8783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the NerdGraphQuery <em>component</em> to an <em>application</em>",
        "body": " visualization with configuration options 10 min Customize your visualization using configuration Add a <em>table</em> to your <em>app</em> 30 min Add a <em>table</em> to your New Relic One <em>app</em> Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an <em>app</em> to show page view data on a map"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/metric-table-row-cell/",
      "sections": [
        "MetricTableRowCell",
        "Usage",
        "Examples",
        "Props",
        "shape"
      ],
      "published_at": "2021-07-30T01:49:25Z",
      "title": "MetricTableRowCell",
      "updated_at": "2021-06-25T01:54:31Z",
      "type": "developer",
      "external_id": "b3f3bb23254c69af9c2c0f5350018bae35f5506c",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular metric. The metric is formatted according to the unit passed. Units are 1:1 compatible with the ones supported by <NrqlQuery> format type CHART. Unit and prefix formatting is automatically picked for you so that it is consistent with the rest of the platform. Metrics are automatically aligned to the left, and ellipsified from the right, which is the standard way for presenting them. Usage import { MetricTableRowCell } from 'nr1' Copy Examples Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : React.MouseEvent ) styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. toshape|string Location object or url string to link to. Linked TableRowCells are unstyled and will not show icons for external links. If the same styling as the Link component is what is desired, then use a Link instead as a child component within the cell. shape pathnamerequiredstring searchstring hashstring typeenum DEFAULT MetricTableRowCell . TYPE . UNKNOWN Unit of the provided metric. Will be used for auto-formatting the numerical value. <One of MetricTableRowCell.TYPE.APDEX , MetricTableRowCell.TYPE.BITS , MetricTableRowCell.TYPE.BITS_PER_MS , MetricTableRowCell.TYPE.BITS_PER_SECOND , MetricTableRowCell.TYPE.BYTES , MetricTableRowCell.TYPE.BYTES_PER_MS , MetricTableRowCell.TYPE.BYTES_PER_SECOND , MetricTableRowCell.TYPE.COUNT , MetricTableRowCell.TYPE.HERTZ , MetricTableRowCell.TYPE.MS , MetricTableRowCell.TYPE.PAGES_PER_SECOND , MetricTableRowCell.TYPE.PERCENTAGE , MetricTableRowCell.TYPE.REQUESTS_PER_SECOND , MetricTableRowCell.TYPE.SECONDS , MetricTableRowCell.TYPE.TIMESTAMP , MetricTableRowCell.TYPE.UNKNOWN , > valuerequirednumber Metric value, always in the shape of a number.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " of the platform. Metrics are automatically aligned to the left, and ellipsified from the right, which is the standard way for presenting them. Usage import { Metric<em>TableRowCell</em> } from &#x27;nr1&#x27; Copy Examples Props classNamestring Appends class names to the <em>component</em>. Should be used only for positioning"
      },
      "id": "6091f8ce196a67bff9d52a48"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Automate workflows",
      "updated_at": "2021-07-29T01:39:17Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 5246.2656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " <em>using</em> <em>Helm</em> <em>charts</em> 20 min Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> <em>Use</em> <em>New</em> <em>Relic</em> to diagnose problems 30 min Learn to diagnose problems <em>using</em> <em>New</em> <em>Relic</em>."
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-07-27T18:06:54Z",
      "updated_at": "2021-07-27T18:06:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.21654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and <em>update</em> CPM versions",
        "body": ". This is necessary for it to report data to <em>New</em> <em>Relic</em> and to receive monitors to execute. Ask your network administration if this is a problem and how to <em>set</em> <em>up</em> exceptions. Communicate with Synthetics via a proxy To <em>set</em> <em>up</em> communication with <em>New</em> <em>Relic</em> by proxy, <em>use</em> the environment variables named"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Use Auto-telemetry with Pixie for instant Kubernetes observability",
        "Why it matters",
        "Important",
        "Install Auto-telemetry with Pixie",
        "Before you begin",
        "Install from the beginning of the guided install process",
        "Install from the Configure the HELM command/manifest (yaml) file",
        "Helm method",
        "manifest method",
        "Explore your cluster",
        "Tip",
        "Investigate usage spikes with Flamegraph",
        "Debug live"
      ],
      "title": "Use Auto-telemetry with Pixie for instant Kubernetes observability",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "fcb7ee18f84381b6ac06911deb127f94d298b03b",
      "image": "https://docs.newrelic.com/static/1e793128e5d6019bbebd8123dbf943ab/c1b63/service-graph.png",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/get-started-auto-telemetry-pixie/",
      "published_at": "2021-07-30T01:55:43Z",
      "updated_at": "2021-07-28T01:58:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When we say auto-telemetry, we’re not talking about cars — we're talking about instant baseline visibility into your Kubernetes clusters. With the New Relic One integration with Pixie, you get similar data to traditional language agents, but without manually instrumenting your code or redeploying your application. Pixie auto-telemetry is powered by eBPF, a virtual machine-like construct that enables Pixie to seamlessly collect fine-grained telemetry data — service-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your Kubernetes clusters and workloads. No language agents required. Live debugging with Pixie shows a service graph listing the namespaces and the node that are available on the current cluster. Simply put, Auto-telemetry with Pixie offers the quickest option for getting observability into your Kubernetes services. Why it matters Our Pixie integration gives you the best of both worlds: Pixie’s fast and simple Kubernetes observability coupled with New Relic One’s incident correlation, intelligent alerting, and long-term retention. You’ll get visibility into HTTP services using golden signals, HTTP transactions, database transactions, distributed tracing, and JVM metrics. You can operate, debug, and scale your Kubernetes clusters based on the information you learn about how your clusters and services are running. Using the New Relic Explorer, you can see key metrics and events at every level, starting with the cluster, and diving down into namespaces, deployments, and pods. You can quickly spot anomalous behavior, and where it’s happening. And then dive deeper using embedded visualizations of your Pixie data. Quickly identify hot spots with Flamegraph. On the Live debugging with Pixie tab, answer questions like what SQL requests your app is making or which services are talking to each other. Important Auto-Telemetry with Pixie leverages Community Cloud with Pixie, a separate platform from New Relic One. Use of Community Cloud with Pixie is subject to separate terms of service. Install Auto-telemetry with Pixie Use our guided installation process to install Auto-telemetry with Pixie. This deploys Pixie with New Relic's Kubernetes integration on your cluster. You don't need to do any further configuration or installation to start using Pixie. If you want to install Auto-telemetry with Pixie on multiple clusters, re-run the guided install for each additional cluster. Before you begin Review this Pixie data security overview for actions to take to secure your data. Make sure you have sufficient memory: Pixie requires 2Gb of memory per node in your cluster. Important If you are already a Pixie user, you must still install using the guided installation steps described below. This will provide the API keys that you need. Install from the beginning of the guided install process Open our New Relic One guided install. Select the account you want to use for the guided install, and click Continue. Note: if you have a single account, you won't see this option. Select Kubernetes and then continue with step one in the next section. Install from the Configure the HELM command/manifest (yaml) file If you arrived in the guided installation process by following a link from Pixie or from within New Relic, your steps begin here. Select the account and cluster for the install. If needed, select a namespace. Important Currently, Pixie performs best on clusters with up to 100 nodes (exceeding 100 nodes can lead to excessive memory usage and scripts failing to run). Friendly reminder: autoscaling can quickly drive up your node numbers. Click Continue. Select the data you want to gather, observe, and debug, and click Continue. On the Choose install method page, select either Helm or manifest. Helm method Copy the Helm command that's provided, and then run it on your command line. See this page about installing the Kubernetes integration using Helm to learn more about the process. Helm installs a bundle containing the New Relic infrastructure agent, an integration to gather Prometheus metrics and Kubernetes events, and the Pixie integration. The deployment takes a few minutes to complete. To see the status of the install to the cluster, run kubectl get pods -n newrelic. manifest method Run the provided command in your console, and insert the path to your downloaded manifest. If you're running your Kubernetes cluster in the cloud, see the additional steps in the Kubernetes docs. Click Continue to open the Listening for data page. When you get the message, See your data, click Kubernetes Cluster Explorer to see your cluster. Auto-telemetry with Pixie might restart after installation. This is caused by the auto update feature. Explore your cluster In the cluster explorer, you can get a quick overview of the nodes in your cluster, including CPU, memory, and storage, as well as the status of each pod (healthy, warning, or critical). You can also find out what services are running in each container, their latency, throughput, and error rate. For more information about using the cluster explorer, see Navigate the Kubernetes cluster explorer. Tip Containers might be listed for up to four hours after they get decommissioned. You can query the Pixie data in New Relic One and create dashboards for at-a-glance monitoring. Find the data model and sample queries here. Investigate usage spikes with Flamegraph Debugging is orders of magnitude easier when you can quickly see what your application is doing. Flamegraph, a Pixie always-on visualization, requires no instrumentation, redeploying, or recompiling. It works for compiled languages like Go, C+, Rust, to name a few. And at a glance, Flamegraph tells you what functions your application is spending time on and where you have hot spots. Flamegraph is especially useful for hierarchical resource use, like disk usage and CPU utilization. For more information on how to read Flamegraph, see the Pixie documentation. Debug live On the Live debugging with Pixie tab, run PxL scripts — scripts written in Pixie's PxL language — to view live data captured through eBPF. Select the script drop-down and then select a script to run in the tab. (For best results, select a time range that is recent in the time picker.) Scripts enable you to debug: Traffic in multiple formats: HTTP and HTTPs (including encrypted), DNS, Postgres, MySQL, Cassandra, Redis (currently supporting SQL and HTTP in beta) Kubernetes services and their throughput, error rate, and latency statistics Service maps to learn which services are talking to each other Network traffic maps to learn which nodes are talking to each other JVM data If you don't find the script you need, you can write your own PxL scripts. Find more information about available scripts in Pixie's open source repo.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.42334,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> Auto-telemetry with Pixie for instant Kubernetes observability",
        "sections": "<em>Use</em> Auto-telemetry with Pixie for instant Kubernetes observability",
        "body": " with Pixie <em>Use</em> our guided installation process to install Auto-telemetry with Pixie. This deploys Pixie with <em>New</em> <em>Relic</em>&#x27;s Kubernetes integration on your cluster. You don&#x27;t need to do any further configuration or installation to start <em>using</em> Pixie. If you want to install Auto-telemetry with Pixie on multiple"
      },
      "id": "60f07e20196a670a2d38adae"
    },
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "bd62b563a23cb35cc2aabc7f1f44e3dcacbce3cf",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/introduction-new-relic/",
      "published_at": "2021-07-30T01:46:32Z",
      "updated_at": "2021-07-27T01:37:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup.. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will setup many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for Full-Stack Observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and drill through transaction traces to relevant logs: Bring all your data together Capture, organize, and make sense of your data in our Telemetry Data Platform—no matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data that’s more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic integrations. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure you’re meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. As a full user you get access to our entire set of observability tools in New Relic One: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. Full-stack observability means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.67613,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em>",
        "tags": "<em>Using</em> <em>New</em> <em>Relic</em>",
        "body": " free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will setup many integrations with a single command. Once you have data coming into <em>New</em> <em>Relic</em>, learn more about the <em>New</em> <em>Relic</em> UI or <em>set</em> <em>up</em> Alerts"
      },
      "id": "6043ad0764441f5a06378ecd"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.38511,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Filter <em>using</em> the <em>chart</em> legend",
        "body": "Access any of your <em>New</em> <em>Relic</em> One dashboards to create or manage your <em>charts</em> directly from the <em>chart</em> menu, customize your dashboard&#x27;s layout, adjust display modes, or export your data. Once you have customized your dashboard and built your <em>charts</em>, <em>use</em> our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    }
  ],
  "/terraform/get-started-terraform": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-07-30T01:41:42Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.62323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091b486196a675dc3d52a6f"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-06-25T01:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostConditions directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_policy\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your main.tf and provider.tf to the stage for commit: bash Copy $ git add main.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.69788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "6091fa98e7b9d2063e506919"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.22687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.42902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "6091fa9964441fe25f2f36f4"
    },
    {
      "sections": [
        "Introduction to Applied Intelligence",
        "Why use Applied Intelligence?",
        "Determine root causes with Incident Intelligence",
        "Find unknowns with Proactive Detection"
      ],
      "title": "Introduction to Applied Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "68af5032ebe9c91467f78169bb5d30976d7f67ee",
      "image": "https://docs.newrelic.com/static/c95c61f5a259d33c01781273aed8311d/30c92/diagram-applied-intelligence-workflow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/introduction-applied-intelligence/",
      "published_at": "2021-07-27T08:59:21Z",
      "updated_at": "2021-07-27T08:59:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applied Intelligence (AI) is our AIOps solution for DevOps, site reliability engineers, and on-call teams. At its core, Applied Intelligence helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. By applying machine learning to your data and feedback, Applied Intelligence is designed to improve functionality and deliver smarter context over time. After connecting your data sources to Applied Intelligence, it looks for potential problems and improves based on your feedback. Why use Applied Intelligence? How you respond to an incident can mean thousands of dollars or clicks for your company. Applied Intelligence helps you solve problems faster. Feature Description Troubleshoot and respond to incidents Our solution helps you understand your incidents and gives you ideas for what to do next. Here are a few examples: Automatically classifies incidents based on the golden signals of site reliability engineering. Identifies entities in your stack that may relate to the underlying issue. Suggests responses for incidents based on historical context. Less noise, more focus As tools and systems become more complex, alert noise can overwhelm DevOps and SRE teams. Applied Intelligence correlates related incidents and suppresses noise, so you're only notified when human action is required. Incidents with a hybrid approach Applied Intelligence streamlines your incidents by combining its built-in inputs with your knowledge and feedback. Over time, the system delivers more accurate insights. For example: Our correlation and classification engine adjusts based on your feedback. The system automatically suggests new correlation rules based on your production data. You can create custom logic using the decision builder. Automatic anomaly detection Applied Intelligence provides automatic anomaly detection on all your New Relic APM-monitored applications. We detect anomalies in throughput, latency, and error rate, with no action required from you. Benefits include: No setup required. See anomalies surfaced automatically in the anomalies feed. See them in various New Relic activity streams (for example, on the New Relic One home page). Ability to run NRQL queries of anomalies and create custom dashboards with that data. Determine root causes with Incident Intelligence As part of Applied Intelligence, Incident Intelligence helps you correlate incident events and reduce noise in your environment. With it, you can get an overview of all your issues, see suggested responders, and configure your own correlation logic. To get started, see Incident Intelligence. Find unknowns with Proactive Detection Another feature of Applied Intelligence is Proactive Detection. Proactive Detection is, by default, always on and detecting anomalies. These anomalies are surfaced in the Applied Intelligence anomalies feed, New Relic One activity streams, and can be queried, alerted on, and added to dashboards. Anomalies can be sent to Slack or via webhooks, and/or added as a source for Incident Intelligence correlation and issue notification. Proactive Detection also provides automatic analysis of anomalies and alerts via the analysis page. To get started, see Proactive Detection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.8673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> and Applied Intelligence",
        "body": " incidents and gives you ideas for what to do next. Here are a few examples: Automatically classifies incidents based on the <em>golden</em> <em>signals</em> of site reliability engineering. Identifies entities in your stack that may relate to the underlying issue. Suggests responses for incidents based on historical"
      },
      "id": "603ea67c64441ffd1c4e8860"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.9782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 336.71564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 328.6463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 317.77655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 272.78363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "NR <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a <em>New</em> <em>Relic</em> account and the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (nr1). If you haven&#x27;t already: Sign up for a <em>New</em> <em>Relic</em> account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your nr1"
      },
      "id": "6091f9c864441f70d82f36c4"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.48505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and <em>add</em> it to a dropdown menu in an application <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. <em>Add</em> a time picker to your app"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.61173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> new content to your dashboard",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " can use the search feature at any time to search <em>data</em> across New Relic One. <em>Add</em> new content to your dashboard There are multiple ways to <em>add</em> new content to your dashboard: From the <em>data</em> explorer and <em>query</em> builder features. Use the + <em>Add</em> to your dashboard button (accessible from the main dashboard"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-07-27T21:16:13Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.35506,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> scrubber",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " or an existing dashboard. From the <em>data</em> explorer or the <em>query</em> builder: <em>Add</em> any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see <em>Add</em> pages"
      },
      "id": "603ec16028ccbc8d07eba78d"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-27T21:14:17Z",
      "updated_at": "2021-07-27T21:14:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also duplicate your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.71916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, <em>add</em>, and share dashboards and charts",
        "sections": "Import, export, <em>add</em>, and share dashboards and charts",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also duplicate your dashboard. <em>Add</em> and share charts and content from your dashboards <em>Add</em> new content to a dashboard You can <em>add</em> new content to any dashboard from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-07-27T21:12:16Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.71239,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the <em>data</em> explorer",
        "sections": "<em>Query</em> your <em>data</em>",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " down into <em>data</em> with filters. <em>Add</em> your searches to a dashboard in a click. Understand how NRQL works: <em>data</em> explorer shows how queries are built while navigating the available <em>data</em>. Tip Want to switch to New Relic One from Insights? See our transition guide. <em>Query</em> your <em>data</em> To access the <em>data</em> explorer"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.49994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.51544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. <em>New</em> <em>Relic</em> <em>One</em>: a programmable platform We strive to have an automated user"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of the accounts you have <em>access</em> to. A workload can include: Any <em>New</em> <em>Relic</em>-monitored entity, including services, browser <em>apps</em>, mobile <em>apps</em>, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.50899,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and <em>components</em> in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch <em>New</em> <em>Relic</em> or third-party <em>data</em>"
      },
      "id": "6091fa39196a67a4ead52a4b"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2021-07-30T01:45:27Z",
      "updated_at": "2021-05-21T01:41:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.81271,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document <em>database</em> <em>accessible</em> within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " application on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>. On the How To Use <em>NerdStorage</em> <em>app</em>"
      },
      "id": "6091f9c8196a67648ed52a3c"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.6312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 350.77142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.3457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.0417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-27T12:29:06Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.71362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-07-30T01:58:30Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 412.2472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>, run nr1 help <em>COMMAND</em>_NAME. Usage"
      },
      "id": "6091fa98196a67ded9d52a39"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.9782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 336.71564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 328.6463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 317.77655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 934.8427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Customize your visualization with <em>SDK</em> <em>components</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, <em>query</em>, and mutate data using Nerd<em>Storage</em> 45 min Nerd<em>Storage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 664.97974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>sdk</em>",
        "body": " your specific problem, you can write and deploy your own code to fill in some of those gaps. <em>One</em> area where programmability is valuable is in visualizing your data. While <em>New</em> <em>Relic</em> offers all the telemetry data that your <em>apps</em> and services report and provides many different kinds of charts"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "sections": [
        "Introduction to the C SDK",
        "Monitor app performance",
        "Architecture: C library and daemon",
        "Get started with the C SDK",
        "Check the source code"
      ],
      "title": "Introduction to the C SDK",
      "type": "docs",
      "tags": [
        "Agents",
        "C SDK",
        "Get started"
      ],
      "external_id": "2d78c020e6e048a9e2fca7eb1f27e0041f8a5112",
      "image": "https://docs.newrelic.com/static/5e14d39d4bf4ef8132f32a5beb5b8970/8c557/c-sdk-daemon-architecture0430.png",
      "url": "https://docs.newrelic.com/docs/agents/c-sdk/get-started/introduction-c-sdk/",
      "published_at": "2021-07-27T10:37:00Z",
      "updated_at": "2021-07-27T10:37:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The C SDK is designed to support the often complex, multi-threaded nature of C/C++ applications. You can gain a new level of visibility to help you identify and solve performance issues. You can also collect and analyze data to help you improve the customer experience and make data-driven business decisions. The C SDK can be used to instrument a wide range of applications beyond C or C++. If your application does not use other languages supported by New Relic and can import C libraries, then you can use the New Relic C SDK to take advantage of our monitoring capabilities and features. Monitor app performance one.newrelic.com > APM > (select an app): Here is an example of some of the data you can view in New Relic after you deploy the C SDK for your app. If your app meets the C SDK's compatibility and requirements in Linux environments, you can customize the generic library to communicate with New Relic, then start with APM to monitor your app's performance. What you can do How to do it See the big picture Start with the APM Summary page to monitor the throughput, response times, errors, memory and CPU usage transactions in your applications and services, then explore other details with additional APM dashboards. With deployment markers, see how code changes impact application performance and health. Use infrastructure monitoring to view detailed host and server data. When you install the infrastructure agent and APM on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by app in the Infrastructure UI. Identify and fix errors Use error analytics tools to find bottlenecks by seeing time spent on database calls, external system calls, and key blocks of code. Get alert notifications for problems or errors before they affect users. Create custom dashboards for important metrics. Analyze business data Query user-related data and improve business processes. Send your own custom data to New Relic. Create custom queries of your application data. Create and share visual, interactive displays of your data. And more! Monitor and troubleshoot your application users' desktop experience with your application, including page load timing problems, JavaScript errors, session trace timelines, etc., by using browser monitoring. Use automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints with synthetic monitoring. Analyze and fine-tune your Android and iOS application performance, troubleshoot crashes, compare multiple versions, and examine the performance of HTTP and other network components with mobile monitoring. Architecture: C library and daemon The C SDK relies on two components to send data from your application to New Relic: The lC SDK calls: You download this library, then add the calls and instrumentation to your application's code. This allows you to identify and customize the kinds of data that matters the most to you. The C SDK daemon: This is a separate binary that accumulates data from the C SDK calls, and sends it to New Relic. This acts as a proxy between the SDK and New Relic. C SDK architecture: To send data from your application to New Relic, the daemon must be invoked before making calls to your application's C SDK instrumentation library. Working together, the C SDK instrumentation and the daemon forward data on to New Relic where you can view and query data about transactions. The workflow between your application and New Relic must occur in this order: An HTTPS link is established between the daemon and New Relic. The daemon must be invoked first, before your instrumented application is invoked. Next, socket communication is established between your instrumented application and the daemon. This occurs after successful calls to newrelic_new_app_config() and newrelic_create_app(). The call to newrelic_create_app() is non-blocking. Its second parameter allows you to specify an amount of time for your instrumented application to wait so that the socket communication is adequately established. For example: newrelic_app_t* app = newrelic_create_app(config, 10000); Copy If your instrumented application sends transactions before both the daemon connection and your application's socket communication are established, data reported from your application will be lost. Get started with the C SDK To use our C SDK agent: Make sure your application meets the compatibility and requirements for the C SDK. If you do not already have one, sign up for a free New Relic account. Use our launcher, or follow the installation and instrumentation procedures to install the agent. Within a few minutes, you will be able to view data from your application in your New Relic account's UI. Read the install docs Add C data Check the source code The C SDK is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 590.4381,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the C <em>SDK</em>",
        "sections": "Introduction to the C <em>SDK</em>",
        "tags": "C <em>SDK</em>",
        "body": " <em>app</em> performance <em>one</em>.newrelic.com &gt; APM &gt; (select an <em>app</em>): Here is an example of some of the data you can view in <em>New</em> <em>Relic</em> after you deploy the C <em>SDK</em> for your <em>app</em>. If your <em>app</em> meets the C <em>SDK</em>&#x27;s compatibility and requirements in Linux environments, you can customize the generic library"
      },
      "id": "6043f78fe7b9d2ae4e5799fc"
    },
    {
      "sections": [
        "Introduction to APM",
        "Identify problems before your users do",
        "Monitor all aspects of your business",
        "Ready to get started?"
      ],
      "title": "Introduction to APM",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "317c07d4b32daa51186fd7d2cb857c392b595b5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-apm/",
      "published_at": "2021-07-27T10:13:51Z",
      "updated_at": "2021-07-27T10:13:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application performance monitoring (APM) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. Our APM agents give you real-time observability matched with trending data about your application's performance and the user experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Identify problems before your users do Our APM agents report and store the state of your application so you can quickly identify potential problems before they affect your end users. With APM, your DevOps teams don't need to guess whether a performance blocker comes from the app itself, CPU availability, database loads, or something entirely unexpected. Use our APM solutions to gather both current and historical information about memory usage, CPU utilization, database query performance, web browser rendering performance, app availability, error analysis, external services, and other useful metrics. We have agents for Go, Java, .NET, Node.js, PHP, Python, and Ruby, as well as a C SDK. Monitor all aspects of your business Take advantage of these APM features, and more: Features Description App performance at a glance When you sign in to APM and select an app for your account, use the Summary page to quickly examine relationships across different aspects of your environment; for example: Web transactions response time: Where is the most time being spent? In the request queue, during different stages of page rendering and execution, from external services, or something else? Transaction traces: Which transactions are the slowest, and why? Error rate and throughput: What relationship is there between a spike in errors or slower throughput for a particular time period? Was there a deployment or outage at that time? Hosts: What kind of impact does this have on CPU usage, memory, etc.? Apdex: How are these events affecting customers' satisfaction with the site? Web and non-web transactions Start by comparing the top twenty web transactions or non-web transactions in terms of most time consuming, slowest average response time, highest throughput, or worst Apdex. From there, drill down into deeper trace levels for individual transactions, which in turn break down into smaller segments and components, from HTTPS requests on down to SQL queries. Want to explore even deeper? Set up distributed tracing to see how requests move across a distributed system. Select the transactions that are most important to your business (key transactions). APM and Infrastructure When your APM and Infrastructure accounts are linked, you will have access to APM data charts on these Infrastructure UI pages: Hosts, Network, Storage, and Processes. Distributed tracing Distributed tracing gives you visibility across distributed systems, showing you the path of a request as it travels between services. This feature is especially valuable for large, distributed systems that rely on many small services and microservices. Logs Bring your logs and APM agent data together to see logs associated with various objects in the New Relic UI such as applications, APM errors, APM traces, and Kubernetes containers. Service maps APM's service maps show your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. You can create and customize service maps to visualize and monitor your complex architectures. Query your data You can query and visualize your data: Sample and search APM transaction and error data to gain full understanding of the data being collected. Browse your data visually with the data explorer. Create custom SQL-like queries of your data using the New Relic Query Language (NRQL), or using our PromQL-style queries. Use dashboards to build advanced data visualizations, contextualize data, and understand what's going on in your system, real-time. These are just a few of APM's features. To find out more, see the table of contents for APM. Ready to get started? Start benefiting from APM in 5 simple steps (and just a few minutes!). Sign up for a New Relic account. Install and customize the language agent for your app. Generate some traffic for your app. Wait a few minutes for New Relic to start receiving your data. Log in to your account, and start exploring New Relic! If data does not appear after waiting a few minutes, follow the troubleshooting tips for your APM agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 588.04407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> APM",
        "body": ", distributed systems that rely on many small services and microservices. Logs Bring your logs and APM agent data together to see logs associated with various objects in the <em>New</em> <em>Relic</em> <em>UI</em> such as applications, APM errors, APM traces, and Kubernetes containers. Service maps APM&#x27;s service maps show your <em>app</em>"
      },
      "id": "60440835e7b9d29c2f5799e0"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-07-30T01:49:24Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 555.7696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you’ll learn how to use Nerd<em>Storage</em> <em>SDK</em> <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of data, including users&#x27; configuration settings"
      },
      "id": "6091fa39e7b9d2e1425068b8"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.9782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 336.71564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 328.6463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 317.77655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-27T12:29:06Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.42508,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/build-apps/build-visualization": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-21T15:59:34Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.64716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Tip",
        "Entity relationships",
        "Important",
        "Group and organize entities"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-22T01:24:04Z",
      "updated_at": "2021-04-22T01:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities You'll find your entities wherever you see your data reporting in New Relic. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. These are granted to user roles by default. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.897995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How entities are related to <em>one</em> another How to organize them into groups for easier analysis What is an entity"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-21T15:49:43Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.62895,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-21T15:50:36Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.90482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "To view workloads, go to <em>one</em>.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-04-25T01:55:12Z",
      "updated_at": "2021-04-09T01:54:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads and the rest of our observability platform, join the New Relic family! Sign up to create your account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.90851,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": ": <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you&#x27;ve included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you"
      },
      "id": "6043cb93196a67f988960f76"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.6312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 350.77142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.3457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.0417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-27T12:29:06Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.71362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.6312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 350.77142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.3457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.0417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-27T12:29:06Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.71362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "sections": [
        "Add custom visualizations to your dashboards",
        "Add a visualization to a dashboard",
        "Manage your dashboard visualizations"
      ],
      "title": "Add custom visualizations to your dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d6c9973ef2c2547a99539d1da027b54db23af42c",
      "image": "https://docs.newrelic.com/static/5f7bd9c6a2a163d1f19c5c8b0d844d2f/c1b63/dashboard_viz.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards/",
      "published_at": "2021-07-27T23:50:42Z",
      "updated_at": "2021-05-22T05:24:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can build your own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to custom queries from any data source. This visualization shows the number of people in each city who are viewing New Relic within an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user permissions, which include the Nerdpack manager role, you can add a visualization to a dashboard as described in the following section. The process for creating a visualization is covered in the guide, Build a custom visualization for dashboards. Add a visualization to a dashboard You can add a visualization to a new or existing dashboard. From New Relic, in the top right, click the Apps button, and then on the Apps page, click Custom Visualizations. Hint: if you don't see the Custom Visualizations tile, use the search to locate it. In Custom Visualizations, select the visualization you want to add to a dashboard and then enable it. If there are configuration options, fill those in. The visualization will update with your changes. Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard. If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name. Click Add to dashboard, then click the link to your dashboard to see the custom visualization. Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click Delete. Editing: To edit a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click Edit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.49718,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Manage</em> your dashboard visualizations",
        "body": " an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user <em>permissions</em>, which include the <em>Nerdpack</em> <em>manager</em> role, you can add a visualization to a dashboard as described in the following section. The process for creating"
      },
      "id": "603ec4e628ccbc9409eba7ab"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.55939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Nerdpack</em> <em>permissions</em>",
        "body": " visualization with configuration options 10 min Customize your visualization using configuration Add a table to your <em>app</em> 30 min Add a table to your New Relic One <em>app</em> <em>Nerdpack</em> <em>permissions</em> 10 minutes Learn about <em>permissions</em> for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site Create a custom map view 30 min Build an <em>app</em> to show page view data on a map"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "https://docs.newrelic.com/static/49612c40721bfa27afa90fafcba0e95c/c1b63/login-multiple-accounts-found.png",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model/",
      "sections": [
        "Users, roles, permissions (original user model)",
        "Requirements",
        "Updates about our new account/user model",
        "View and manage users in UI",
        "Tip",
        "Add a new user",
        "Important",
        "Manage user type (basic vs full) and full user upgrades",
        "Determine full user count",
        "Enable SAML SSO and/or SCIM",
        "View pending SAML SSO users",
        "Update account roles",
        "Delete a user",
        "Update the account Owner",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "View roles",
        "Assign a managed role",
        "Create a custom role",
        "Assign a custom role",
        "Edit or delete a custom role",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads permissions"
      ],
      "published_at": "2021-07-27T06:31:39Z",
      "title": "Users, roles, permissions (original user model)",
      "updated_at": "2021-07-15T15:41:08Z",
      "type": "docs",
      "external_id": "95ae42f3474b43dec394245cfc3e23628449a1ed",
      "document_type": "page",
      "popularity": 1,
      "body": "For users on our original user model, an introduction to how the user model works, including user roles and permissions, and how to add and manage users. Requirements This doc and the surrounding section of docs shows you how to manage users on our original account/user model. If you were a New Relic customer before July 30 2020 and haven't migrated your users to the new model, your users are on our original account/user model (and not the New Relic One model). If you're an admin and want to see if you have users on the original model: If you can see users in the Users and roles UI, those users are on our original user model. Updates about our new account/user model In July of 2020, we released a new account/user model called the New Relic One user model, which offers many benefits in terms of how you manage your organization and users. At first this was only available to new sign-ups but over time we've been migrating more older customers to the new model. Some older customers are able to migrate their users on their own. We'll continue working on migrating users to the new model until the original model is fully deprecated. One impact of the new user model is that it's possible now for users to have multiple logins associated with the same email. For example, a user with access to multiple organizations (like a contractor) may have their user record updated to the new user model in one organization, resulting in them having their original login method and records and a New Relic One user model record. This may result in the user being logged in to New Relic and not being able to find an account they're looking for. For more on that, see Factors affecting access. If a user's email is associated with more than one login, they'll see a \"multiple accounts found\" note when logging in. View and manage users in UI If your New Relic account has users on our original user model, you can use the Users and roles UI. To access this: Click the account dropdown, click Account settings, and then click Users and roles. Some features in the UI are visible only to account Owners and Admins. Tip You can also use the New Relic REST API to obtain a list of everyone and their roles in your New Relic account. Here are some instructions and tips for adding and managing users via the UI: Add a new user Tip Owner or Admins To add a new user to your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. In the upper right corner, click New user. Enter the appropriate name and email address. Select their base role as either Admin, User, or Restricted. Select Add user. The new user will receive an email notification automatically from New Relic. Important New Relic recommends a maximum of 1,000 accounts per user. Additional accounts may result in limited access to some New Relic features. Manage user type (basic vs full) and full user upgrades Note that billing-related aspects of your count of full users only apply if you're on New Relic One pricing. If you're on our original pricing plan, billing impacts do not apply. To update a user's type (basic user versus full user): Go to: account dropdown > Account settings > Users and roles > Users. Either select a user and edit their type or bulk update the type for multiple useres. To control how basic users upgrade to become full users, from the Users and roles UI you can select Access requests. You have two options: Automatic approval: With this option, basic users can automatically upgrade to be full users. This option allows your users to more easily troubleshoot problems. Require review: With this option, your admins get a notification when basic users request an upgrade and must upgrade them first. You can approve them either from the notification email or from the user's entry in the Users and roles UI. For more about user type, see User type. Determine full user count If you're on New Relic One pricing plan, your count of full users is a factor in your billing. To see your count of full users, click the account dropdown and then click View your usage. If you have a parent/child account structure (including a customer partnership), your count of full users may not match what you see when you go to Account settings > Users and roles. To examine users on a parent account's children accounts, go to a parent account's Account settings UI page, click on a child account, and go to that account's Users and roles UI page. Enable SAML SSO and/or SCIM For an introduction to using SAML SSO and/or SCIM provisioning, see Get started with SAML SSO or SCIM. View pending SAML SSO users New Relic accounts with SAML Single Sign On (SSO) may have a list of Pending users. These are individuals who have been added to the SAML-enabled account but have not yet confirmed. Update account roles Tip Owner or Admins To update a person's role and capabilities: Go to: account dropdown > Account settings > Users and roles > Users. Select the person's name. Under Roles and capabilities, select their base role as Admin, User, or Restricted. The account Owner must update the Owner role. Delete a user Tip Owner or Admins To remove a user from your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. Click on the name of the person you would like to update. Click Delete User. Tip You can also add, update, or delete users in bulk via CSV file. Update the account Owner A New Relic account can have only one Owner role at any time. You must be the current account Owner to change your role to someone who currently has an Admin role for the account. If the current Owner is unavailable, contact your account representative at New Relic, or get support at support.newrelic.com. You cannot delete or remove your assigned Owner role. However, if the account has one or more Admin role, you can change an Owner to an Admin. Go to: account dropdown > Account settings > Account > Users and roles. Above the Active users list, select Change owner. If an account has no Admins, this button won't be available. Select someone who currently has an Admin role for the account. Refresh the page for changes to take effect. Your previous Owner role automatically changes to an Admin role. To find out who is the current assigned Owner: Go to: account dropdown > Account settings > Account > Users and roles. View the Base role column to locate your account Owner. The Change owner button is only visible to the current account Owner. If the current Owner is unable to change the role (for example, that person no longer is with your organization), contact your account representative at New Relic, or get support at support.newrelic.com. User types: basic user and full user Important This section is for users on our original user model. If you're on our New Relic One user model, see our New Relic One user docs. Starting March 2021, we ended the preview period for basic users on our original user model. The preview period gave these basic users the same permissions as full users. For more on this, see our Explorers Hub post on user type changes. The user type (basic user or full user) determines what features a user has access to. Below are details on the two user types. Note that billing-related aspects only apply if you're on New Relic One pricing. If you're on our original pricing plan, billing impacts do not apply. Basic user. Details: These users have access to basic features like setting up reporting of data, running queries of data, making custom charts and dashboards, and setting up alerts. They do not have access to Full-Stack Observability features (for more details on feature access, see Capabilities). Depending on access request settings, basic users can either upgrade themselves to be full users or request upgrade access from admins. No matter what custom group a basic user is assigned to, they always have the capabilities of a basic user: no more and no less. Full user. Details: Full users have access to our Full-Stack Observability features, which include our curated UI experiences like APM, infrastructure monitoring, browser monitoring, mobile monitoring, and synthetic monitors. For details on what's available, see Capabilities. For organizations on New Relic One pricing: these users are billable. The Standard edition includes one free full user and up to five total. If a user in your organization is set as a basic user in one account and a full user in another, the user has full user access for all accounts. For how to edit a user's type, see Manage users. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. Admin Can add, edit, and delete users, and can enable or set up features. User Can use (and optionally set up) New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted User One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a parent account automatically have the same level of access for all the child accounts of the parent account. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Tip Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. Tip You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Tip Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Tip Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select Edit role or Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a parent account automatically have the same level of access for all the child accounts of that parent account. However, they won't receive email notifications for alerts or weekly reports for child accounts unless they are explicitly granted permission on those accounts. Function Owner Admin User Restricted Maintain billing information. Change the account Owner. Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. Update users' job titles and roles from Account settings in the New Relic UI. Create, modify and delete child accounts from Account settings in the New Relic UI. Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. Manage flexible data retention. Subscribe and unsubscribe applications to New Relic One Add, update, and delete Proactive Detection configurations. Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. Tip New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions To give permission to delete a mobile app from New Relic, you can assign an Admin or Mobile manager role. Synthetics permissions Here's a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads permissions Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.18231,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Users, roles, <em>permissions</em> (original user model)",
        "sections": "Users, roles, <em>permissions</em> (original user model)",
        "body": " dashboards with others. Mobile <em>permissions</em> To give permission to delete a mobile <em>app</em> from New Relic, you can assign an Admin or Mobile <em>manager</em> role. Synthetics <em>permissions</em> Here&#x27;s a summary of Admin and Add-on <em>manager</em> capabilities with New Relic Synthetics. To allow a User or Restricted User"
      },
      "id": "603e88b2e7b9d2a3f12a07d5"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 65.42381,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Impact of accounts on the workload <em>permissions</em> and content",
        "body": " and <em>managing</em> workloads: All users for an account can view that account&#x27;s workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload <em>permissions</em> and content Workloads can group and display entities from multiple accounts"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-07-27T21:16:13Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.83705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Dashboard <em>permissions</em>",
        "body": " and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data <em>apps</em> associated with your New Relic account. This includes the dashboards you&#x27;ve created within the New Relic One platform as well as the dashboards built in Insights. From the top bar"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-07-27T22:25:48Z",
      "updated_at": "2021-07-21T13:27:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in New Relic One. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, browser, and mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the data explorer. Learn more about querying data in New Relic. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of browser data Here's a NRQL query of PageView data from browser monitoring. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for browser monitoring PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.19417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "tags": "Query your <em>data</em>",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>"
      },
      "id": "60445a0e196a67cb09960f6e"
    },
    {
      "sections": [
        "Use integration data in New Relic dashboards",
        "Get started with integration data",
        "Example NRQL queries",
        "AWS EBS query example",
        "Azure Service Bus query example",
        "Azure Functions query example",
        "Azure VMs query example",
        "NGINX query example",
        "MySQL query example",
        "Inventory change query example",
        "Tip",
        "Tips for using different data types",
        "Metric data tips",
        "Event data tips",
        "Inventory data tips"
      ],
      "title": "Use integration data in New Relic dashboards",
      "type": "docs",
      "tags": [
        "Integrations",
        "Infrastructure integrations",
        "Get started"
      ],
      "external_id": "b236b0fae29853de085d0430fdec27fba74c15d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/infrastructure-integrations/get-started/use-integration-data-new-relic-dashboards/",
      "published_at": "2021-07-27T16:16:47Z",
      "updated_at": "2021-07-21T20:24:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Most data generated by integrations is available in New Relic One dashboards, where you can query your data using NRQL and build custom dashboards. The following tips and sample queries were created for New Relic-built integrations, but most will also apply to integrations built with the Integrations SDK. For a general look at how to find and use integration data, see New Relic data types. Get started with integration data Here are some tips for finding and exploring your integration data in New Relic: From the one.newrelic.com > Infrastructure > Third-party services page, select an integration dashboard. There, you can view the NRQL queries that generated a chart. For examples of NRQL queries for integration data, see the example queries. Use the data explorer or the dashboards to explore and understand the available data. Read the documentation for a specific integration to learn about the reported data. When you create a useful query you'd like to add to your dashboard, select Add to dashboard. Example NRQL queries Here are some examples of NRQL queries that use integration data: AWS EBS query example Here's a NRQL query for the AWS EBS service, showing the total write time metric, faceted by entityName: SELECT sum('provider.volumeTotalWriteTime.Sum') FROM BlockDeviceSample WHERE provider = 'EbsVolume' FACET entityName Copy Azure Service Bus query example Here's a NRQL query for the maximum number of messages in an Azure Service Bus topic queue, faceted by resource group: SELECT max(activeMessages.Maximum) FROM AzureServiceBusTopicSample FACET resourceGroupName Copy Azure Functions query example Here's a NRQL query for Azure Functions, showing the count of executed functions over the past six hours by region over time: SELECT sum(functionExecutionCount.Total) FROM AzureFunctionsAppSample FACET regionName TIMESERIES SINCE 6 hours ago Copy Azure VMs query example Here's a NRQL query for Azure VMs that compares the count of VM events over the past thirty minutes with the same time a week ago: SELECT uniqueCount(vMName) FROM AzureVirtualMachineScaleSetSample FACET name SINCE 30 minutes ago COMPARE WITH 1 week ago Copy NGINX query example Here's an example of a query that you might run on your NGINX integration data and place in a dashboard. This query creates a chart showing the average value of NGINX requests per second over time: SELECT average(net.requestsPerSecond) FROM NginxSample TIMESERIES Copy For more on how to create queries, see NRQL syntax. MySQL query example Here's an example of a query that you might run on your MySQL integration data. This query generates a chart showing the maximum number of used MySQL connections: SELECT max(net.maxUsedConnections) FROM MysqlSample Copy For more on how to create queries, see NRQL syntax. Inventory change query example Here's an example of a query that groups inventory change events from the last day by the type of change: SELECT count(*) FROM InfrastructureEvent WHERE format='inventoryChange' FACET changeType SINCE 1 DAY AGO Copy Tip You can also perform these queries using dimensional metrics. Tips for using different data types Integrations can generate metric, event, and inventory data, all of which are available for querying. Here are some tips for using the different types of integration data: Metric data tips Tips for finding and using integration metric data: All integration data is attached to a data type known as an event (not to be confused with events reported by integrations, which represent important activity in your host/service). This means that all integration data can be found via the data explorer. For more about these two basic New Relic data types, see New Relic data collection. Metric values are treated as attributes: key-value pairs attached to an event. For example, the MySQL integration has an 'active connections' metric; this would be found by querying the connectionsActive attribute of the MysqlSample event. For general information about metrics, see Integration metric data. Event data tips Here are some tips for finding and using integration event data when querying: Most integration events are inventory change events. When inventory is changed, it generates an InfrastructureEvent with a format value of inventoryChange. Integration data can be found via the data explorer. For general information about events, see Event data. Inventory data tips Here are some tips for finding and using integration inventory data: For general information about inventory data, see Integration inventory data. Some inventory data is added as attributes (key-value pairs) to this data. For example, the AWS EC2 integration collects awsRegion as inventory data; this would be found by querying the awsRegion attribute of the ComputeSample event type and provider Ec2Instance. When inventory data changes, an InfrastructureEvent event type is generated with a format value of inventoryChange. See the query examples for an example of querying this data. For more on using NRQL queries, see Intro to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.42389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use integration <em>data</em> in New Relic dashboards",
        "sections": "Use integration <em>data</em> in New Relic dashboards",
        "body": "(net.requestsPerSecond) FROM NginxSample TIMESERIES Copy For more on how to create queries, see <em>NRQL</em> <em>syntax</em>. MySQL query example Here&#x27;s an example of a query that you might run on your MySQL integration <em>data</em>. This query generates a chart showing the maximum number of used MySQL connections: SELECT max"
      },
      "id": "60450a39196a67d7dc960f7c"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-27T21:14:17Z",
      "updated_at": "2021-07-27T21:14:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also duplicate your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.30671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Query your <em>data</em>",
        "body": "?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. <em>NRQL</em> <em>Syntax</em> Error: Error at line 1 position 15, unexpected &#x27;FROM&#x27; FACET and TIMESERIES are not supported on events. Your query has <em>syntax</em> issues. Review it in the query builder to find the error. Query"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "46f2be93b0c4daf40da9b93cfe0fbf5f235eecb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-07-29T01:47:07Z",
      "updated_at": "2021-07-16T03:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.36449,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "tags": "Event <em>data</em> sources",
        "body": " <em>syntax</em>, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute <em>data</em> types Attribute values can be either a string"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Access and requirements",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "e90cb97b3973aef0ea5ffe6b428c3b568e77ddf0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-metric-api/",
      "published_at": "2021-07-27T06:15:46Z",
      "updated_at": "2021-07-27T06:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Access and requirements You'll need a New Relic Insert API key. For information on limits and restricted attributes, see Metric API requirements and limits. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting If you receive an NrIntegrationError, see Troubleshoot a NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.5596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find and use your <em>data</em>",
        "tags": "Telemetry <em>Data</em> Platform",
        "body": " <em>data</em>. Alert on metric <em>data</em> To alert on metrics created with the Metric API, use <em>NRQL</em> alert conditions: Select the <em>NRQL</em> category when defining your condition, then use the FROM Metric ... <em>NRQL</em> query <em>syntax</em> to express it. When you create these alert conditions, Alerts automatically uses the finest"
      },
      "id": "603eac62e7b9d20c222a07c5"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.68267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "6091fa98e7b9d215455068c4"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-07-30T01:50:30Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.691414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "6091fa9928ccbc8f44a2689c"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-07-27T21:12:16Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.29576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": ", go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.475197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-07-27T21:16:13Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.33857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. <em>Explore</em> your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-07-30T01:49:24Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.30515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": ": AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information"
      },
      "id": "6091fa39e7b9d2e1425068b8"
    },
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "@Trace",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "@TraceLambda",
        "Properties for @TraceLambda",
        "pattern",
        "includeNonstatic",
        "@TraceByReturnType",
        "Properties for @TraceByReturnType",
        "traceReturnTypes",
        "Performance considerations",
        "Caution",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-07-27T04:22:59Z",
      "updated_at": "2021-07-15T18:31:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. Make sure that newrelic-api.jar appears in your classpath as it contains all these annotations. @Trace Annotating a method with @Trace tells the Java agent that measurements should be taken for that method. To add a method call as a custom trace add @Trace annotations to your method. import com.newrelic.api.agent.Trace; ... @Trace public void run() { // background task } Copy Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy @TraceLambda If your transaction traces show large blocks of uninstrumented time and you want to include lambda expressions within the trace, you can use the @TraceLambda annotation without parameters: import com.newrelic.api.agent.TraceLambda; @TraceLambda class ClassContainingLambdaExpressions() { // work } Copy Lambda expressions become static methods of the containing class after compilation. By default, static methods within classes marked with the @TraceLambda annotation matching the annotations pattern will be marked with the @Trace annotation. Properties for @TraceLambda The @TraceLambda annotation supports the following properties. pattern Type: String Default: ^\\$?(lambda\\|anonfun)\\$(?\\<name\\>.*) If you set the pattern, as in @TraceLambda(pattern=\"YourPattern\"), then the marked classes method names will be matched against the regex pattern YourPattern. If matched the related method will be marked with the @Trace annotation. Here is an example: @TraceLambda(pattern=\"YourPattern\") Copy includeNonstatic Type: Boolean Default: false If true, the marked classes nonstatic methods will be eligible for assessment against the pattern for instrumentation. Here is an example: @TraceLambda(includeNonstatic=\"true\") Copy @TraceByReturnType To include methods with a particular return type within the trace, you can use the @TraceByReturnType annotation to mark a class passing the return types as a property. Methods in annotated classes that match one of the specified return types will be marked with the @Trace annotation. @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { // ... } Copy Properties for @TraceByReturnType The @TraceByReturnType annotation supports the following properties. traceReturnTypes Type: List < Class> Default: empty list If you set the traceReturnTypes, as in @TraceByReturnType(traceReturnTypes={String.class}), then the marked classes method return types will be matched against the String.class. All matched methods will be marked with the @Trace annotation. Here is an example: @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { public String doSomething() { // matches // ... } public Long somethingElse() { // does not match // ... } } Copy Performance considerations When the Java agent is present in the JVM, it will inject code on the annotated methods. The performance hit is negligible in heavyweight operations, such as database or webservice calls, but is noticeable in methods that are called frequently, such as an accessor called thousands of times a second. Caution Do not instrument all of your methods, as this can lead to decreased performance and to a metric grouping issue. More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.99642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.<em>METHOD</em>) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public <em>static</em> final String NULL = &quot;&quot;; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360/",
      "sections": [
        "Java agent v3.36.0",
        "Improvements",
        "Fixes"
      ],
      "published_at": "2021-07-28T01:23:49Z",
      "title": "Java agent v3.36.0",
      "updated_at": "2021-03-11T03:30:39Z",
      "type": "docs",
      "external_id": "620b9aa4068c44bd29515f153020db735791cd39",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.599808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page"
      },
      "id": "60445ebc196a676dd6960f5e"
    },
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-07-27T03:54:51Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 37.54191,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Child nodes for <em>method</em>",
        "body": ". The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non <em>static</em> <em>methods</em> (defaults to false); pattern - a string with the pattern to search for the lambda <em>methods</em>. Child nodes for <em>method</em> The <em>method</em> node can have several children. For more information"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-07-27T04:21:46Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 25.957642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-07-27T10:09:56Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.23457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using Alerts via <em>NerdGraph</em> API",
        "sections": "<em>Mutations</em>",
        "tags": "Alerts and <em>Nerdgraph</em>",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "Dashboards API",
        "Starting out with NerdGraph",
        "Operations",
        "Dashboard CRUD operations",
        "Dashboard page operations",
        "Other operations",
        "Limits",
        "Dashboard limits",
        "Dashboard page limits",
        "Widget limits",
        "Errors as first class citizens",
        "Errors as part of every mutation response"
      ],
      "title": "Dashboards API",
      "type": "docs",
      "tags": [
        "Dashboards",
        "Dashboards API"
      ],
      "external_id": "96f807b5a19101ec83176ceeb95b822eb8165896",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-api/",
      "published_at": "2021-07-27T21:12:14Z",
      "updated_at": "2021-07-09T23:44:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Dashboards API allows you to create and manage dashboards. Starting out with NerdGraph If you're new to NerdGraph and GraphQL, you may want to first read our Introduction to NerdGraph. If you’re already familiar with the dashboards API, you can read Create dashboards with NerdGraph. When using NerdGraph, it helps to understand that our dashboards are entities that report data from other entities, such as monitored apps, hosts and services. Find the NerdGraph API explorer at api.newrelic.com/graphiql. Operations We have defined a granular GraphQL API that lets you execute different dashboard operations depending on their goal and scope. Dashboard CRUD operations Operation GraphQL operation type Notes actor > entity() query Get dashboard operation. You can get all dashboard and widget data for a given dashboard entity GUID. dashboardCreate() mutation Create dashboard operation. You can create a dashboard attached to a specific account by specifying all its elements, from metadata to widget configuration. dashboardUpdate() mutation Update dashboard operation. You can update an existing dashboard given a dashboard entity GUID. You need to specify the complete, updated dashboard elements, from metadata to widget configuration. dashboardDelete() mutation Delete dashboard operation. You can delete an existing dashboard given a dashboard entity GUID. This operation executes a logical delete that lets you recover your dashboard. dashboardUndelete() mutation Undelete dashboard operation. You can recover a previously deleted dashboard given a dashboard entity GUID. Dashboard page operations Operation GraphQL operation type Notes dashboardUpdatePage() mutation Update dashboard page operation. You can update one page of an existing dashboard given a dashboard page entity GUID. You need to specify the complete, updated dashboard page elements, from metadata to widget configuration. dashboardUpdateWidgetsInPage() mutation Update widgets operation. You can update a set of existing widgets of a dashboard page given a dashboard page entity GUID. You need to specify the set of widgets to be updated and their complete configuration. dashboardAddWidgetsToPage() mutation Add widgets operation. You can add a set of new widgets to a dashboard page given a dashboard page entity GUID. You need to specify the set of new widgets and their complete configuration. Other operations Operation GraphQL operation type Notes dashboardCreateSnapshotUrl() mutation Create dashboard page snapshot operation. You can create a public URL for a given dashboard page entity GUID. The dashboard page can then be accessed in the form of a static snapshot in the resulting public URL. actor > dashboard > liveUrls() query List all live URLs operation. You can get the complete list of live URLs you have access to. A live URL is a mechanism that allows you to share dashboard pages and widgets publicly with up-to-date or live data. dashboardWidgetRevokeLiveUrl() mutation Revoke widget live URL operation. You can revoke a previously created live URL of a widget. As a result, the live URL will become unavailable to the public. Limits We have limited the values you can set to some of the dashboard properties. This allows us to keep dashboards in good shape while boosting their usability. Dashboard limits Limit Value Maximum number of pages in a dashboard 20 Maximum length of a dashboard name 255 Maximum length of a dashboard description 1024 Dashboard page limits Limit Value Maximum number of widgets in a dashboard page 40 Maximum length of a dashboard page name 255 Maximum length of a dashboard page description 1024 Widget limits Limit Value Maximum length of a widget title 255 Maximum number of entities linked to a widget 1 Maximum number of queries in a widget 20 Maximum layout column of a widget 12 Minimum layout column of a widget 1 Minimum layout row of a widget 1 Maximum layout width of a widget 12 Minimum layout width of a widget 1 Maximum layout height of a widget 8 Minimum layout height of a widget 1 Errors as first class citizens All dashboard mutations offer a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect expected potential issues. Every error has a type and a description to help you identify what’s the source of the problem. Errors as part of every mutation response mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy Keep in mind that these are expected errors that we are aware of in advance. You should also check for unexpected errors that will be returned in the standard GraphQL errors field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.91621,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Starting out with <em>NerdGraph</em>",
        "body": "The Dashboards API allows you to create and manage dashboards. Starting out with <em>NerdGraph</em> If you&#x27;re new to <em>NerdGraph</em> and GraphQL, you may want to first read our Introduction to <em>NerdGraph</em>. If you’re already familiar with the dashboards API, you can read Create dashboards with <em>NerdGraph</em>. When using"
      },
      "id": "60dd3c8328ccbc8f1a71b46c"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-27T09:44:35Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.88517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "tags": "<em>NerdGraph</em>",
        "body": "This document provides examples of how to use New Relic <em>NerdGraph</em> to <em>query</em> and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the <em>NerdGraph</em> GraphiQL explorer, you can also <em>query</em> NRQL data. These examples for querying"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: Manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "NerdGraph tutorial: Manage license keys and user keys",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-07-27T11:27:55Z",
      "updated_at": "2021-04-22T11:55:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.20501,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Manage license keys and user keys",
        "sections": "<em>NerdGraph</em> tutorial: Manage license keys and user keys",
        "tags": "<em>NerdGraph</em>",
        "body": " to let you rotate keys for security purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. Notes about this functionality: All <em>mutations</em> can accept multiple keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-30T01:43:08Z",
      "title": "Collect data",
      "updated_at": "2021-07-30T01:43:08Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source 15 min APIs, agents, OS emitters - get any data Add custom attributes   Use custom attributes for deeper analysis Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.374565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build <em>queries</em> with <em>NerdGraph</em>",
        "body": " data - any source 15 min APIs, agents, OS emitters - get any data Add custom attributes   Use custom attributes for deeper analysis Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with <em>NerdGraph</em> 25 min Try <em>NerdGraph</em> and build the queries you need <em>Query</em> data with NRQL 10 min <em>Query</em> default data, custom events, and attributes"
      },
      "id": "6091fa38196a67a932d52a29"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Automate workflows",
      "updated_at": "2021-07-29T01:39:17Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.30122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the <em>Kubernetes</em> <em>operator</em> 20"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Install Kubernetes events integration",
        "Requirements",
        "Install the Kubernetes events integration",
        "View your Kubernetes events",
        "Query events",
        "Get attributes names",
        "See event details",
        "Search events in New Relic",
        "View events in the Kubernetes cluster explorer",
        "Optional: Collect metrics of the event collector",
        "Optional: Define custom attributes",
        "Troubleshooting",
        "Get logs on event collection",
        "Get logs on sending events"
      ],
      "title": "Install Kubernetes events integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Kubernetes events"
      ],
      "external_id": "a19259cc9ac093cc7acf401c1201e48d5daa9682",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/kubernetes-events/install-kubernetes-events-integration/",
      "published_at": "2021-07-27T13:46:47Z",
      "updated_at": "2021-07-27T13:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Kubernetes events integration watches for events happening in your Kubernetes clusters and sends those events to New Relic. To visualize your event data, use the Kubernetes cluster explorer in New Relic One platform, or use the infrastructure events UI. Requirements The Kubernetes events integration requires you to: Install and activate the New Relic Kubernetes integration. Configure a Kubernetes pod with the label app.kubernetes.io/name=nri-kube-events and two containers, one used to capture events in the Kubernetes cluster and the other to forward the events to New Relic. Install the Kubernetes events integration To install the New Relic Kubernetes events integration in a Kubernetes environment: Download the integration manifest YAML file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/nri-kube-events-latest.yaml Copy Edit the nri-kube-events-latest.yaml manifest file, adding both a cluster name, to identify your Kubernetes cluster (required), and your New Relic license key (required). clusterName: \"YOUR_CLUSTER_NAME\" [...] - name: \"NRIA_LICENSE_KEY\" value: \"YOUR_LICENSE_KEY\" Copy Deploy the integration in your Kubernetes cluster: kubectl apply -f nri-kube-events-latest.yaml Copy To confirm that the integration has been configured correctly, wait a few minutes, then go to one.newrelic.com > Query builder, and run the following NRQL query to see if data has been reported: FROM InfrastructureEvent SELECT count(*) WHERE clusterName = 'YOUR_CLUSTER_NAME' since 1 hour ago Copy View your Kubernetes events Once you have successfully installed the Kubernetes event integration, you can view and query your events in New Relic. To add events to your New Relic One dashboard: Add a chart to a new or existing dashboard or create a chart using the New Relic query builder. When creating or updating your chart, select the chart type table and use the following event query, replacing YOUR_CLUSTER_NAME with the name of your cluster: FROM InfrastructureEvent SELECT event.involvedObject.kind,event.involvedObject.name,event.reason,event.message WHERE clusterName = 'YOUR_CLUSTER_NAME' limit 100 Copy Query events Here are a few examples to query your data: Get attributes names To see all the attributes names, use the following query: FROM InfrastructureEvent SELECT keyset() WHERE category = 'kubernetes' Copy See event details To see details about the latest events in a cluster, use the following query, replacing YOUR_CLUSTER_NAME with the name of your cluster: FROM InfrastructureEvent SELECT event.involvedObject.kind, event.involvedObject.name, event.type, event.message, event.reason WHERE category = 'kubernetes' AND clusterName='YOUR_CLUSTER_NAME'​ Copy The events collected by New Relic will have the exact same attributes as given by Kubernetes. For a reference of these attributes, see the Kubernetes event v1 core documentation. Search events in New Relic To search events in the New Relic Infrastructure UI: Navigate to the Infrastructure event page: Go to one.newrelic.com > Infrastructure > Events. In Category, select kubernetes. Use the Search events field to look for specific events. To focus on a specific set of events, select or change the filter set. View events in the Kubernetes cluster explorer To view events in the Kubernetes cluster explorer, use either of these methods: In New Relic One: Go to one.newrelic.com > Kubernetes cluster explorer. Then, to view the pod details: In the Kubernetes cluster explorer, select a pod. Select Show pod events. Optional: Collect metrics of the event collector To collect metric data for the event collector itself, install the New Relic Prometheus OpenMetrics integration. To get started: Install the New Relic Prometheus OpenMetrics integration. Label the deployment of your Kubernetes events integration with your configured scrape label (default is prometheus.io/scrape=true). Optional: Define custom attributes To add custom attributes to the events sent by the integration these need to be specified as environment variables following the nomenclature NRI_KUBE_EVENTS_attributeKey=attributeValue. These environment variables should be defined as part of the spec for the kube-events container. For example, to add the attribute environment with value staging to all the events, add the following to your manifest: env: - name: NRI_KUBE_EVENTS_environment value: dev Copy Be sure to specify the environment in the spec for the kube-events container, making your manifest look something like this: ... kind: Deployment ... spec: ... template: ... spec: containers: - name: kube-events ... env: - name: NRI_KUBE_EVENTS_environment value: dev Copy Troubleshooting Here are some troubleshooting tips when using the Kubernetes events integration. Get logs on event collection To check the logs of our event collector: kubectl logs deploy/nr-kube-events kube-events Copy To add more details, enable verbose mode by adding verbose: \"true\" in the config section of you configuration file, either before or after the clusterName. Get logs on sending events To check the logs of the agent responsible for sending the events to New Relic: kubectl logs deploy/nr-kube-events infra-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.359695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Kubernetes</em> events integration",
        "sections": "Install <em>Kubernetes</em> events integration",
        "tags": "<em>Kubernetes</em> integration",
        "body": "The New Relic <em>Kubernetes</em> events integration watches for events happening in your <em>Kubernetes</em> clusters and sends those events to New Relic. To visualize your event data, use the <em>Kubernetes</em> cluster explorer in New Relic One platform, or use the infrastructure events UI. Requirements The <em>Kubernetes</em>"
      },
      "id": "603eae45196a67b26ba83d8f"
    },
    {
      "sections": [
        "Use Auto-telemetry with Pixie for instant Kubernetes observability",
        "Why it matters",
        "Important",
        "Install Auto-telemetry with Pixie",
        "Before you begin",
        "Install from the beginning of the guided install process",
        "Install from the Configure the HELM command/manifest (yaml) file",
        "Helm method",
        "manifest method",
        "Explore your cluster",
        "Tip",
        "Investigate usage spikes with Flamegraph",
        "Debug live"
      ],
      "title": "Use Auto-telemetry with Pixie for instant Kubernetes observability",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "fcb7ee18f84381b6ac06911deb127f94d298b03b",
      "image": "https://docs.newrelic.com/static/1e793128e5d6019bbebd8123dbf943ab/c1b63/service-graph.png",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/get-started-auto-telemetry-pixie/",
      "published_at": "2021-07-30T01:55:43Z",
      "updated_at": "2021-07-28T01:58:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When we say auto-telemetry, we’re not talking about cars — we're talking about instant baseline visibility into your Kubernetes clusters. With the New Relic One integration with Pixie, you get similar data to traditional language agents, but without manually instrumenting your code or redeploying your application. Pixie auto-telemetry is powered by eBPF, a virtual machine-like construct that enables Pixie to seamlessly collect fine-grained telemetry data — service-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your Kubernetes clusters and workloads. No language agents required. Live debugging with Pixie shows a service graph listing the namespaces and the node that are available on the current cluster. Simply put, Auto-telemetry with Pixie offers the quickest option for getting observability into your Kubernetes services. Why it matters Our Pixie integration gives you the best of both worlds: Pixie’s fast and simple Kubernetes observability coupled with New Relic One’s incident correlation, intelligent alerting, and long-term retention. You’ll get visibility into HTTP services using golden signals, HTTP transactions, database transactions, distributed tracing, and JVM metrics. You can operate, debug, and scale your Kubernetes clusters based on the information you learn about how your clusters and services are running. Using the New Relic Explorer, you can see key metrics and events at every level, starting with the cluster, and diving down into namespaces, deployments, and pods. You can quickly spot anomalous behavior, and where it’s happening. And then dive deeper using embedded visualizations of your Pixie data. Quickly identify hot spots with Flamegraph. On the Live debugging with Pixie tab, answer questions like what SQL requests your app is making or which services are talking to each other. Important Auto-Telemetry with Pixie leverages Community Cloud with Pixie, a separate platform from New Relic One. Use of Community Cloud with Pixie is subject to separate terms of service. Install Auto-telemetry with Pixie Use our guided installation process to install Auto-telemetry with Pixie. This deploys Pixie with New Relic's Kubernetes integration on your cluster. You don't need to do any further configuration or installation to start using Pixie. If you want to install Auto-telemetry with Pixie on multiple clusters, re-run the guided install for each additional cluster. Before you begin Review this Pixie data security overview for actions to take to secure your data. Make sure you have sufficient memory: Pixie requires 2Gb of memory per node in your cluster. Important If you are already a Pixie user, you must still install using the guided installation steps described below. This will provide the API keys that you need. Install from the beginning of the guided install process Open our New Relic One guided install. Select the account you want to use for the guided install, and click Continue. Note: if you have a single account, you won't see this option. Select Kubernetes and then continue with step one in the next section. Install from the Configure the HELM command/manifest (yaml) file If you arrived in the guided installation process by following a link from Pixie or from within New Relic, your steps begin here. Select the account and cluster for the install. If needed, select a namespace. Important Currently, Pixie performs best on clusters with up to 100 nodes (exceeding 100 nodes can lead to excessive memory usage and scripts failing to run). Friendly reminder: autoscaling can quickly drive up your node numbers. Click Continue. Select the data you want to gather, observe, and debug, and click Continue. On the Choose install method page, select either Helm or manifest. Helm method Copy the Helm command that's provided, and then run it on your command line. See this page about installing the Kubernetes integration using Helm to learn more about the process. Helm installs a bundle containing the New Relic infrastructure agent, an integration to gather Prometheus metrics and Kubernetes events, and the Pixie integration. The deployment takes a few minutes to complete. To see the status of the install to the cluster, run kubectl get pods -n newrelic. manifest method Run the provided command in your console, and insert the path to your downloaded manifest. If you're running your Kubernetes cluster in the cloud, see the additional steps in the Kubernetes docs. Click Continue to open the Listening for data page. When you get the message, See your data, click Kubernetes Cluster Explorer to see your cluster. Auto-telemetry with Pixie might restart after installation. This is caused by the auto update feature. Explore your cluster In the cluster explorer, you can get a quick overview of the nodes in your cluster, including CPU, memory, and storage, as well as the status of each pod (healthy, warning, or critical). You can also find out what services are running in each container, their latency, throughput, and error rate. For more information about using the cluster explorer, see Navigate the Kubernetes cluster explorer. Tip Containers might be listed for up to four hours after they get decommissioned. You can query the Pixie data in New Relic One and create dashboards for at-a-glance monitoring. Find the data model and sample queries here. Investigate usage spikes with Flamegraph Debugging is orders of magnitude easier when you can quickly see what your application is doing. Flamegraph, a Pixie always-on visualization, requires no instrumentation, redeploying, or recompiling. It works for compiled languages like Go, C+, Rust, to name a few. And at a glance, Flamegraph tells you what functions your application is spending time on and where you have hot spots. Flamegraph is especially useful for hierarchical resource use, like disk usage and CPU utilization. For more information on how to read Flamegraph, see the Pixie documentation. Debug live On the Live debugging with Pixie tab, run PxL scripts — scripts written in Pixie's PxL language — to view live data captured through eBPF. Select the script drop-down and then select a script to run in the tab. (For best results, select a time range that is recent in the time picker.) Scripts enable you to debug: Traffic in multiple formats: HTTP and HTTPs (including encrypted), DNS, Postgres, MySQL, Cassandra, Redis (currently supporting SQL and HTTP in beta) Kubernetes services and their throughput, error rate, and latency statistics Service maps to learn which services are talking to each other Network traffic maps to learn which nodes are talking to each other JVM data If you don't find the script you need, you can write your own PxL scripts. Find more information about available scripts in Pixie's open source repo.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.01047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Auto-telemetry with Pixie for instant <em>Kubernetes</em> observability",
        "sections": "Use Auto-telemetry with Pixie for instant <em>Kubernetes</em> observability",
        "tags": "<em>Kubernetes</em>",
        "body": "When we say auto-telemetry, we’re not talking about cars — we&#x27;re talking about instant baseline visibility into your <em>Kubernetes</em> clusters. With the New Relic One integration with Pixie, you get similar data to traditional language agents, but without manually instrumenting your code or redeploying"
      },
      "id": "60f07e20196a670a2d38adae"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Access and requirements",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "e90cb97b3973aef0ea5ffe6b428c3b568e77ddf0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-metric-api/",
      "published_at": "2021-07-27T06:15:46Z",
      "updated_at": "2021-07-27T06:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Access and requirements You'll need a New Relic Insert API key. For information on limits and restricted attributes, see Metric API requirements and limits. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting If you receive an NrIntegrationError, see Troubleshoot a NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.763504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em> on metric data",
        "body": " data. <em>Alert</em> on metric data To <em>alert</em> on metrics created with the Metric API, use <em>NRQL</em> <em>alert</em> <em>conditions</em>: Select the <em>NRQL</em> category when defining your condition, then use the FROM Metric ... <em>NRQL</em> query syntax to express it. When you create these <em>alert</em> <em>conditions</em>, Alerts automatically uses the finest"
      },
      "id": "603eac62e7b9d20c222a07c5"
    },
    {
      "sections": [
        "Kubernetes integration: install and configure",
        "Use automated installer",
        "Installs for managed services and platforms",
        "Amazon EKS",
        "Amazon EKS Fargate",
        "Google Kubernetes Engine (GKE)",
        "OpenShift container platform",
        "Azure Kubernetes Service (AKS)",
        "Pivotal Container Service (PKS / VMware Tanzu)",
        "Custom manifest",
        "Important",
        "Make sure New Relic pods can be scheduled",
        "Unprivileged installs of the Kubernetes integration",
        "Tip",
        "Steps to complete an unprivileged install",
        "Configure the integration",
        "Select which processes should send their data to New Relic",
        "Specify the Kubernetes API host and port",
        "Kubernetes versions 1.6 to 1.7.5: Edit manifest file",
        "Use environment variables",
        "Disable kube-state-metrics parsing",
        "Caution",
        "Specify the kube-state-metrics URL",
        "Discover kube-state-metrics pods using a label",
        "Query kube-state-metrics behind RBAC",
        "kube-state-metrics timeout: Increase the client timeout",
        "Non-default namespace deployments: Edit config file",
        "Set the TTL for the Kubernetes API responses cache",
        "Specify base URLs for control plane component endpoints",
        "Configure the infrastructure agent",
        "Update to the latest version",
        "Using the automated installer",
        "Using helm",
        "Uninstall the Kubernetes integration"
      ],
      "title": "Kubernetes integration: install and configure",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Installation"
      ],
      "external_id": "ff06c8b1d8b2940d0b23034f3057377ce571e4ab",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure/",
      "published_at": "2021-07-28T07:32:06Z",
      "updated_at": "2021-07-28T07:32:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The easiest way to install the Kubernetes integration is to use our automated installer to generate a manifest. It bundles not just the integration DaemonSets, but also other New Relic Kubernetes configurations, like Kubernetes events, Prometheus OpenMetrics, and New Relic log monitoring. Use automated installer You can use the automated installer for servers, VMs, and unprivileged environments. The installer can also help you with managed services or platforms after you review a few preliminary notes. We also have separate instructions if you need a custom manifest or prefer to do a manual unprivileged installation. Start the installer If your New Relic account is in the EU region, access the installer from one.eu.newrelic.com. Installs for managed services and platforms Before starting our automated installer, check out these notes for your managed services or platforms: Amazon EKS The Kubernetes integration monitors worker nodes. In Amazon EKS, master nodes are managed by Amazon and abstracted from the Kubernetes platforms. Before starting our automated installer to deploy the Kubernetes integration in Amazon EKS, make sure you are using the version of kubectl provided by AWS. Amazon EKS Fargate For help installing our EKS Fargate integration, see these setup options. Google Kubernetes Engine (GKE) The Kubernetes integration monitors worker nodes. In GKE, master nodes are managed by Google and abstracted from the Kubernetes platforms. Before starting our automated installer to deploy the Kubernetes integration on GKE, ensure you have sufficient permissions: Go to console.cloud.google.com/iam-admin/iam and find your username. Click edit. Ensure you have permissions to create Roles and ClusterRoles: If you are not sure, add the Kubernetes Engine Cluster Admin role. If you cannot edit your user role, ask the owner of the GCP project to give you the necessary permissions. Ensure you have a RoleBinding that grants you the same permissions to create Roles and ClusterRoles: kubectl create clusterrolebinding YOUR_USERNAME-cluster-admin-binding --clusterrole=cluster-admin --user=YOUR_GCP_EMAIL Copy Creating a RoleBinding is necessary because of a known RBAC issue in Kubernetes and Kubernetes Engine versions 1.6 or higher. For more information, see Google Cloud's documentation on defining permissions in a role. OpenShift container platform To deploy the Kubernetes integration with OpenShift: Add the <>{'<release_name>'}</>-newrelic-infrastructure service account to your privileged Security Context Constraints: oc adm policy add-scc-to-user privileged \\ system:serviceaccount:<namespace>:<release_name>-newrelic-infrastructure Copy The default <>{'<release_name>'}</> provided by the installer is nri-bundle. Complete the steps in our automated installer. If you're using signed certificates, make sure they are properly configured by using the following variables in the DaemonSet portion of your manifest to set the .pem file: - name: NRIA_CA_BUNDLE_DIR value: YOUR_CA_BUNDLE_DIR - name: NRIA_CA_BUNDLE_FILE value: YOUR_CA_BUNDLE_NAME Copy YAML key path: spec.template.spec.containers.name.env Save your changes. Azure Kubernetes Service (AKS) The Kubernetes integration monitors worker nodes. In Azure Kubernetes Service, master nodes are managed by Azure and abstracted from the Kubernetes platforms. To deploy in Azure Kubernetes Service (AKS), complete the steps in our automated installer. Pivotal Container Service (PKS / VMware Tanzu) To deploy in PKS, we recommend that you use the automated installer, or you can follow the manual instructions provided in Install the Kubernetes integration using Helm. Custom manifest If the Kubernetes automated installer doesn't provide the settings you need, you can download our manifest template and install the integration manually. To activate the Kubernetes integration, you must deploy the newrelic-infra agent onto a Kubernetes cluster as a DaemonSet: Install kube-state-metrics and get it running on the cluster. For example: curl -L -o kube-state-metrics- 1.9.5 .zip https://github.com/kubernetes/kube-state-metrics/archive/v 1.9.5 .zip && unzip kube-state-metrics- 1.9.5 .zip && kubectl apply -f kube-state-metrics- 1.9.5 /examples/standard Copy Download the manifest file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml Copy In the DaemonSet portion of your manifest, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. Recommendation: Do not change the NRIA_PASSTHROUGH_ENVIRONMENT or NRIA_DISPLAY_NAME value in your manifest. YOUR_CLUSTER_NAME is your cluster’s id in New Relic Explorer. It doesn’t need to match the name of the cluster running in your environment. YAML key path: spec.template.spec.containers.name.env env: - name: NRIA_LICENSE_KEY value: YOUR_LICENSE_KEY - name: CLUSTER_NAME value: YOUR_CLUSTER_NAME Copy If you need to adapt the manifest to fit your environment, review the configure section in this doc. Confirm that kube-state-metrics is installed. kubectl get pods --all-namespaces | grep kube-state-metrics Copy Create the DaemonSet: kubectl create -f newrelic-infrastructure-k8s-latest.yaml Copy Confirm that the DaemonSet has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets Copy To confirm that the integration is working: wait a few minutes, then look for data in the New Relic Kubernetes cluster explorer. If you don't see data, review the configuration procedures again, then follow the troubleshooting procedures. Important In the future, the number of labels collected on Kubernetes objects will be limited per object type (containers, pods, nodes, etc.). If objects have labels above the limit, you will be able to configure important labels that should always be sent to New Relic. When the limitation is in place, this documentation will be updated. Make sure New Relic pods can be scheduled Some of the New Relic pods are set up as DaemonSet in the manifest file so that they can run on every host. These include newrelic-infrastructure and newrelic-logging. In rare circumstances, other pods may be scheduled first and starve the New Relic pods of resources. Since each of these pods have to run on a specific host, they will stay in pending status until that host has enough resources, even if there are other hosts available. This could end up occurring for long periods of time and result in reporting gaps. To prevent this scenario, you can configure the Kubernetes scheduler to give New Relic pods a higher priority. Using the default scheduler: Ensure kube-scheduler flag disablePreemption is not set to true (by default it is false). Create a PriorityClass for the New Relic DaemonSet pods: Set the appropriate priority value, which should generally be higher than your other pods. preemptionPolicy is set to PreemptLowerPriority by default. This allows New Relic pods assigned this priority class to remove lower-priority pods that are taking up resources. Edit the manifest file to add priorityClassName to any DaemonSet specs. In the example below, the highlighted line sets the priority class for newrelic-infrastructure: apiVersion: apps/v1 kind: DaemonSet metadata: namespace: default labels: app: newrelic-infrastructure chart: newrelic-infrastructure-1.0.0 release: nri-bundle mode: privileged name: nri-bundle-newrelic-infrastructure spec: priorityClassName: your-priority-class ... Copy If you have already deployed the New Relic pods, re-deploy them and confirm they have been created: kubectl delete -f newrelic-infrastructure-k8s-latest.yaml kubectl create -f newrelic-infrastructure-k8s-latest.yaml kubectl get daemonsets Copy Unprivileged installs of the Kubernetes integration For platforms that have stringent security requirements, we provide an unprivileged version of the Kubernetes integration. Changes from the standard Kubernetes integration are: Runs the infrastructure agent and the Kubernetes integration as a standard user instead of root No access to the underlying host filesystem No access to /var/run/docker.sock Container's root filesystem mounted as read-only allowPrivilegeEscalation is set to false hostnetwork is set to false The tradeoff is that the solution will only collect metrics from Kubernetes, but it will not collect any metric from the underlying hosts directly. Kubernetes provides some data (metrics and metadata) about its nodes (hosts). Tip Optional: To collect the underlying host metrics, the non-containerized infrastructure agent can be deployed on the underlying host. The infrastructure agent already supports running as non-root. The combination of the Kubernetes integration in its unprivileged version and the agent running on the host will report all the metrics that our standard solution for monitoring Kubernetes receives. Steps to complete an unprivileged install Install kube-state-metrics and get it running on the cluster. For example: curl -L -o kube-state-metrics- 1.9.5 .zip https://github.com/kubernetes/kube-state-metrics/archive/v 1.9.5 .zip && unzip kube-state-metrics- 1.9.5 .zip && kubectl apply -f kube-state-metrics- 1.9.5 /examples/standard Copy Download the integration manifest: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-unprivileged-latest.yaml Copy In the manifest, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. Important YOUR_CLUSTER_NAME is your cluster’s id in New Relic Explorer. It doesn’t need to match the name of the cluster running in your environment. env: - name: NRIA_LICENSE_KEY value: YOUR_LICENSE_KEY - name: CLUSTER_NAME value: YOUR_CLUSTER_NAME Copy YAML key path: spec.template.spec.containers.name.env Confirm that kube-state-metrics is installed. kubectl get pods --all-namespaces | grep kube-state-metrics Copy Create the DaemonSet: kubectl create -f newrelic-infrastructure-k8s-unprivileged-latest.yaml Copy Confirm that the DaemonSet has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets Copy To confirm that the integration has been configured correctly, wait a few minutes, then run this NRQL query to see if data has been reported: SELECT * FROM K8sPodSample since 5 minutes ago Copy Configure the integration The Kubernetes integration comes with a default configuration that should work in most environments. To change the configuration, modify the manifest file: Select which processes should send their data to New Relic By default, data about the processes running on your pods is not sent to New Relic. You can enable it by setting enable_process_metrics to true. To choose what metric data you want to send to New Relic, configure the include_matching_metrics environment variable in your manifest. Specify the Kubernetes API host and port This is necessary when you are using SSL and not using the default FQDN. The Kubernetes API FQDN needs to match the FQDN of the SSL certificate. You do not need to specify both variables. For example, if you only specify the HOST, the default PORT will be used. - name: \"KUBERNETES_SERVICE_HOST\" value: \"KUBERNETES_API_HOST\" - name: \"KUBERNETES_SERVICE_PORT\" value: \"KUBERNETES_API_TCP_PORT\" Copy Kubernetes versions 1.6 to 1.7.5: Edit manifest file For Kubernetes versions 1.6 to 1.7.5, uncomment these two lines in the manifest file: - name: \"CADVISOR_PORT\" # Enable direct connection to cAdvisor by specifying the port. Needed for Kubernetes versions prior to 1.7.6. value: \"4194\" Copy Use environment variables Use environment variables that can be passed to the Kubernetes integration if you use a proxy to configure its URL. Disable kube-state-metrics parsing You can disable kube-state-metrics parsing for the DaemonSet by using the following configuration: - name: \"DISABLE_KUBE_STATE_METRICS\" value: \"true\" Copy Caution Disabling kube-state-metrics also disables data collection for the following: ReplicaSets DaemonSets StatefulSets Namespaces Deployments Services Endpoints Pods (that are pending) Additionally, disabling this affects the Kubernetes Cluster Explorer in the following ways: No pending pods are shown. No filters based on services. Specify the kube-state-metrics URL If several instances of kube-state-metrics are present in the cluster, uncomment and configure the following lines to specify which one to use: - name: \"KUBE_STATE_METRICS_URL\" value: \"http://KUBE_STATE_METRICS_IP_OR_FQDN:PORT\" Copy Important Even though a KUBE_STATE_METRICS_URL is defined, the KSM service should contain one of the following labels for the auto-discovery process: k8s-app=kube-state-metrics OR app=kube-state-metrics OR ​​app.kubernetes.io/name=kube-state-metrics Important This configuration option overrides KUBE_STATE_METRICS_POD_LABEL. If you have both defined, KUBE_STATE_METRICS_POD_LABEL has no effect. Discover kube-state-metrics pods using a label If several instances of kube-state-metrics are present in the cluster, another option to easily target one of these instances with the Kubernetes integration is to use label-based discovery. - name: \"KUBE_STATE_METRICS_POD_LABEL\" value: \"LABEL_NAME\" Copy Important When a KUBE_STATE_METRICS_POD_LABEL is defined, the label should have a value equal to true. For example, if the label name is my-ksm, ensure that my-ksm=true. Important This configuration option is incompatible with KUBE_STATE_METRICS_URL. If you have both defined, KUBE_STATE_METRICS_URL is used. Query kube-state-metrics behind RBAC If your instance of kube-state-metrics is behind kube-rbac-proxy, the integration can be configured in a compatible way using the combination of the label-based discovery and two other environment variables: - name: \"KUBE_STATE_METRICS_SCHEME\" value: \"https\" - name: \"KUBE_STATE_METRICS_PORT\" value: \"KSM_RBAC_PROXY_PORT\" Copy To confirm which port should be used as the value of KUBE_STATE_METRICS_PORT, we recommend running a describe command on the kube-state-metrics pod and look for the port exposed by the container named kube-rbac-proxy-main. Important These two configuration options only work when using the KUBE_STATE_METRICS_POD_LABEL configuration described above. kube-state-metrics timeout: Increase the client timeout To increase the client timeout of kube-state-metrics, add a new environment variable, TIMEOUT, to the manifest file: env: - name: TIMEOUT value: 5000 # The default client timeout when calling kube-state-metrics, in milliseconds Copy Then, add this new environment variable to the NRIA_PASSTHROUGH_ENVIRONMENT Non-default namespace deployments: Edit config file If you want to deploy in a different namespace from default, change all values of namespace in the manifest. Set the TTL for the Kubernetes API responses cache By default, the integration will cache any retrieved information from the Kubernetes API for 5 minutes. Use the API_SERVER_CACHE_TTL environment variable to set a custom cache duration for responses from the API server. Valid time unit values are: ns, us, ms, s, m, and h. To disable caching, set to 0s. env: - name: API_SERVER_CACHE_TTL value: \"1m\" Copy Specify base URLs for control plane component endpoints Use the following environment variables if any of the Kubernetes control plane components export metrics on base URLs that are different from the defaults. This is necessary for environments such as OpenShift when a control plane component metrics endpoint is using SSL or an alternate port. Values of these environment variables must be base URLs of the form [scheme]://[host]:[port]. URLs should not include a path component. For example: - name: \"SCHEDULER_ENDPOINT_URL\" value: \"https://localhost:10259\" - name: \"ETCD_ENDPOINT_URL\" value: \"https://localhost:9979\" - name: \"CONTROLLER_MANAGER_ENDPOINT_URL\" value: \"https://localhost:10257\" - name: \"API_SERVER_ENDPOINT_URL\" value: \"https://localhost:6443\" Copy The /metrics path segment is added automatically. In addition, if the https scheme is used, authentication to the control plane component pod(s) is accomplished via service accounts. Caution If a FQDN (fully qualified domain name) is used in a multi-master cluster, inconsistent results may be returned. Therefore, it is recommended to use localhost only. Important Even though a custom base URL is defined for a given control plane component, the control plane component pod(s) must contain one of the labels supported by the auto-discovery process. Important Even though a custom ETCD_ENDPOINT_URL can be defined, ETCD will always require https and mTLS authentication to be configured. Here are some additional configurations to consider: Do more configuration for control plane monitoring Link New Relic APM to the Kubernetes integration Monitor services that run on Kubernetes Configure the infrastructure agent The Kubernetes integration image comes with a default configurations for the agent that can be modified if needed. When installing with the manifest, you can modify the infrastructure agent configuration by editing the manifest and adding any needed configuration option of the agent as environment variables of the newrelic-infrastructure DaemonSet. When installing with Helm, you can specify the needed infrastructure agent configuration options in the values.yaml as shown in the example in GitHub. The config object is used to populate the configMap that is mounted automatically in the location of the infrastructure agent configuration file in the pods created by the newrelic-infrastructure DaemonSet. Update to the latest version Using the automated installer To update a Kubernetes integration installed with the automated installer, just run the installer again. It will always offer a manifest pointing to the last released version of the integration. Using helm See Install the Kubernetes integration using Helm Custom manifest If you are already running the Kubernetes integration and want to update the newrelic-infra agent to the latest agent version: Run this NRQL query to check which version you are currently running (this will return the image name by cluster): SELECT latest(containerImage) FROM K8sContainerSample WHERE containerImage LIKE '%newrelic/infrastructure%' FACET clusterName SINCE 1 day ago Copy If you've set a name other than newrelic/infrastructure for the integration's container image, the above query won't yield results: to make it work, edit the name in the query. Download the integration manifest file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml Copy Copy the changes you made to the manifest. At a minimum, include CLUSTER_NAME and NRIA_LICENSE_KEY, and paste your changes in the manifest you downloaded. Install the latest DaemonSet with the following command (Kubernetes will automatically do a rollout upgrade for the integration's pods): kubectl apply -f newrelic-infrastructure-k8s-latest.yaml Copy Uninstall the Kubernetes integration To uninstall the Kubernetes integration: Verify that newrelic-infrastructure-k8s-latest.yaml corresponds to the filename of the manifest as you have saved it. Example: If you are using the unprivileged version of the integration, the default filename will be newrelic-infrastructure-k8s-unprivileged-latest.yaml. After you verify the filename, use the following command: kubectl delete -f newrelic-infrastructure-k8s-latest.yaml Copy You only need to execute this command once, regardless of the number of nodes in your cluster.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.93388,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Kubernetes</em> integration: install and configure",
        "sections": "<em>Kubernetes</em> integration: install and configure",
        "tags": "<em>Kubernetes</em> integration",
        "body": " in the results generated by this command: kubectl get daemonsets Copy To confirm that the integration has been configured correctly, wait a few minutes, then run this <em>NRQL</em> query to see if data has been reported: SELECT * FROM K8sPodSample since 5 minutes ago Copy Configure the integration The <em>Kubernetes</em>"
      },
      "id": "60450ae964441f0603378f15"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-07-30T01:51:40Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.68254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "6091fa99196a67e912d52a10"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-07-30T01:50:30Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.691414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "6091fa9928ccbc8f44a2689c"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-07-27T21:12:16Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.29576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": ", go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.475197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-07-27T21:16:13Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.33857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. <em>Explore</em> your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 259.5983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091fa9928ccbc8a70a268ac"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-06-25T01:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostConditions directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_policy\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your main.tf and provider.tf to the stage for commit: bash Copy $ git add main.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.69788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "6091fa98e7b9d2063e506919"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.22687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.42902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "6091fa9964441fe25f2f36f4"
    },
    {
      "sections": [
        "Introduction to Applied Intelligence",
        "Why use Applied Intelligence?",
        "Determine root causes with Incident Intelligence",
        "Find unknowns with Proactive Detection"
      ],
      "title": "Introduction to Applied Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "68af5032ebe9c91467f78169bb5d30976d7f67ee",
      "image": "https://docs.newrelic.com/static/c95c61f5a259d33c01781273aed8311d/30c92/diagram-applied-intelligence-workflow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/introduction-applied-intelligence/",
      "published_at": "2021-07-27T08:59:21Z",
      "updated_at": "2021-07-27T08:59:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applied Intelligence (AI) is our AIOps solution for DevOps, site reliability engineers, and on-call teams. At its core, Applied Intelligence helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. By applying machine learning to your data and feedback, Applied Intelligence is designed to improve functionality and deliver smarter context over time. After connecting your data sources to Applied Intelligence, it looks for potential problems and improves based on your feedback. Why use Applied Intelligence? How you respond to an incident can mean thousands of dollars or clicks for your company. Applied Intelligence helps you solve problems faster. Feature Description Troubleshoot and respond to incidents Our solution helps you understand your incidents and gives you ideas for what to do next. Here are a few examples: Automatically classifies incidents based on the golden signals of site reliability engineering. Identifies entities in your stack that may relate to the underlying issue. Suggests responses for incidents based on historical context. Less noise, more focus As tools and systems become more complex, alert noise can overwhelm DevOps and SRE teams. Applied Intelligence correlates related incidents and suppresses noise, so you're only notified when human action is required. Incidents with a hybrid approach Applied Intelligence streamlines your incidents by combining its built-in inputs with your knowledge and feedback. Over time, the system delivers more accurate insights. For example: Our correlation and classification engine adjusts based on your feedback. The system automatically suggests new correlation rules based on your production data. You can create custom logic using the decision builder. Automatic anomaly detection Applied Intelligence provides automatic anomaly detection on all your New Relic APM-monitored applications. We detect anomalies in throughput, latency, and error rate, with no action required from you. Benefits include: No setup required. See anomalies surfaced automatically in the anomalies feed. See them in various New Relic activity streams (for example, on the New Relic One home page). Ability to run NRQL queries of anomalies and create custom dashboards with that data. Determine root causes with Incident Intelligence As part of Applied Intelligence, Incident Intelligence helps you correlate incident events and reduce noise in your environment. With it, you can get an overview of all your issues, see suggested responders, and configure your own correlation logic. To get started, see Incident Intelligence. Find unknowns with Proactive Detection Another feature of Applied Intelligence is Proactive Detection. Proactive Detection is, by default, always on and detecting anomalies. These anomalies are surfaced in the Applied Intelligence anomalies feed, New Relic One activity streams, and can be queried, alerted on, and added to dashboards. Anomalies can be sent to Slack or via webhooks, and/or added as a source for Incident Intelligence correlation and issue notification. Proactive Detection also provides automatic analysis of anomalies and alerts via the analysis page. To get started, see Proactive Detection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.8673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> and Applied Intelligence",
        "body": " incidents and gives you ideas for what to do next. Here are a few examples: Automatically classifies incidents based on the <em>golden</em> <em>signals</em> of site reliability engineering. Identifies entities in your stack that may relate to the underlying issue. Suggests responses for incidents based on historical"
      },
      "id": "603ea67c64441ffd1c4e8860"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.68267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "6091fa98e7b9d215455068c4"
    },
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-07-30T01:51:40Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.68254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "6091fa99196a67e912d52a10"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-07-27T21:12:16Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.29576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": ", go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.475197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-07-27T21:16:13Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.33857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. <em>Explore</em> your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 845.72815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": " default class MyAwesome<em>NerdpackNerdletNerdlet</em> extends React.Component { render() { return &lt;h1&gt;&quot;Hello, World!&quot;&lt;&#x2F;h1&gt;; } } Copy Step 4 of 9 As an optional step, you can add a custom <em>launcher</em> icon using any image <em>file</em> named icon.png. Replace the default icon.png <em>file</em> under <em>launcher</em> by dragging in your <em>new</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 736.59326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "<em>Launchers</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " up your <em>New</em> <em>Relic</em> <em>One</em> application. Since ab-test-<em>nerdlet</em> is the only <em>Nerdlet</em> in this <em>Nerdpack</em>, there is only <em>one</em> subdirectory. In <em>nerdlets</em>&#x2F;ab-test-<em>nerdlet</em>, there are three files: index.js is the JavaScript <em>file</em> that contains your <em>Nerdlet</em> component styles.scss holds the Sass stylesheet for your"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Subscribe to a Nerdpack",
        "Tag your Nerdpack's release version"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-07-27T01:40:22Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Subscribe to a Nerdpack   Subscribe to a Nerdpack Tag your Nerdpack's release version   Tag your Nerdpack's release version",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 520.25525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes <em>launchers</em>, <em>Nerdlets</em>, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the <em>New</em> <em>Relic</em> platform. Guides to serve, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-07-30T01:44:15Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 416.13586,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions: <em>New</em> <em>Relic</em> <em>One</em> user model",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": ", review the tables below for a summary of your <em>Nerdpack</em> capabilities. Original user model If your organization was created before July 30, 2020 and you haven&#x27;t transitioned to our <em>New</em> <em>Relic</em> <em>One</em> pricing model, you&#x27;re on the original pricing plan. Capabilities for our original user model differ from those"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 297.3332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable advanced configurations for your <em>Nerdpack</em>",
        "sections": "Enable advanced configurations for your <em>Nerdpack</em>",
        "info": "Enable advanced configurations for your <em>Nerdpack</em>",
        "body": "Most of the time, the nr1 <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, <em>Nerdlets</em>, <em>launchers</em>, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.26723,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.7489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.33636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-07-30T01:42:07Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.9375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Features",
        "Improved query abilities",
        "Improved visualizations",
        "Steps for a successful transition"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-07-27T13:37:49Z",
      "updated_at": "2021-07-21T20:51:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we're upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries, charts, and dashboards. With New Relic One, we have modernized the experience for you to access, analyze, and visualize your data. New Relic One offers an improved charts and dashboards experience, and it provides a platform where we can more rapidly bring new innovations to you. This transition guide can help you understand: What are some of the new and improved features you get with New Relic One charts, dashboards, and queries Why it's easy to transition to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Features You can scroll down to the transition details, but first here are some features we've added that show how New Relic One dashboards are a clear improvement over Insights dashboards. Improved query abilities With New Relic One, you get: Ability to query many accounts from the same widget: New Relic One lets you query across all your associated accounts in one place. Better querying and charting experiences: Query access is available globally, no matter where you are in New Relic One. Learn how to browse and query data in New Relic. Improved query experience: You can query both the Metric data type and metric timeslice data. Easy customization: Every visualization now has the query accessible. You can augment any curated chart just by changing the NRQL query. Improved visualizations Not only can you select a wide range of visualization options, you can also add more to your dashboards: Better display options: Make your data easier to understand by using visualizations other than dense, line-heavy charts. New Relic One also offers a better TV mode. Facet linking: You can filter your dashboards by faceted attributes, making your dashboards more interactive and easy to use. There's also support for cases. Learn more. More charts or widgets in an area: Insights restricted you to a 3-across limit. Now you can display up to 12 across your dashboard, providing increased data density along with improved tooltips and tracking across charts. Easier creation of multi-page dashboards: Insights referred to these as data apps. Your Insights data apps are preserved as multi-page dashboards in New Relic One. Chart consistency and flexibility: Dashboards include facet color consistency across widgets and faster loading times for more performant dashboards. Also, you can add any chart type to a dashboard in New Relic One! The New Relic Insights UI has served our users well for many years, but it's time to give you an even better experience. Join us and make the switch to New Relic One! Steps for a successful transition The transition to New Relic One has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to New Relic One UI We have already taken care of your transition from Insights to New Relic One for you! As of April 12, 2021, your old Insights URLs redirect automatically to New Relic One. We recommend that you familiarize yourself with the new UI features available to you, as described in this transition guide. If you need to view any Insights charts embedded in other websites, go to one.newrelic.com > More > Manage Data. (These older embedded charts will continue to function as expected.) Mobile apps The Insights mobile app is deprecated as of April 11, 2021. Go to the Google Play Store 2 or Apple App store. Delete your old Insights mobile app, and download the New Relic One mobile app. tvOS apps and large displays New Relic's tvOS app is still available. No action is needed by you at this time. Some New Relic customers with the original pricing model may have set up dashboards on wall screens for restricted users with kiosk mode. No action is required for you to continue to view these dashboards. APIs In July of 2021, the Insights Dashboard API will be deprecated and replaced with NerdGraph functionality. For more on this change, and tips on how to migrate, see NerdGraph API for dashboards. Partnership accounts This applies only if your account is one of the few using our partnership account structure to deliver New Relic services to your direct customers. In this situation, the Insights EOL will not affect your customers’ pricing. This is simply an EOL for the UI, not an EOL for the account type. Questions If you have questions about the transition, please comment in our Explorers Hub post. Or, if you work with an account team, they will be happy to help you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.18256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "! Steps for a successful transition The transition to <em>New</em> <em>Relic</em> <em>One</em> has two parts: the UI and mobile <em>app</em> experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to <em>New</em> <em>Relic</em> <em>One</em> UI We have already taken care of your transition from Insights to <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "6044171164441f454a378ee2"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 631.9486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the <em>NerdGraphQuery</em> <em>component</em> to an application 20 minutes The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-query/",
      "sections": [
        "NerdGraphQuery",
        "Usage",
        "Examples",
        "Props",
        "Methods",
        "NerdGraphQuery.query",
        "Type definitions",
        "PromiseQueryResult",
        "QueryResult"
      ],
      "published_at": "2021-07-30T01:54:31Z",
      "title": "NerdGraphQuery",
      "updated_at": "2021-06-25T01:48:19Z",
      "type": "developer",
      "external_id": "1ada6e056e031c141b2bb989e4ec200b3a7ce988",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One SDK provides Query components based on ApolloClient's query components. These components are an abstraction layer making it easier to query NerdGraph without worrying about configuring Apollo Client and, for the most common use cases, without having to write GraphQL queries. A generic NerdGraph Query component that allows you to query anything from NerdGraph. Usage import { NerdGraphQuery } from 'nr1' Copy Examples Props childrenfunction Render prop function as a child. function ( queryResult : QueryResult // Results of the query. ) => React.ReactNode fetchPolicyTypeenum DEFAULT NerdGraphQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_FIRST , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. Set to zero to avoid any kind of regular polling. queryrequiredstring|object GraphQL query, either as a string or a GraphQL document parsed into an AST by the gql method of nr1. skipboolean DEFAULT false When set to true, the query will be skipped entirely from rendering. variablesobject DEFAULT {} Object containing all of the variables your query needs to execute. Methods NerdGraphQuery.query Static method to use NerdGraphQuery as a Promise instead of as a React component. function ( props : Object // Object containing the query options. Any NerdGraphQuery prop is a valid option except children and pollInterval. ) Type definitions PromiseQueryResult { error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your query. fetchMore : function|null, // If not null, fetchMore allows you to load more results for your query. New data is merged with previous data. refetch : function, // Refetch the query. } QueryResult { loading : boolean, // Indicates that the request is in flight. error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your query. fetchMore : function|null, // If not null, fetchMore allows you to load more results for your query. New data is merged with previous data. refetch : function, // Refetch the query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 417.90646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphQuery</em>",
        "sections": "<em>NerdGraphQuery</em>",
        "body": " containing all of the variables your <em>query</em> needs to execute. Methods <em>NerdGraphQuery.query</em> Static method to use <em>NerdGraphQuery</em> as a Promise instead of as a React <em>component</em>. function ( props : Object &#x2F;&#x2F; Object containing the <em>query</em> options. Any <em>NerdGraphQuery</em> prop is a valid option except children"
      },
      "id": "6091f8cee7b9d213095068a2"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-29T01:40:31Z",
      "updated_at": "2021-07-27T11:27:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 378.19977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "sections": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "tags": "<em>NerdGraph</em>",
        "body": "&quot;: &quot;{ requestContext { userId apiKey } }&quot; } &#x27; Copy What can you do with <em>NerdGraph</em>? <em>NerdGraph</em> functionality can be broken <em>down</em> into two main categories: Querying New Relic <em>data</em>. You can fetch <em>data</em> for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One <em>app</em> for custom"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-27T21:14:17Z",
      "updated_at": "2021-07-27T21:14:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also duplicate your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 363.28943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " be before the endTime. Modify it and run the <em>query</em> again. <em>NerdGraph</em>GetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify <em>app</em>Id, <em>app</em>Name or entity.guid"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage data coming into New Relic",
        "Important",
        "Data ingestion sources",
        "Break down data to see what's contributing to your ingest",
        "How we break your ingest data down",
        "Set alerts for data use",
        "Adjust your data ingest"
      ],
      "title": "Manage data coming into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "f6af5123503549262d48d7cc1cc609b506b0853a",
      "image": "https://docs.newrelic.com/static/82d3c36157005ac0efe40cd6e10fe06b/b23ad/data-facet.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/manage-data-coming-new-relic/",
      "published_at": "2021-07-27T06:13:51Z",
      "updated_at": "2021-07-22T05:32:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you connect your data to New Relic, we process what we receive and apply data dropping and transformation rules. Then we count the bytes needed to represent your data in a standard format, like JSON. If you're on our New Relic One pricing plan, you're charged by the number of bytes written to our database, above and beyond the standard amount that’s free. Important This doc is for accounts on our New Relic One pricing plan. If you're on our original product-based pricing plan, see Original data retention. Not sure which you're on? See Overview of pricing and account/user structure. The Data ingestion page shows your ingest rates for a period you specify on the top-right of the Data management hub. Since 30 days ago is the default setting, but you can also set a custom date span. The page shows your daily average GBs, and the total for the range you set. You can toggle between an overall ingest view and an account view to identify which of your accounts are sending the most data. The page also provides the current month-to-date, and the projected end-of-month total ingest rates. With this information, you can proactively drop data or turn off agents in order to manage ingest and, therefore, costs. If you want to take a look at how we query the data, click the ellipsis icon (just above the chart) to slide out the chart query and open it in our query builder. And If you want to drill down further into your data usage, check out the sample queries in the usage docs. From the Login drop-down, select Manage your data, and then select Data ingestion. This is the Data ingestion page with data source and account views. Data ingestion sources The Data ingestion page describes which of your data sources provide the most data on average and during specific data ranges. The sources are described here. Billable data sources Description Timeslices (1-minute) and Metric:Raw Metrics are timeslices + MetricRaw Metric group: MetricsBytes Metric timeslice data averages to one-hour periods after eight days. After 90 days, the permanent metric data continues to be stored in one-hour periods. We currently store the raw metric data for 30 days. You are only billed for the initial ingest volume. You are not billed for subsequent rollups. APM (transactions and errors) APM events Metric group: ApmEventsBytes InfraSamples:Raw Includes multiple Infrastructure events Infrastructure host data Metric group:InfraHostBytes Information related to your servers and virtual machines coming from infrastructure agents, including storage and network data Infrastructure process data stored in ProcessSample. Metric group: InfraProcessBytes Data are metrics related to each process running on the hosts running the Infrastructure agent. This feature is turned off by default. Infrastructure integrations Metric group: InfraIntegrationBytes Performance data related to applications and services, typically managed by the customer, including data related to Docker containers, Windows services, Nagios checks, and cloud integrations such as managed services in AWS, Azure, and GCP. Logging Includes logs and LogExtendedRecord Metric group: LoggingBytes Log messages longer than 4KB are split into multiple events that, when needed, are stitched together to display the original message; this reduces the size of message data. Default Custom events Metric group: CustomEventsBytes Mobile error Mobile general Breadcrumb crash event trails Mobile session Mobile exception Mobile crash Mobile events Metric group: MobileEventsBytes Tracing Metric group: TracingBytes TracingBytes includes Span and OpenTelemetry's SpanEvent. You are not charged for DistributedTraceSummary events. Browser:EventLog Browser Browser:JSErrors PcvPerf (PageView timing) Browser events Metric group: BrowserEventsBytes Lambda Serverless Metric group: ServerlessBytes Break down data to see what's contributing to your ingest You can inspect your data ingest to gain more information about your ingest health. This way, you'll know your baselines, and can more easily spot an anomaly like an ingest spike, as well as its source. To break down your ingested data, start from the chart on the Data ingestion page. Think of the data source bands as the Y axis, and the dates as the X axis. Click on the band you want to inspect at the spot in the X axis that corresponds with the date you want to investigate. This image shows the Metrics band for June 15 right before it's clicked. A modal opens with the account, data source, and facet selected. You can do a handful of things on this page: Change the account, data source, or facet you want to drill down into. Change the date and time to investigate. Review the results of the query in chart form. The chart displays the top 15 results for the facet query. Open the NRQL query in the Query builder where you'll find additional facets that you can use. Learn more about NRQL queries here. How we break your ingest data down Some of the content in the UI is variable, depending on your account. This information is intended to help you understand how we're working with your ingest data. The chart on the Data ingestion page shows data usage for a little longer time frame than that covered by your retention settings for each data ingest source. If you choose a date outside of your designated retention period for an ingest source, you'll get the message that there's no chart data available. Select a more recent date to fix this problem. If you inspect a data source for an account that has less than a terrabyte of data, we compute the ingest volume over a 24 hour period; otherwise, we compute it for a 1 hour period. The ingest value provided on the main Data ingestion chart will be slightly different from that reflected during inspection. This is because our facet computation is an estimate. Set alerts for data use Query and alert on usage data describes how to set alerts to get notified if you're nearing data ingest limits you don't want to cross. For example, you might set an alert on logs, which can stack up quickly in an active system. Adjust your data ingest Drop data for lower retention costs and data compliance On ingest, we apply data dropping rules so you won't be charged for data that's not useful. Learn how to set additional data dropping rules yourself. Use NerdGraph to drop entire data types or drop data attributes from data types so they’re not written to NRDB. This enables you to focus on the data you want, reduces retention costs, and avoids writing sensitive data to the database. For dropping log data, see Drop data with drop filter rules. Turn off agents and integrations If you don’t need data from specific agents or integrations that you have installed, you can uninstall/delete those tools. For instructions, see the specific documentation for an agent or integration.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.58664,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>data</em> coming into New Relic",
        "sections": "Break <em>down</em> <em>data</em> to see what&#x27;s contributing to your ingest",
        "tags": "Telemetry <em>Data</em> Platform",
        "body": " the Login <em>drop</em>-<em>down</em>, select Manage your <em>data</em>, and then select <em>Data</em> ingestion. This is the <em>Data</em> ingestion page with <em>data</em> source and <em>account</em> views. <em>Data</em> ingestion sources The <em>Data</em> ingestion page describes which of your <em>data</em> sources provide the most <em>data</em> on average and during specific <em>data</em> ranges"
      },
      "id": "603e978228ccbc8984eba79e"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-07-27T14:48:53Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 312.608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-07-30T01:49:24Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.73235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> <em>access</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use Nerd<em>Storage</em> SDK <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of <em>data</em>, including users&#x27; configuration settings"
      },
      "id": "6091fa39e7b9d2e1425068b8"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.34198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of the accounts you have <em>access</em> to. A workload can include: Any <em>New</em> <em>Relic</em>-monitored entity, including services, browser <em>apps</em>, mobile <em>apps</em>, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.66608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. <em>New</em> <em>Relic</em> <em>One</em>: a programmable platform We strive to have an automated user"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.88287,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " 45 seconds!): Short guide to using the <em>New</em> <em>Relic</em> Explorer. View and connect the performance of your entities <em>Access</em> the <em>New</em> <em>Relic</em> Explorer at <em>one</em>.newrelic.com and see together <em>data</em> reported by any entity from across all of your <em>New</em> <em>Relic</em> accounts. Entity categories include: Services: APM-monitored"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.32469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Create a <em>custom</em> <em>map</em> <em>view</em>",
        "body": " visualization with configuration options 10 min Customize your visualization using configuration Add a table to your <em>app</em> 30 min Add a table to your New Relic One <em>app</em> <em>Nerdpack</em> permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a <em>custom</em> <em>map</em> <em>view</em> 30 min Build an <em>app</em> to show <em>page</em> <em>view</em> data on a <em>map</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-07-30T01:44:23Z",
      "updated_at": "2021-07-30T01:44:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.04675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example of <em>custom</em> configuration",
        "body": " this to the above command: -e NR_EU_<em>REGION</em>=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add <em>custom</em> tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest"
      },
      "id": "6043a32364441fa554378eee"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-07-30T01:54:32Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.784195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure your <em>custom</em> visualization",
        "sections": "Configure your <em>custom</em> visualization",
        "info": "Configure your <em>custom</em> visualization",
        "body": ": <em>Nerdpack</em> items all have nr1.json metadata files. The schemaType describes the item&#x27;s schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization&#x27;s string identifier. This must be unique within a given <em>Nerdpack</em>, but it doesn&#x27;t need to be unique across all Nerdpacks. displayName"
      },
      "id": "6091fa3a64441fa2172f3714"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin Before you begin, we recommend first reading about permissions. To start building, you must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.24975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "body": " guides: Build a &quot;Hello, World!&quot; application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query"
      },
      "id": "6091fa3ae7b9d2e0595068b1"
    },
    {
      "sections": [
        "Configure polling frequency and data collection for cloud integrations",
        "Overview of settings",
        "Caution",
        "Change polling frequency",
        "Specify data to be fetched",
        "Data collection",
        "Filters",
        "Potential impact on alerts and charts"
      ],
      "title": "Configure polling frequency and data collection for cloud integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "Infrastructure integrations",
        "Cloud integrations"
      ],
      "external_id": "b900b7545f9032201c212449be114e10176bf789",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/infrastructure-integrations/cloud-integrations/configure-polling-frequency-data-collection-cloud-integrations/",
      "published_at": "2021-07-29T01:48:56Z",
      "updated_at": "2021-07-27T15:37:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our cloud integrations get data from cloud provider APIs. In New Relic, you can change some of the data collection-related settings for your cloud integrations. Read on to see what changes you can make and the reasons for making them. Overview of settings New Relic cloud integrations get data from cloud providers' APIs. Data is generally collected from monitoring APIs such as AWS CloudWatch, Azure Monitor, and GCP Stackdriver, and inventory metadata is collected from the specific services' APIs. You can use the account status dashboard to see how your cloud integrations are handling data from a cloud service provider. If you want to report more or less data from your cloud integrations, or if you need to control the use of the cloud providers' APIs to prevent reaching rate and throttling limits in your cloud account, you can change the configuration settings to modify the amount of data they report. The two main controls are: Change polling frequency Change what data is reported Examples of business reasons for wanting to change your polling frequency include: Billing: If you need to manage your AWS CloudWatch bill, you may want to decrease the polling frequency. Before you do this, make sure that any alert conditions set for your cloud integrations are not affected by this reduction. New services: If you are deploying a new service or configuration and you want to collect data more often, you may want to increase the polling frequency temporarily. Caution Changing the configuration settings for your integrations may impact alert conditions and chart trends. Change polling frequency The polling frequency configuration determines how often New Relic reports data from your cloud provider for each service. By default, the polling frequency is set to the maximum frequency that is available for each service. To change the polling frequency for a cloud integration: Go to one.newrelic.com > Infrastructure. Select the tab that corresponds to your cloud service provider. Select Configure next to the integration. Use the dropdowns next to Data polling interval every to select how frequently you want New Relic to capture your cloud integration data. Specify data to be fetched You can specify which information you want captured for your cloud integration by enabling the collection of additional data and by applying multiple filters to each integration. To change this settings for your cloud integration: Go to one.newrelic.com > Infrastructure. Select the tab that corresponds to your cloud service provider. Select Configure next to the integration. Under Data collections and filters, turn the toggles you want On. For filters, select or enter the values that you want included in your reported data. Data collection For some cloud integrations, an additional number of calls to the cloud provider APIs are needed in order to collect data. For example, to fetch tags for AWS Elastic Map Reduce clusters, an additional call to the service API is required. To better control the amount of API calls that are sent to your cloud account for these integrations, you can specify when you need these types of data to be collected. Different data collection toggles are available, depending on the integration. Toggle Description Collect tags Some integrations require additional API calls to the cloud provider to report tags. Tag collection is enabled by default. Switch this to Off if you don't want the integration to collect your cloud resource tags and thus reduce the volume of API calls. Collect extended inventory Some integrations can collect extended inventory metadata about your cloud resources by making additional API calls to the cloud provider. The metadata included within the extended inventory for each cloud integration is described in the integration documentation. Extended inventory collection is disabled by default. Switch this to On if you want to monitor extended inventory. This will increase the volume of API calls. Collect shards data Available for AWS Kinesis Streams integration. By default, we don't report shard metrics. Switch this to On if you want to monitor shard metrics in addition to data stream metrics. Collect Lambda@Edge data Available for AWS CloudFront integration. By default, we don't report Lambda@Edge data. Switch this to On if you're using Lambda@Edge in AWS CloudFront and want to get Lambda execution location metadata. Collect node data Available for AWS Elasticsearch integration. By default, we don't report Elasticsearch node metrics. Switch this to On if you want to monitor node metrics in addition to cluster metrics. Collect NAT Gateway data and Collect VPN data Available for AWS VPC integration. By default, we don't report NAT Gateway nor VPN metrics. Switch these to On if you want to monitor NAT Gateway and VPN metrics and inventory, in addition to other VPC related entities inventory. Collect IP addresses Available for AWS EC2 integration. By default, we collect EC2 instance metadata that includes public and private IP addresses, and network interface details. Switch this to Off if you don't want New Relic to store and display these IP data. Filters When a filter is On, you specify the data that you want to be collected; for example, if the Limit to AWS region is On, the regions that you select will be the ones that data will be collected for. There are different filters available, depending on the integration: Filter Description Region Select the regions that include the resources that you want to monitor. Queue prefixes Available for AWS SQS integration. Enter each name or prefix for the queues that you want to monitor. Filter values are case-sensitive. Load balancer prefixes Available for AWS ALB integration. Enter each name or prefix for the application load balancers that you want to monitor. Filter values are case-sensitive. Stage name prefixes Available for AWS API Gateway integration. Enter each name or prefix for the stages that you want to monitor. Filter values are case-sensitive. Tag key Enter one tag key that is associated with the resources that you want to monitor. Filter values are case-sensitive, and you can use this filter in combination with tag value filter. Tag value Enter one tag value that is associated with the resources that you want to monitor. Filter values are case-sensitive, and you can use this filter in combination with tag key. Resource group Select the resource groups that are associated with the resources that you want to monitor. Potential impact on alerts and charts If you change an integration's configuration, it can impact alert conditions and charts. Here are some things to consider: If you change this setting... It may have this impact... Any configuration setting When you change the configuration settings, the data that New Relic displays in infrastructure charts, on the inventory page, and in the events feed changes as well. Any filters When you create alert conditions after you set filters, make sure that your alerts are not triggered by resources that you filtered out. Filter for regions If you filter for specific regions, it may lower the amount of data reported to New Relic, which could trigger an alert. If you create an alert condition for a specific region and then filter that region out, the region would no longer report data and would never trigger the alert. Polling frequency When you create an alert, make sure that you define the threshold for a time period that is longer than the polling frequency. Tags and extended inventory If you turn on tags and/or extended inventory, New Relic makes more API calls to the cloud provider, which could increase your cloud provider API usage bill.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.28429,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " want included in your reported data. Data collection For some cloud integrations, an additional number of calls to the cloud provider APIs are needed in order to collect data. For example, to fetch tags for AWS Elastic <em>Map</em> Reduce clusters, an additional call to the service API is required. To better"
      },
      "id": "603e8eef64441fcc7e4e8853"
    }
  ],
  "/components/charts": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.3603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable advanced configurations for your <em>Nerdpack</em>",
        "sections": "Enable advanced configurations for your <em>Nerdpack</em>",
        "info": "Enable advanced configurations for your <em>Nerdpack</em>",
        "body": " configurations for your <em>Nerdpack</em>. Before you begin Make sure you have the latest version of the <em>nr1</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Extend your webpack configuration You can use our .extended-webpackrc.js <em>file</em> to extend your webpack 4 configuration. This allows you to add your own aliases, scripts"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    },
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.33179,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install and configure the New Relic One <em>CLI</em>",
        "sections": "Install and configure the New Relic One <em>CLI</em>",
        "info": "Install and configure the New Relic One <em>CLI</em>",
        "body": " profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ <em>nr1</em> profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One <em>CLI</em>! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a <em>Nerdpack</em>."
      },
      "id": "6091faf1196a6714b4d52a39"
    },
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.859566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Account access, deselect the account you want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you&#x27;ve built a New Relic One application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a <em>Nerdpack</em>"
      },
      "id": "6091fb4464441f42962f3737"
    },
    {
      "sections": [
        "Subscribe to a Nerdpack",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Tip",
        "Subscribe from the command line",
        "Technical detail",
        "Unsubscribe from a Nerdpack",
        "Unsubscribe using the command line",
        "Resolve issues with accessing your published Nerdpack",
        "Tag your Nerdpack version",
        "Subscribe with the web UI"
      ],
      "title": "Subscribe to a Nerdpack",
      "type": "developer",
      "tags": [
        "nerdpack",
        "subscribe"
      ],
      "external_id": "1e44b2ed6ab9788b17cd19ca10ae4b4cfd4c2fe1",
      "image": "https://developer.newrelic.com/static/157cec05491eea35b82fe9066d24f004/0086b/subscribe-to-account-maturity-app.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/subscribe/",
      "published_at": "2021-07-30T01:51:40Z",
      "updated_at": "2021-05-21T01:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to subscribe to a Nerdpack",
      "body": "Subscribe to a Nerdpack to use it in the New Relic platform. Unsubscribe from Nerdpacks you no longer use. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To subscribe to a Nerdpack, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can subscribe to them: Publish your Nerdpack Tag your Nerdpack if it's published and doesn't yet have a tag Subscribe to a Nerdpack Subscribe to a published Nerdpack, with either the web UI or the nr1 CLI, to use it in your account. Subscribing allows you to select the tagged version you want to use as well as the account you want to subscribe with. This lets you control what Nerdpacks you use in your account. Tip When the tag you've subscribed to gets an update, New Relic updates your Nerdpack automatically. Step 1 of 7 Go to New Relic: Step 2 of 7 Navigate to Apps: Step 3 of 7 Find your published Nerdpack under New Relic One catalog: All published Nerdpacks are shown in the New Relic One catalog. However, the one you're looking for maybe filtered out. Adjust the filter to find the Nerdpack you're looking for: Step 4 of 7 Select the Nerdpack you want to add to your New Relic account: Step 5 of 7 Click Add this app: This button says Manage access if you're already subscribed to the Nerdpack. Step 6 of 7 Select the account to subscribe with and the tagged version to subscribe to. Then, update your account(s): Tip In the web UI, and some places in the CLI, we refer to tags as channels. This is a relic of a past implementation of Nerdpack versioning. Ignoring historical and implementation details, consider them to be synonyms. Now you, and members of the accounts you've subscribed with, can launch the Nerdpack from New Relic. Step 7 of 7 If you subscribed to an app, find it under Your apps: If you subscribed to a visualization, find it under Custom visualizations: Subscribe from the command line If you've published your own Nerdpack, it may be quicker to subscribe to your Nerdpack with the nr1 CLI. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack For simplicity, this guide refers to your Nerdpack as my-awesome-nerdpack. Step 2 of 3 Ensure that your Nerdpack was published and tagged: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------------- ------ 1.0.0 a few seconds ago STABLE You should see at least one published version with a tag. It doesn't have to be STABLE. You can subscribe to any tagged version. Step 3 of 3 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe --channel=STABLE Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the STABLE channel Here, you've subscribed to the STABLE tag. You can also subscribe to DEV and BETA tags from the CLI, but the subscription command doesn't allow for arbitrary tags. To subscribe to any other tagged version, you need to use the web UI. Similar to the web UI, the term channel nr1 nerdpack:subscribe is a reference to an older implementation of Nerdpack versions. Technical detail nr1 nerdpack:subscribe is an alias for nr1 subscription:set. Read the nr1 subscription:set documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:set --help Unsubscribe from a Nerdpack Unsubscribe from a Nerdpack to remove it from your account. Step 1 of 5 Go to New Relic: Step 2 of 5 Navigate to Apps: Step 3 of 5 Click the \"i\" icon next to the Nerdpack you're subscribed to: This opens the detail page. Step 4 of 5 Click Manage access: Step 5 of 5 Deselect the accounts you want to unsubscribe with. Then, update those accounts: Unsubscribe using the command line Quickly unsubscribe your CLI profile from Nerdpacks. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack Step 2 of 3 View your profile's subscriptions: bash Copy $ nr1 subscription:list Listing subscribed deployed nerdpacks on your account: Version UUID Name Date User ------- ------------------------------------ ---------------- ----------- ------- 0.6.4 384de6e5-8e57-4d56-9d13-299ee7ae8641 Account Maturity a month ago 2774472 Step 3 of 3 Unsubscribe from the Nerdpack with the UUID: bash Copy $ nr1 nerdpack:unsubscribe --nerdpack-id=384de6e5-8e57-4d56-9d13-299ee7ae8641 Unsubscribed account 1234567 from the nerdpack 384de6e5-8e57-4d56-9d13-299ee7ae8641 on the STABLE channel. Tip nr1 nerdpack:unsubscribe is an alias for nr1 subscription:unset. Read the nr1 subscription:unset documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:unset --help Resolve issues with accessing your published Nerdpack Sometimes, when you subscribe to a Nerdpack, you may run into issues. Whether you can't subscribe or see duplicate subscriptions in your account, consider some common solutions for resolving these issues. Tag your Nerdpack version When you subscribe to an Nerdpack, you choose a specific tag. So, if the Nerdpack you're trying to subscribe to isn't tagged, or doesn't have the tag you're targeting, tag your release version: bash Copy $ nr1 nerdpack:subscribe --channel=DEV › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel DEV. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED $ nr1 nerdpack:tag --tag=DEV ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as DEV. $ nr1 nerdpack:subscribe --channel=DEV Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the DEV channel. If you subscribe without a --channel argument, the default channel is STABLE, so make sure you have a STABLE version in this case: bash Copy $ nr1 nerdpack:subscribe › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel STABLE. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED Subscribe with the web UI When you subscribe with the CLI, you pass a --channel argument to select a tag. A channel is, for all intents and purposes, a tag. This term is a relic of a past implementation of Nerdpack versioning. However, while the terms are synonymous, using --channel is limited in the CLI. When you subscribe with a --channel, you can only choose between DEV, BETA, and STABLE. So, to subscribe to a different tag, use the web UI: bash Copy $ nr1 nerdpack:subscribe --channel=QA › Error: Expected --channel=QA to be one of: DEV, BETA, STABLE › See more help with --help › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.6651,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Subscribe to a <em>Nerdpack</em>",
        "sections": "Subscribe to a <em>Nerdpack</em>",
        "info": "Learn to subscribe to a <em>Nerdpack</em>",
        "tags": "<em>nerdpack</em>",
        "body": "Subscribe to a <em>Nerdpack</em> to use it in the New Relic platform. Unsubscribe from Nerdpacks you no longer use. Update your <em>CLI</em> Before you run any commands, ensure that you have the latest version of the <em>CLI</em>: bash Copy $ <em>nr1</em> update Check your permissions To subscribe to a <em>Nerdpack</em>, you need: Access"
      },
      "id": "609c8686196a67beaed52a2c"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.544975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "6091fa39196a67a4ead52a4b"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you’re looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 μs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is “loading” its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.90152,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to use charts in your <em>NR1</em> app.",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "In your application, you can display data in charts, like those used elsewhere in New Relic&#x27;s user interface. The New Relic <em>One</em> SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply"
      },
      "id": "6091fb4428ccbc063ca268b7"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.46088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d<em>1</em>ef88dd0 version <em>1</em>.0.0 as STABLE. This means that your <em>Nerdpack</em> was published to the New Relic <em>One</em> <em>catalog</em> that you can find under Apps. Step 2 of 9 <em>Subscribe</em> to your <em>Nerdpack</em>: bash Copy $ <em>nr1</em> <em>nerdpack:subscribe</em> Subscribed account 3014918"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-07-30T01:48:13Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.20737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create your visualization Step <em>1</em> of 2 Ensure you&#x27;re working with the latest version of the New Relic <em>One</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 2 Create a visualization, called radar-or-treemap, in a <em>Nerdpack</em>, called alternate-viz: bash"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.42938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your <em>Nerdpack</em>, publish and <em>subscribe</em> to your visualization: bash Copy $ <em>nr1</em> <em>nerdpack</em>:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Customize your visualization with configuration options",
        "Course",
        "Tip",
        "Add a new configuration option",
        "Replace your SegmentedControl with the configurable property",
        "Summary"
      ],
      "title": "Customize your visualization with configuration options",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9028e58f383ea362d2c9d3a7ecd6404dbfeac87c",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/customize-visualizations-with-configuration/",
      "published_at": "2021-07-30T01:48:12Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization using configuration",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Custom visualizations and the New Relic One SDK, before starting this one. In the previous lesson, you built a custom visualization that shows queried data in one of two chart types: RadarChart Treemap You used a SegmentedControl to switch between the two chart types in the visualization UI. This implementation takes up space in the visualization, but it offers your users the choice to switch between two chart types even after you've created an instance of your chart. But what if you only need to be able to select an option once, when initializing the visualization? In this lesson you'll learn how to add a configuration option to your visualization which replaces the SegmentedControl. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Add a new configuration option Step 1 of 8 In your visualization's nr1.json file, add an enum configuration object for selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve If you're still serving your Nerdpack from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to nr1.json. Step 4 of 8 Go to https://one.newrelic.com/?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from the local server. Step 5 of 8 Open the Apps page: Step 6 of 8 Go to Custom Visualizations, which is favorited by default: Step 7 of 8 In Custom Visualizations, find and click your visualization: Step 8 of 8 Notice the new Select chart configuration option: Selecting a chart type doesn't effect your visualization. This is because you first need to introduce the selectedChart property to the visualization component. Then, you use selectedChart to determine the chart type to render. Replace your SegmentedControl with the configurable property Step 1 of 5 Open your visualization's index.js file. You'll be working here for the rest of the guide. Step 2 of 5 In render(), include selectedChart as a constant you get from destructuring props, and remove your component's state: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now that you're using selectedChart from the configuration options instead of component state, you can select a chart in the configuration panel and watch the visualization change. Unfortunately, there's a bug. The default chart option is Radar, but the initial render shows a Treemap. Step 3 of 5 Update your ternary expression to account for the case where there is no selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now, your data is rendered in a RadarChart if you haven't yet configured the option. Step 4 of 5 Remove SegmentedControl from render(): index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 Spinner, 18 } from 'nr1'; 19 20 const CHART_TYPES = { 21 'Radar': 'radar', 22 'Treemap': 'treemap' 23 } 24 25 export default class RadarOrTreemapVisualization extends React.Component { 26 // Custom props you wish to be configurable in the UI must also be defined in 27 // the nr1.json file for the visualization. See docs for more details. 28 static propTypes = { 29 /** 30 * A fill color to override the default fill color. This is an example of 31 * a custom chart configuration. 32 */ 33 fill: PropTypes.string, 34 35 /** 36 * A stroke color to override the default stroke color. This is an example of 37 * a custom chart configuration. 38 */ 39 stroke: PropTypes.string, 40 /** 41 * An array of objects consisting of a nrql `query` and `accountId`. 42 * This should be a standard prop for any NRQL based visualizations. 43 */ 44 nrqlQueries: PropTypes.arrayOf( 45 PropTypes.shape({ 46 accountId: PropTypes.number, 47 query: PropTypes.string, 48 }) 49 ), 50 }; 51 52 /** 53 * Restructure the data for a non-time-series, facet-based NRQL query into a 54 * form accepted by the Recharts library's RadarChart. 55 * (https://recharts.org/api/RadarChart). 56 */ 57 transformData = (rawData) => { 58 return rawData.map((entry) => ({ 59 name: entry.metadata.name, 60 // Only grabbing the first data value because this is not time-series data. 61 value: entry.data[0].y, 62 })); 63 }; 64 65 /** 66 * Format the given axis tick's numeric value into a string for display. 67 */ 68 formatTick = (value) => { 69 return value.toLocaleString(); 70 }; 71 72 render() { 73 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 74 75 const nrqlQueryPropsAvailable = 76 nrqlQueries && 77 nrqlQueries[0] && 78 nrqlQueries[0].accountId && 79 nrqlQueries[0].query; 80 81 if (!nrqlQueryPropsAvailable) { 82 return <EmptyState />; 83 } 84 85 return ( 86 <AutoSizer> 87 {({width, height}) => ( 88 <NrqlQuery 89 query={nrqlQueries[0].query} 90 accountId={parseInt(nrqlQueries[0].accountId)} 91 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 92 > 93 {({data, loading, error}) => { 94 if (loading) { 95 return <Spinner />; 96 } 97 98 if (error) { 99 return <ErrorState />; 100 } 101 102 const transformedData = this.transformData(data); 103 104 return ( 105 <React.Fragment> 106 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 107 <RadarChart 108 width={width} 109 height={height} 110 data={transformedData} 111 > 112 <PolarGrid /> 113 <PolarAngleAxis dataKey=\"name\" /> 114 <PolarRadiusAxis tickFormatter={this.formatTick} /> 115 <Radar 116 dataKey=\"value\" 117 stroke={stroke || '#51C9B7'} 118 fill={fill || '#51C9B7'} 119 fillOpacity={0.6} 120 /> 121 </RadarChart> 122 ) : ( 123 <Treemap 124 width={width} 125 height={height} 126 data={transformedData} 127 dataKey=\"value\" 128 ratio={4 / 3} 129 stroke={stroke || '#000000'} 130 fill={fill || '#51C9B7'} 131 /> 132 )} 133 </React.Fragment> 134 ); 135 }} 136 </NrqlQuery> 137 )} 138 </AutoSizer> 139 ); 140 } 141 } 142 143 const EmptyState = () => ( 144 <Card className=\"EmptyState\"> 145 <CardBody className=\"EmptyState-cardBody\"> 146 <HeadingText 147 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 148 type={HeadingText.TYPE.HEADING_3} 149 > 150 Please provide at least one NRQL query & account ID pair 151 </HeadingText> 152 <HeadingText 153 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 154 type={HeadingText.TYPE.HEADING_4} 155 > 156 An example NRQL query you can try is: 157 </HeadingText> 158 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 159 </CardBody> 160 </Card> 161 ); 162 163 const ErrorState = () => ( 164 <Card className=\"ErrorState\"> 165 <CardBody className=\"ErrorState-cardBody\"> 166 <HeadingText 167 className=\"ErrorState-headingText\" 168 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 169 type={HeadingText.TYPE.HEADING_3} 170 > 171 Oops! Something went wrong. 172 </HeadingText> 173 </CardBody> 174 </Card> 175 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 5 of 5 Serve your Nerdpack locally, and view it in the Custom Visualizations app in New Relic. Select a chart type from the dropdown in the configuration sidebar, and see your visualization update to show the matching chart type: Summary Congratulations on completing this lesson! You've learned how to customize your visualization using nr1.json configuration. Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Add custom visualizations to your dashboards.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.0732,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>nerdpack</em>:serve If you&#x27;re still serving your <em>Nerdpack</em> from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to <em>nr1</em>.json. Step 4 of 8 Go to https:&#x2F;&#x2F;<em>one</em>.newrelic.com&#x2F;?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from"
      },
      "id": "6091fa3ae7b9d2df595068c1"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.26723,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> <em>account</em> for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-05-05T01:53:28Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.04988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a <em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use <em>CLI</em> commands to: Generate"
      },
      "id": "6091fa9864441feb412f36d4"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.64838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.33636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or data from another service or <em>API</em>. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> apps. If you want to get started building quickly, first read the requirements. <em>New</em> <em>Relic</em> <em>One</em>: a programmable platform We strive to have an automated user"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-27T12:29:06Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.04492,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " with. Get acquainted with the enhanced distributed tracing features in <em>New</em> <em>Relic</em> <em>One</em>, including search and filter capabilities with cross-<em>account</em> trace details, query options with the NerdGraph <em>API</em>, and histogram charts (which can help you quickly understand trace distribution for important values"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/build-apps/custom-visualizations-and-the-new-relic-one-sdk": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 669.21814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 520.6916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build your first custom <em>visualization</em>",
        "sections": "Build your first custom <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>One</em> <em>catalog</em> Add your visualization to a dashboard Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create a new visualization Use <em>nr1</em> to generate the boilerplate for a new visualization"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.45737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your custom <em>visualization</em> to a dashboard",
        "sections": "Add your custom <em>visualization</em> to a dashboard",
        "info": "Add your custom <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your Nerdpack, publish and <em>subscribe</em> to your visualization: bash Copy $ <em>nr1</em> nerdpack:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Customize your visualization with configuration options",
        "Course",
        "Tip",
        "Add a new configuration option",
        "Replace your SegmentedControl with the configurable property",
        "Summary"
      ],
      "title": "Customize your visualization with configuration options",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9028e58f383ea362d2c9d3a7ecd6404dbfeac87c",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/customize-visualizations-with-configuration/",
      "published_at": "2021-07-30T01:48:12Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization using configuration",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Custom visualizations and the New Relic One SDK, before starting this one. In the previous lesson, you built a custom visualization that shows queried data in one of two chart types: RadarChart Treemap You used a SegmentedControl to switch between the two chart types in the visualization UI. This implementation takes up space in the visualization, but it offers your users the choice to switch between two chart types even after you've created an instance of your chart. But what if you only need to be able to select an option once, when initializing the visualization? In this lesson you'll learn how to add a configuration option to your visualization which replaces the SegmentedControl. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Add a new configuration option Step 1 of 8 In your visualization's nr1.json file, add an enum configuration object for selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve If you're still serving your Nerdpack from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to nr1.json. Step 4 of 8 Go to https://one.newrelic.com/?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from the local server. Step 5 of 8 Open the Apps page: Step 6 of 8 Go to Custom Visualizations, which is favorited by default: Step 7 of 8 In Custom Visualizations, find and click your visualization: Step 8 of 8 Notice the new Select chart configuration option: Selecting a chart type doesn't effect your visualization. This is because you first need to introduce the selectedChart property to the visualization component. Then, you use selectedChart to determine the chart type to render. Replace your SegmentedControl with the configurable property Step 1 of 5 Open your visualization's index.js file. You'll be working here for the rest of the guide. Step 2 of 5 In render(), include selectedChart as a constant you get from destructuring props, and remove your component's state: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now that you're using selectedChart from the configuration options instead of component state, you can select a chart in the configuration panel and watch the visualization change. Unfortunately, there's a bug. The default chart option is Radar, but the initial render shows a Treemap. Step 3 of 5 Update your ternary expression to account for the case where there is no selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now, your data is rendered in a RadarChart if you haven't yet configured the option. Step 4 of 5 Remove SegmentedControl from render(): index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 Spinner, 18 } from 'nr1'; 19 20 const CHART_TYPES = { 21 'Radar': 'radar', 22 'Treemap': 'treemap' 23 } 24 25 export default class RadarOrTreemapVisualization extends React.Component { 26 // Custom props you wish to be configurable in the UI must also be defined in 27 // the nr1.json file for the visualization. See docs for more details. 28 static propTypes = { 29 /** 30 * A fill color to override the default fill color. This is an example of 31 * a custom chart configuration. 32 */ 33 fill: PropTypes.string, 34 35 /** 36 * A stroke color to override the default stroke color. This is an example of 37 * a custom chart configuration. 38 */ 39 stroke: PropTypes.string, 40 /** 41 * An array of objects consisting of a nrql `query` and `accountId`. 42 * This should be a standard prop for any NRQL based visualizations. 43 */ 44 nrqlQueries: PropTypes.arrayOf( 45 PropTypes.shape({ 46 accountId: PropTypes.number, 47 query: PropTypes.string, 48 }) 49 ), 50 }; 51 52 /** 53 * Restructure the data for a non-time-series, facet-based NRQL query into a 54 * form accepted by the Recharts library's RadarChart. 55 * (https://recharts.org/api/RadarChart). 56 */ 57 transformData = (rawData) => { 58 return rawData.map((entry) => ({ 59 name: entry.metadata.name, 60 // Only grabbing the first data value because this is not time-series data. 61 value: entry.data[0].y, 62 })); 63 }; 64 65 /** 66 * Format the given axis tick's numeric value into a string for display. 67 */ 68 formatTick = (value) => { 69 return value.toLocaleString(); 70 }; 71 72 render() { 73 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 74 75 const nrqlQueryPropsAvailable = 76 nrqlQueries && 77 nrqlQueries[0] && 78 nrqlQueries[0].accountId && 79 nrqlQueries[0].query; 80 81 if (!nrqlQueryPropsAvailable) { 82 return <EmptyState />; 83 } 84 85 return ( 86 <AutoSizer> 87 {({width, height}) => ( 88 <NrqlQuery 89 query={nrqlQueries[0].query} 90 accountId={parseInt(nrqlQueries[0].accountId)} 91 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 92 > 93 {({data, loading, error}) => { 94 if (loading) { 95 return <Spinner />; 96 } 97 98 if (error) { 99 return <ErrorState />; 100 } 101 102 const transformedData = this.transformData(data); 103 104 return ( 105 <React.Fragment> 106 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 107 <RadarChart 108 width={width} 109 height={height} 110 data={transformedData} 111 > 112 <PolarGrid /> 113 <PolarAngleAxis dataKey=\"name\" /> 114 <PolarRadiusAxis tickFormatter={this.formatTick} /> 115 <Radar 116 dataKey=\"value\" 117 stroke={stroke || '#51C9B7'} 118 fill={fill || '#51C9B7'} 119 fillOpacity={0.6} 120 /> 121 </RadarChart> 122 ) : ( 123 <Treemap 124 width={width} 125 height={height} 126 data={transformedData} 127 dataKey=\"value\" 128 ratio={4 / 3} 129 stroke={stroke || '#000000'} 130 fill={fill || '#51C9B7'} 131 /> 132 )} 133 </React.Fragment> 134 ); 135 }} 136 </NrqlQuery> 137 )} 138 </AutoSizer> 139 ); 140 } 141 } 142 143 const EmptyState = () => ( 144 <Card className=\"EmptyState\"> 145 <CardBody className=\"EmptyState-cardBody\"> 146 <HeadingText 147 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 148 type={HeadingText.TYPE.HEADING_3} 149 > 150 Please provide at least one NRQL query & account ID pair 151 </HeadingText> 152 <HeadingText 153 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 154 type={HeadingText.TYPE.HEADING_4} 155 > 156 An example NRQL query you can try is: 157 </HeadingText> 158 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 159 </CardBody> 160 </Card> 161 ); 162 163 const ErrorState = () => ( 164 <Card className=\"ErrorState\"> 165 <CardBody className=\"ErrorState-cardBody\"> 166 <HeadingText 167 className=\"ErrorState-headingText\" 168 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 169 type={HeadingText.TYPE.HEADING_3} 170 > 171 Oops! Something went wrong. 172 </HeadingText> 173 </CardBody> 174 </Card> 175 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 5 of 5 Serve your Nerdpack locally, and view it in the Custom Visualizations app in New Relic. Select a chart type from the dropdown in the configuration sidebar, and see your visualization update to show the matching chart type: Summary Congratulations on completing this lesson! You've learned how to customize your visualization using nr1.json configuration. Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Add custom visualizations to your dashboards.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.12936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with configuration options",
        "sections": "Customize your <em>visualization</em> with configuration options",
        "info": "Customize your <em>visualization</em> using configuration",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": "&quot;: &quot;Stroke color&quot;, 51 &quot;description&quot;: &quot;A stroke color to override the default stroke color&quot;, 52 &quot;type&quot;: &quot;string&quot; 53 } 54 ] 55 } <em>visualizations</em>&#x2F;radar-or-treemap&#x2F;<em>nr1</em>.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ <em>nr1</em>"
      },
      "id": "6091fa3ae7b9d2df595068c1"
    },
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.39996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "info": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " serving it locally! Tip If you don&#x27;t see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application"
      },
      "id": "6091fb4464441f42962f3737"
    }
  ],
  "/build-apps/customize-visualizations-with-configuration": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 606.11865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 414.1713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your custom <em>visualization</em> to a dashboard",
        "sections": "Add your custom <em>visualization</em> to a dashboard",
        "info": "Add your custom <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ <em>nr1</em> nerdpack:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 413.19638,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build your first custom <em>visualization</em>",
        "sections": "Build your first custom <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>One</em> <em>catalog</em> Add your visualization to a dashboard Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create a new visualization Use <em>nr1</em> to generate the boilerplate for a new visualization"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-07-30T01:48:13Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.5924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with SDK components",
        "sections": "Customize your <em>visualization</em> with SDK components",
        "info": "Customize your <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create your visualization Step <em>1</em> of 2 Ensure you&#x27;re working with the latest version of the New Relic <em>One</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.25946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Most of the time, the <em>nr1</em> <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, Nerdlets, launchers, and <em>visualizations</em> without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    }
  ],
  "/build-apps/ab-test/third-party-service": [
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 723.17566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> PlatformStateContext to your Nerdlet",
        "sections": "<em>Add</em> PlatformStateContext to your Nerdlet",
        "info": "<em>Add</em> PlatformStateContext to your Nerdlet",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Fetch</em> <em>data</em> <em>from</em> a <em>third</em>"
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-07-30T01:50:30Z",
      "title": "Access NerdStorageVault from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "d35788d1b5e58689f48c12aa4cbdc2f446550102",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorageVault from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.5482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Access</em> NerdStorageVault <em>from</em> your Nerdlet",
        "sections": "<em>Access</em> NerdStorageVault <em>from</em> your Nerdlet",
        "info": "<em>Access</em> NerdStorageVault <em>from</em> your Nerdlet",
        "body": " is to show you how your software is helping you meet your business objectives. Sometimes, New Relic <em>data</em> is all you need to make that happen, but other times you need to look beyond New Relic for <em>data</em> to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Fetch</em> <em>data</em> <em>from</em> a <em>third</em>-<em>party</em> <em>service</em>."
      },
      "id": "6091faf264441f1cbe2f36e1"
    },
    {
      "sections": [
        "Introduction to on-host integrations",
        "Get started",
        "Features",
        "Monitor remote and multi-tenant configurations"
      ],
      "title": "Introduction to on-host integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "Get started"
      ],
      "external_id": "0e84cd158def0d2b748d2a54a0716f9820691f0d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/get-started/introduction-host-integrations/",
      "published_at": "2021-07-27T16:14:38Z",
      "updated_at": "2021-07-27T16:14:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure integrations allow you to send data from popular products and services to New Relic. You can select from our list of available on-host integrations to collect and send data to our platform. Get started To get started with on-host integrations: Browse the lists of on-host integrations. If you do not already have New Relic infrastructure monitoring enabled, install the infrastructure agent. Follow the procedures to install and configure the selected on-host integration, including prerequisites for compatibility and other requirements. If we don't currently offer an integration for a service you use, consider creating your own integration with Flex. Features After you install and activate an integration, you will be able to: Filter and analyze the metrics and configuration data in Infrastructure UI. Create custom queries and charts of your integration data. Create alert conditions to monitor problems with your services' performance in New Relic's alerts. Monitor remote and multi-tenant configurations Some configurations may use third party elements, such as databases, which reside in non-accessible, remote hosts. Our integrations can fetch data from local and remote hosts or servers, ensuring a continuous monitoring of your service. They also support multi-tenant clustered configurations—by abstracting the service from the host, multiple entities can be monitored as remote instances. You can activate remote monitoring and multi-tenancy in the Apache, Cassandra, MySQL, NGINX, and Redis integrations with the remote_monitoring parameter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.9436,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Monitor remote <em>and</em> multi-tenant configurations",
        "body": " alert conditions to monitor problems with your services&#x27; performance in New Relic&#x27;s alerts. Monitor remote and multi-tenant configurations Some configurations may use <em>third</em> <em>party</em> elements, such as databases, which reside in non-accessible, remote hosts. Our integrations can <em>fetch</em> <em>data</em> <em>from</em> local"
      },
      "id": "6044e41ce7b9d2ad305799ef"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-07-27T14:48:53Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.66494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "sections": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "body": "NerdGraph allows you to access your New Relic <em>data</em>, but when you want to <em>fetch</em> <em>third</em>-<em>party</em> <em>data</em>, NerdStorageVault allows you to safely store a secret to authenticate with a <em>third</em>-<em>party</em> <em>service</em>. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "sections": [
        "Install New Relic",
        "Install APM",
        "Install browser monitoring",
        "Install infrastructure monitoring",
        "Install mobile monitoring",
        "Install synthetic monitors",
        "Troubleshooting"
      ],
      "title": "Install New Relic ",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "069bcbf7a447dbab6466939200375e5cc3b8c394",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/install-configure/install-new-relic/",
      "published_at": "2021-07-28T03:28:32Z",
      "updated_at": "2021-07-28T03:28:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for third party telemetry services Data ingest APIs (metrics, events, logs, traces) To search these and other monitoring solutions, see New Relic integrations. Install APM C Go Java .NET For Windows .NET applications on IIS, use our guided install to get started with APM. If you're on an EU server, use this link instead. Node.js PHP Python Ruby Install browser monitoring See browser monitoring install. Install infrastructure monitoring Linux Use our guided install to install the infrastructure agent on Linux. Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) Cloud integrations: AWS, Azure, Google Cloud Platform Install mobile monitoring Android iOS React Install synthetic monitors Synthetic monitoring doesn't require installation, except for its private minions feature. Troubleshooting If you don't see data in the New Relic UI after installing the agent and waiting a few minutes, see Not seeing data for help troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.6685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install <em>APM</em>",
        "tags": "Install <em>and</em> configure",
        "body": "This document contains links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for <em>third</em> <em>party</em> telemetry services <em>Data</em> ingest APIs (metrics, events, logs, traces) To search these and other monitoring solutions, see New"
      },
      "id": "603eb6f328ccbcb565eba752"
    }
  ],
  "/build-apps/ab-test/chart-headings": [
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add a grid",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "fab1a23ddf5003cd0fb8189b903f3707a97d66e5",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a grid",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 513.1699,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a grid",
        "sections": "<em>Add</em> a grid",
        "info": "<em>Add</em> a grid",
        "body": " steps, you significantly improved the readability and usability of your A&#x2F;B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll <em>add</em> <em>headings</em> to your charts to remind yourself of what data each <em>chart</em> presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>chart</em> <em>headings</em>."
      },
      "id": "6091faf228ccbcbfe2a268f2"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add version descriptions",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "13644740111a7835d4738836f19589a74c711e26",
      "document_type": "page",
      "popularity": 1,
      "info": "Add version descriptions",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 503.87738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> version descriptions",
        "sections": "<em>Add</em> version descriptions",
        "info": "<em>Add</em> version descriptions",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>chart</em> <em>headings</em>, before"
      },
      "id": "6091fb44196a6744a7d52a81"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.60979,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> new content to your dashboard",
        "body": ". Create new content by clicking the <em>Add</em> widget button. <em>Add</em> a new <em>chart</em> using the query builder, or <em>add</em> text, images, or links using our markdown editor. Resize and rearrange charts. You can move any <em>chart</em> and put it anywhere in the dashboard so the layout you set fits your preferences: place your more"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-guidelines/levels-headings/",
      "sections": [
        "Levels of headings",
        "Use parallel construction",
        "Keep it short, avoid -ing words",
        "Do not use h1 headings",
        "Use level two headings to identify chunks of information",
        "Important",
        "Avoid using level three headings"
      ],
      "published_at": "2021-07-27T06:06:36Z",
      "title": "Levels of headings",
      "updated_at": "2021-05-21T14:31:50Z",
      "type": "docs",
      "external_id": "981282f676b2697e24f69ad23bce7e3412bb1d22",
      "document_type": "page",
      "popularity": 1,
      "body": "Taking some time to consider your headings and document titles will be time well spent. Titles and headings are not only important for search results, but they can make your docs easier to skim. For all headings and document titles, use sentence case. Use parallel construction Use parallel construction when naming headers. For example, use all nouns (\"Organization,\" \"Tone\"), all verbs (\"Create,\" \"Delete\"), etc. Keep it short, avoid -ing words For all headers, keep the title as short as possible. In particular, avoid headers that are more than a line long. As with all our writing, you should feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which add to character count without contributing clarity. Do not use h1 headings After you publish your doc, the Docs site will automatically use what you added to the Title field as the doc's level one heading (h1). To ensure that your doc is properly indexed for search, do not manually create additional h1 headings. If your doc's title is long and you would like a shorter title to appear in the sidebar menu, create a GitHub issue and we'll help you with that change. Use level two headings to identify chunks of information Organize chunks of information into sections with level two headings (##). For example: ## Create a new user [#create-new-user] Copy Important If you don't specify an ID manually, the site will use your header text as that header's ID (also known as anchor link). Create a manual ID to preserve links to that header if you change the header text. If you have too many level sections, consider splitting the document into multiple pages. Avoid using level three headings Avoid using ### headings unless it makes sense for the content or if the content is lengthy. Collapsers, tables, and other structural elements are often a better choice. Be particularly careful about level three headings that make a level two section longer than a single screen height. Here are two examples of good scenarios for using level three headings: Example #1: Events-to-metrics API doc Example #2: Infrastructure integration doc",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.33317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Levels of <em>headings</em>",
        "sections": "Levels of <em>headings</em>",
        "body": " feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which <em>add</em> to character count without contributing clarity. Do not use h1 <em>headings</em> After you publish your doc, the Docs site will automatically use what you added"
      },
      "id": "604221d3196a677e3aa83db4"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add user interface components to your application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "ed894ca79a689bdfbf6cff8d64273d4921872e41",
      "document_type": "page",
      "popularity": 1,
      "info": "Add user interface components to your application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.21189,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> user interface components to your application",
        "sections": "<em>Add</em> user interface components to your application",
        "info": "<em>Add</em> user interface components to your application",
        "body": " functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> <em>headings</em> to clarify what each <em>chart</em> represents. Third, you&#x27;ll <em>add</em> descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section"
      },
      "id": "6091fb4464441f44672f36fa"
    }
  ],
  "/build-apps/ab-test/persist-version": [
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-07-30T01:50:29Z",
      "title": "Add a section to end your test",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "b6a72d3fa08cce5a0edcacd34e8fa438dcfeaede",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a section to end your test",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 630.9169,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " value in the component doesn&#x27;t change. You must control the value that <em>Select</em> displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to <em>persist</em> your <em>version</em> choice in the <em>Select</em> component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Persist</em> the <em>selected</em> <em>version</em>."
      },
      "id": "6091faf228ccbcbf1fa268ea"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-07-30T01:51:41Z",
      "title": "Present an end test confirmation modal",
      "updated_at": "2021-05-05T01:54:59Z",
      "type": "developer",
      "external_id": "d304e6d4f2b5f3ca8465df20913b58f4360652d7",
      "document_type": "page",
      "popularity": 1,
      "info": "Present an end test confirmation modal",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. The modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.39368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>the</em> <em>version</em> you <em>selected</em> in your modal",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Persist</em> the <em>selected</em> <em>version</em>"
      },
      "id": "6091faf428ccbcbe03a268f3"
    },
    {
      "sections": [
        "Handled exceptions: Analyze trends, prevent crashes",
        "Handled exceptions workflow",
        "Exception percentage charts",
        "Exception percentage charts example",
        "Groups and filters",
        "Groups and filters example",
        "Top five exception locations",
        "Top five exception locations example",
        "Query builder links",
        "Exception locations table",
        "Exception locations table example"
      ],
      "title": "Handled exceptions: Analyze trends, prevent crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "d325744648613b771d7dd39de3f1448fe8a54ab9",
      "image": "https://docs.newrelic.com/static/5891a9437b94b543d81ee04a70ebe876/8c557/mobile-handled-exceptions-ui.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/handled-exceptions-analyze-trends-prevent-crashes/",
      "published_at": "2021-07-27T16:12:26Z",
      "updated_at": "2021-07-21T21:33:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Handled exceptions help you identify significant factors contributing to poor mobile application experience, and use filterable data to find a resolution more quickly. You can also use the handled exceptions API to customize the data you send, and use NRQL to query and share the data. Handled exceptions workflow To get the most out of the Handled exceptions UI, use this basic workflow: Go to one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions. Use any of New Relic's standard page functions to drill down into detailed information; for example, zoom into any area of a chart. Look for obvious or general trends in the Users affected and Sessions affected percentage charts. Adjust the types of exceptions shown by using groups and filters. Optional: Query or share the chart data. Look for similar patterns where exceptions appear in stack traces with the Top 5 exception locations table. To view stack trace thread details for each occurrence of the exception, select a record from the Top 5 exceptions location table. one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: As you explore the wealth of data in the charts and table, use groups and filters to discover patterns that help you determine the root cause of mobile app exceptions. Exception percentage charts Start with the Users affected and Sessions affected percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with exceptions in general. (If the Users affected chart is empty, there were no user sessions during the selected time period.) For example: Are there any spikes near a recent version release? Is there a time period when the percentage of users has been affected significantly by the exception? Are there uneventful periods? To examine data in greater detail: Below any chart, select Expand chart. Exception percentage charts example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: The percentage charts help you quickly see any unexpected spikes, dips, or patterns with exceptions in general. Groups and filters Use the groups and filters to examine attributes for crashes, devices, locations, or other custom attributes in more detail. You can select a group, then filter to specific data. For example: Group the list by exception location (default), cause, app build or version, devices, connections, or other custom attributes. This lets you discover patterns in your exceptions to determine the root cause. Use the time picker to adjust the currently selected time period. Filter by a specific Version or by one or more attribute Filter, such as appVersion, exceptionLocationMethod, lastInteraction, or any of the longer list of standard and custom attributes. The currently selected filters appear at the top of the UI page. You can close them, add other filters, or select other groups and filters. Groups and filters example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: Group the data by attributes that matter to the most to you, then select one or more filters to help pinpoint specific causes behind the exceptions. Top five exception locations Use the Top 5 exception locations table to find or sort patterns in the type of exception you selected from the groups and filters. This includes: Recurring locations in the stack trace Mobile app version Number of occurrences Number of users affected during the selected time period For example, you can group by Exception Message, filter to timeout message, then select individual timeout locations from the table to review the stack trace thread and details about each occurrence. To filter or group by other attributes, use the table's search window, or select any of the available filters. For example, filter by type of occurrence, device, a specific location, or any custom attributes. To look for other historical patterns, change the selected time period. Top five exception locations example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: This example shows the Expand chart button and links to the query builder, where you can query, create dashboards, and share the handled exceptions data. Query builder links Handled exceptions charts use default attributes for mobile events (including MobileHandledException), along with any custom attributes you have added to this event type. When you mouse over the charts, direct links appear below them. These links to the query builder allow you to analyze your mobile app data even deeper. View query link: View the NRQL query used to calculate the chart data. View in query builder link: View the chart, and share it with others. Exception locations table The Exception locations table supplements the charts. It lists where the top five handled exceptions appear in their stack trace thread, and links them to relevant details. Each row helps you find answers to questions such as: How many of this exception occurred within the selected time period? Does a specific app version have a higher (or lower) number of users affected? Which exception has the fewest number of occurrences? You can change the sort order or filter options to focus on just the types of exceptions that matter the most to you and your teams. To view additional thread details for each occurrence of the exception, select a record from the Top 5 exceptions location table. Exception locations table example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: To continue to the handled exception's Occurrences page, select any row on the table.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.36394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " from the groups and filters. This includes: Recurring locations in the stack trace Mobile app <em>version</em> Number of occurrences Number of users affected during the <em>selected</em> time period For example, you can group by Exception Message, filter to timeout message, then <em>select</em> individual timeout locations"
      },
      "id": "604505ae28ccbc783e2c6085"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-07-27T21:12:16Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.04296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>the</em> data explorer",
        "sections": "Introduction to <em>the</em> data explorer",
        "body": " of the <em>selected</em> event. By default attributes are sorted by Name. <em>Select</em> the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously <em>selected</em>. Dimensions are string values that provide information"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Versions analysis",
        "Versions analysis details",
        "Viewing drill-down details",
        "How version numbers are obtained",
        "Android",
        "iOS"
      ],
      "title": "Versions analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Usage pages"
      ],
      "external_id": "3906aba3231864c2adb43694636f085ae5332d0e",
      "image": "https://docs.newrelic.com/static/f359bb98f6fbf2a5c90dd604778a5dcd/c1b63/screen-versions_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/versions-analysis/",
      "published_at": "2021-07-27T13:07:51Z",
      "updated_at": "2021-07-09T12:29:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring includes a comparative analysis of adoption and performance between versions of your application, including top versions by: Interaction time Active sessions Error rate The Versions page also includes a table comparing each version by date created, average memory, average CPU, average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific version. Versions analysis details one.newrelic.com > Mobile > (select an app) > Usage > Versions: The Versions analysis includes color-coded charts of mobile app usage, plus a table that summarizes mobile app versions and their averages for memory, CPU, active users, and network RPM (requests per minute). The Versions page provides a list of all versions of your app that have been detected, plus overview information on all versions active in the last seven days. To view the comparative analysis: Go to one.newrelic.com > Mobile > (select an app) > Usage > Versions. To select the time period, use the time picker below the New Relic menu bar. Optional: Select the Sort by options. To view details only for a specific version, select its name. The Versions page provides a list of all versions of your app that have been active in the selected time window. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details one.newrelic.com > Mobile > (select an app) > Usage > Versions > (selected version): Here is an example of details for a selected version. The details page provides further insight into how the selected version compares to a reference version (a recent or popular version), and the average of other versions of your app. Time series show the comparison across error rate, response time, active sessions, and memory usage. To exit the details page, select the Close (X) button. How version numbers are obtained The way that mobile monitoring obtains the version number varies by platform: Android The Android agent obtains the version information from the android:versionName property in the manifest. iOS The iOS agent uses both CFBundleShortVersionString and CFBundleVersion properties to obtain the app version. The agent accesses those properties through iOS APIs. It does not obtain them by reading the info.plist file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.82158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Versions</em> analysis",
        "sections": "<em>Versions</em> analysis",
        "body": ", average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific <em>version</em>. Versions analysis details one.newrelic.com &gt; Mobile &gt; (<em>select</em> an app) &gt; Usage &gt; Versions: The Versions analysis includes color-coded charts"
      },
      "id": "603eaeeae7b9d262be2a080c"
    }
  ],
  "/build-apps/ab-test/nerdstoragevault": [
    {
      "image": "https://developer.newrelic.com/static/d2303a01613c5e0506712d9e593ec1db/ba3ac/nerdsletter-success.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/",
      "sections": [
        "Fetch data from a third-party service",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Fetch data from a third-party service",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92ddade6115ab659f26d62248a75ff9ec3ed7203",
      "document_type": "page",
      "popularity": 1,
      "info": "Fetch data from a third-party service",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1069.8992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Fetch data <em>from</em> a third-party service",
        "sections": "Fetch data <em>from</em> a third-party service",
        "info": "Fetch data <em>from</em> a third-party service",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorageVault</em> <em>from</em>"
      },
      "id": "6091fb4464441f43272f3724"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-07-30T01:50:30Z",
      "title": "Access NerdStorage from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "8c49cf33a6d954510f5c4b309a8a4d2f848fd68c",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorage from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 436.21243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": "&#x27;s own data store. While <em>NerdStorage</em> is a great place for many categories of data, it&#x27;s not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you&#x27;d use <em>NerdStorageVault</em>. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091faf1196a67250bd52a2b"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-07-27T14:48:53Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 366.15775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "<em>Nerd</em>Graph allows you to <em>access</em> <em>your</em> New Relic data, but when you want to fetch third-party data, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and encrypted <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2021-07-30T01:49:24Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 363.0342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorageVault</em>",
        "sections": "Using <em>NerdStorageVault</em> in <em>your</em> apps",
        "info": "Intro to <em>NerdStorageVault</em> on New Relic One",
        "tags": "<em>nerdstoragevault</em>",
        "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use <em>NerdStorageVault</em> to store data in an encrypted <em>storage</em> solution. Using <em>NerdStorageVault</em> in <em>your</em> apps <em>NerdStorageVault</em> is used to store and retrieve sensitive secrets data"
      },
      "id": "6091fa9828ccbc86bda268a9"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/",
      "sections": [
        "What's new in New RelicRSS"
      ],
      "published_at": "2021-07-30T01:44:22Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-07-24T01:46:54Z",
      "type": "docs",
      "external_id": "49467ca3d09d7a4f1c1c69fd16be4e20050a7686",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "July 15 Upgrade your Kubernetes monitoring with Pixie Get instant, code-level visibility without code changes or redeploying July 13 Recommended Alert Conditions Quickly and easily expand your alert coverage July 8 Real Time Profiling for Java enabled by default with Java Agent v7.1 Low-overhead, continuous profiling of your Java code in production environments July 7 HIPAA-enabled Observability Platform The first to support metrics, events, logs, and traces July 1 Monitor Amazon EKS on AWS Fargate integration with our public beta Receive telemetry from Kube State Metrics, Kubelet, and cAdvisor for full observability for Kubernetes clusters running on EKS in Fargate. June 30 Control data ingest costs with ingest drill-down Analyze the data that you send to New Relic June 23 Errors Inbox: Error tracking across your entire stack Track and triage your errors from a single screen May 28 NRQL Alert Conditions, with no NRQL required Now create alert conditions directly from the Query Builder May 27 Diagnose Issues Faster with AIOps Issue Maps and More! Introducing Issue Maps, Incident Analysis, and Relevant Dashboards New observability specialist certification for developers! Get certified in programmability with this certification course May 26 Instant Kubernetes observability with Pixie Without updating code or sampling data May 25 Dynamic Baselines for all your services and infrastructure Easily apply intelligent alerting to all of your services May 21 Keep track of What's New, security bulletins, and more with RSS! Get What's New posts, security bulletins, agent release notes, and Nerdlog and Nerd Bytes videos with RSS. May 14 Nerdlog Roundup - April Check out our monthly recap of some of the new products and features we released in April May 12 Level up at FutureStack May 25-27! Attend the observability event of the year! May 7 Attend FutureStack May 25-27, the observability event of the year! Level up at the observability event of the year! May 4 Pixie is now open source!! Instantly troubleshoot your Kubernetes applications without code changes April 27 Lightning fast search response with data partitions for log data Control how you segment your log data April 23 PHP agent now supports PHP version 8.0!! Monitor your PHP(v8.0) application with New Relic One April 21 Create synthetic monitors without code Synthetic monitors have never been easier to build! April 16 Native support for OpenTelemetry (Early access available now!!) Ingest OpenTelemetry data without adding any New Relic software into your services April 14 Distributed tracing for Mobile Get visibility to the entire journey of requests, originating in your mobile app as they travel through distributed systems April 12 A simpler, more intuitive log analytics experience Check out the changes we've made to the UI to help you see details and debug faster! Create alert conditions from any chart Now you can create an alert condition from just about anywhere in New Relic! Detect patterns and outliers in log data Create queries, alerts, and dashboards using log patterns and outliers April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.94017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " for OpenTelemetry Check out our APM functionality for <em>your</em> OpenTelemetry data. October 13, 2020 Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em> Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save <em>your</em> table column, time range, etc"
      },
      "id": "60422917196a677e2fa83ddf"
    }
  ],
  "/build-apps/ab-test/version-descriptions": [
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add chart headings",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "01dece7fe0259e5d6ff3c32f2022c97034db7a5a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart headings",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 399.86057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> chart headings",
        "sections": "<em>Add</em> chart headings",
        "info": "<em>Add</em> chart headings",
        "body": " grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it&#x27;d be nice to <em>add</em> <em>descriptions</em> to help you remember what each <em>version</em> in your A&#x2F;B test represents. In the next lesson, you&#x27;ll <em>add</em> a description for each design <em>version</em>"
      },
      "id": "6091faf128ccbcdaa2a26895"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-07-30T01:50:29Z",
      "title": "Add a section to end your test",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "b6a72d3fa08cce5a0edcacd34e8fa438dcfeaede",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a section to end your test",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 387.07657,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a section to end your test",
        "sections": "<em>Add</em> a section to end your test",
        "info": "<em>Add</em> a section to end your test",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>version</em> <em>descriptions</em>"
      },
      "id": "6091faf228ccbcbf1fa268ea"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.20113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a local <em>version</em> of the &quot;Hello, World!&quot; application",
        "body": ": Step 3 of 5 In the catalog directory of your project, <em>add</em> screenshots or various types of metadata to describe your project. For details about what you can <em>add</em>, see <em>Add</em> catalog metadata and screenshots. Step 4 of 5 After you <em>add</em> the screenshots and <em>descriptions</em> you want, execute the following to save"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "ISpan",
        "Syntax",
        "Description",
        "AddCustomAttribute",
        "Parameters",
        "Returns",
        "Usage considerations",
        "Examples"
      ],
      "title": "ISpan",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "d2a095fb3000fc46c42ea24c1450b3a586c13e26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/net-agent-api/ispan/",
      "published_at": "2021-07-27T10:53:00Z",
      "updated_at": "2021-03-11T08:04:14Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax Public interface ISpan Copy Provides access to span-specific methods in the New Relic API. Description Provides access to span-specific methods in the New Relic .NET agent API. To obtain a reference to ISpan, use: The CurrentSpan property on IAgent (Recommended). The CurrentSpan property on ITransaction. This section contains descriptions and parameters of ISpan methods: Name Description AddCustomAttribute Add contextual information from your application to the current span in form of attributes. AddCustomAttribute Adds contextual information about your application to the current span in the form of attributes. This method requires .NET agent version and .NET agent API version 8.25 or higher. Syntax ISpan AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current span. Usage considerations For details about supported data types, see the Custom Attributes guide. Examples IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ISpan currentSpan = agent.CurrentSpan; currentSpan .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.96647,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Description</em>",
        "body": " on ITransaction. This section contains <em>descriptions</em> and parameters of ISpan methods: Name Description <em>Add</em>CustomAttribute <em>Add</em> contextual information from your application to the current span in form of attributes. <em>Add</em>CustomAttribute Adds contextual information about your application to the current span"
      },
      "id": "6044129664441f542c378ed3"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "21ef5578bcf38440be72fcc2053de733d6aa95f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/net-agent-install-resources/",
      "published_at": "2021-07-27T05:06:08Z",
      "updated_at": "2021-07-09T11:00:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (e.g. the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.442535,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "This document contains detailed <em>descriptions</em> of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft&#x27;s .NET"
      },
      "id": "60eefc2fe7b9d287e3fc109f"
    }
  ],
  "/build-apps/ab-test/nerdstorage": [
    {
      "image": "https://developer.newrelic.com/static/d2303a01613c5e0506712d9e593ec1db/ba3ac/nerdsletter-success.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/",
      "sections": [
        "Fetch data from a third-party service",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Fetch data from a third-party service",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92ddade6115ab659f26d62248a75ff9ec3ed7203",
      "document_type": "page",
      "popularity": 1,
      "info": "Fetch data from a third-party service",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 916.5347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Fetch data <em>from</em> a third-party service",
        "sections": "Fetch data <em>from</em> a third-party service",
        "info": "Fetch data <em>from</em> a third-party service",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorage</em>Vault <em>from</em>"
      },
      "id": "6091fb4464441f43272f3724"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 584.57794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add, query, and mutate data using <em>NerdStorage</em>",
        "body": " <em>from</em> <em>your</em> account and add it to a dropdown menu in an application Add, query, and mutate data using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents <em>from</em> one session to the next. Add a time picker to <em>your</em> app"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "https://developer.newrelic.com/static/39196df35b3f160bf0ac9eeab116b112/ba3ac/real-table-chart-data.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:50:30Z",
      "title": "Customize NRQL data",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "52491e06cfe78faf65a628e3a553720f3ce4d318",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize NRQL data",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 534.7531,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Merge NRQL <em>from</em> multiple sources",
        "body": ", <em>your</em> demo application doesn&#x27;t create custom New Relic events when a user unsubscribes <em>from</em> <em>your</em> newsletter or you end an A&#x2F;B test. In the next lesson, you&#x27;ll learn how to use <em>Nerd</em>Graph and <em>NerdStorage</em> to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091faf228ccbcbadfa268f9"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-07-30T01:50:30Z",
      "title": "Access NerdStorageVault from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "d35788d1b5e58689f48c12aa4cbdc2f446550102",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorageVault from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 416.89975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em>"
      },
      "id": "6091faf264441f1cbe2f36e1"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2021-07-30T01:45:27Z",
      "updated_at": "2021-05-21T01:41:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.76944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate data using <em>NerdStorage</em>",
        "sections": "Query data <em>from</em> <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document database <em>accessible</em> within New Relic One. It allows you to modify, save, and retrieve documents <em>from</em> one session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " the application’s .&#x2F;nerdlets&#x2F;use-<em>nerdstorage</em>-<em>nerdlet</em>&#x2F;index.js file in the text editor of <em>your</em> choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addTo<em>NerdStorage</em>, and you need to update it to add User<em>Storage</em>"
      },
      "id": "6091f9c8196a67648ed52a3c"
    }
  ],
  "/build-apps/ab-test/catalog": [
    {
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/",
      "sections": [
        "Publish your New Relic One application",
        "Course",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Publish your New Relic One application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "f17b8d1fc30a296e6c4f0b4ef06c28e36672b87b",
      "document_type": "page",
      "popularity": 1,
      "info": "Publish your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Describe your app for the catalog, before starting this one. In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the Nerdpack's root-level package.json file. Every time you modify code in your Nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 7 Change to the publish/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 7 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 7 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 7 Replace all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively. Step 6 of 7 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 7 of 7 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Subscribe to your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 757.58936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Publish <em>your</em> New Relic One <em>application</em>",
        "sections": "View <em>your</em> <em>application</em> in <em>the</em> <em>catalog</em>",
        "info": "Publish <em>your</em> New Relic One <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Describe</em> <em>your</em> <em>app</em>"
      },
      "id": "6091fb45e7b9d2820a5068b9"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 570.7376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add navigation to <em>your</em> Nerdlet",
        "sections": "Add navigation to <em>your</em> Nerdlet",
        "info": "Add navigation to <em>your</em> Nerdlet",
        "body": " and subscribe to <em>your</em> New Relic One application so that it can run on our platform instead of <em>your</em> own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Describe</em> <em>your</em> <em>app</em> for the <em>catalog</em>."
      },
      "id": "6091faf128ccbcb641a268f9"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.66885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a &quot;Hello, World!&quot; <em>application</em>",
        "sections": "Add details to <em>describe</em> <em>your</em> project",
        "info": "Build a &quot;Hello, World!&quot; <em>app</em> and publish it to New Relic One",
        "tags": "NR One <em>Catalog</em>",
        "body": ". When <em>your</em> new application opens, notice that it doesn&#x27;t display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to <em>describe</em> <em>your</em> project Now that <em>your</em> new application is in the New Relic One <em>catalog</em>, you can add details that help users"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Subscribe to a Nerdpack",
        "Tag your Nerdpack's release version"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-07-27T01:40:22Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Subscribe to a Nerdpack   Subscribe to a Nerdpack Tag your Nerdpack's release version   Tag your Nerdpack's release version",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.4125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to <em>your</em> Nerdpack",
        "sections": "Update <em>your</em> Nerdpack&#x27;s <em>catalog</em> information",
        "info": "Share and use <em>the</em> Nerdpacks you build",
        "body": "Whether <em>your</em> Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, <em>describe</em>, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to <em>your</em> nerdpack Update <em>your</em> Nerdpack&#x27;s <em>catalog</em>"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a&#x2F;an Nerdlet Nerdpack item inside <em>your</em> Nerdpack. launcher <em>catalog</em> visualization In the next lesson, you&#x27;ll learn how to serve <em>your</em> Nerdpack locally and see <em>your</em> <em>app</em> in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve <em>your</em> New Relic One application."
      },
      "id": "6091faf2196a672632d52a22"
    }
  ],
  "/build-apps/ab-test/chart-group": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add user interface components to your application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "ed894ca79a689bdfbf6cff8d64273d4921872e41",
      "document_type": "page",
      "popularity": 1,
      "info": "Add user interface components to your application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 772.0045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> user interface components to your <em>application</em>",
        "sections": "<em>Add</em> user interface components to your <em>application</em>",
        "info": "<em>Add</em> user interface components to your <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>chart</em> <em>group</em>, before"
      },
      "id": "6091fb4464441f44672f36fa"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add tables",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92a3d84ceeaa19bbf11078ee56dc0ce7baa85ae2",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tables",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 657.3061,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> tables",
        "sections": "<em>Add</em> tables",
        "info": "<em>Add</em> tables",
        "body": " looking at a code sample. This practice will reinforce what you&#x27;ve learned in this lesson. If you need help, review the <em>add</em>-a-<em>chart</em>-<em>group</em> directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each <em>chart</em> you’ll <em>add</em>"
      },
      "id": "6091fb4464441f40c02f3741"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-27T21:14:17Z",
      "updated_at": "2021-07-27T21:14:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also duplicate your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.2055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, <em>add</em>, <em>and</em> share dashboards <em>and</em> <em>charts</em>",
        "sections": "Import, export, <em>add</em>, <em>and</em> share dashboards <em>and</em> <em>charts</em>",
        "tags": "<em>Charts</em>",
        "body": " features. Also, in a given dashboard, to <em>add</em> content: Click the edit button at the top right corner, then create new content by clicking the <em>Add</em> widget button. <em>Add</em> a new <em>chart</em> using the query builder, or <em>add</em> text, images, or links using our markdown editor. Use the + <em>Add</em> to your dashboard button"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-07-30T01:54:32Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.67593,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>account</em>-id",
        "body": "&#x27; align=&quot;right&quot; iconSize={legend.iconSize} iconType={legend.iconType} &#x2F;&gt; &lt;&#x2F;RadialBar<em>Chart</em>&gt; ) } } index.js Copy collection A collection is a <em>group</em> of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection&#x27;s child items. When"
      },
      "id": "6091fa3a64441fa2172f3714"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.6882,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> new content to your dashboard",
        "tags": "Explore <em>and</em> query data",
        "body": ". Create new content by clicking the <em>Add</em> widget button. <em>Add</em> a new <em>chart</em> using the query builder, or <em>add</em> text, images, or links using our markdown editor. Resize and rearrange charts. You can move any <em>chart</em> and put it anywhere in the dashboard so the layout you set fits your preferences: place your more"
      },
      "id": "603ec235196a67206fa83dde"
    }
  ],
  "/build-apps/ab-test/pie-charts": [
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add tables",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92a3d84ceeaa19bbf11078ee56dc0ce7baa85ae2",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tables",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 454.2296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> tables",
        "sections": "<em>Add</em> tables",
        "info": "<em>Add</em> tables",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>pie</em> <em>charts</em>, before"
      },
      "id": "6091fb4464441f40c02f3741"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/",
      "sections": [
        "Add your first chart",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:41Z",
      "title": "Add your first chart",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "292725b4d7883e56c1178913f21337d18b92133c",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your first chart",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart components to your A/B test application, before starting this one. In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add pie charts.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.15164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> your first <em>chart</em>",
        "sections": "<em>Add</em> your first <em>chart</em>",
        "info": "<em>Add</em> your first <em>chart</em>",
        "body": " for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another <em>chart</em> type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>pie</em> <em>charts</em>."
      },
      "id": "6091faf164441f0f032f3727"
    },
    {
      "sections": [
        "Use your charts",
        "Change the appearance of your chart",
        "Customize your charts",
        "Tip",
        "Format date and time",
        "Customize the Y axis",
        "Enable or disable the legend",
        "Remove the other groups facet",
        "More chart-specific features",
        "Chart share and view options"
      ],
      "title": "Use  your charts ",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Use charts"
      ],
      "external_id": "947a92d0243924f412fedb47bcb95dc40ec953fb",
      "image": "https://docs.newrelic.com/static/9bd74f30a31df0cb0ab112a325296b92/59415/crop-cb-chart-menu-tooltip_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/use-your-charts/",
      "published_at": "2021-07-27T22:25:48Z",
      "updated_at": "2021-07-21T13:02:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Once you've created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using the data explorer to specify data, the query builder analyzes your data and applies a chart type that fits your data. For some queries, you'll have several options of chart types to choose from. To change chart type, use the Chart type menu to the right of the current chart. Each type in the list has a tooltip with information about using that type. Example of the chart type menu, showing a tooltip. Customize your charts While we try our best to optimize how we display your data, sometimes you may have other needs. To this end, you can customize charts to display information at your convenience. Tip Customizations are available depending on the chart type. Format date and time Tip For table and billboard charts. Customize the date and time format for tables and billboards: for each type of data, you can select if you want to leave it as it is, or modify the format as Numeric or Date. If data is a timestamp, you can choose how to represent the date and time: For numbers, select if you want us to auto-format them, or chose the number of decimals you want to see. Customize the Y axis Tip For line and area charts. On line charts and area charts you can adjust the Y axis to display the data within certain values by setting a minimum and maximum value for the axis. If no customization option is selected, dashboards automatically displays the full Y axis from 0 to the top value plus a margin. Enable or disable the legend Tip For line and area charts, and histograms. For line charts, area charts, and histograms, you can disable or enable the legend. Remove the other groups facet Tip For bar and pie charts, and tables. When faceting on bar charts, pie charts, or tables, and if the number of faceting on queries is larger than 2,000, the Other groups facet aggregates the rest of facets. With this customization you can select whether to see Other groups, or remove it. More chart-specific features For more chart type-specific features, see Chart types. Chart share and view options Most charts have various options, including a chart-embed option, getting a chart as an image, and adding a chart to a dashboard. To read about general chart options, see Basic UI features.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.58011,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use  your <em>charts</em> ",
        "sections": "Use your <em>charts</em>",
        "tags": "Use <em>charts</em>",
        "body": "Once you&#x27;ve created a <em>chart</em>, you can customize the appearance of it to best present the data. You can share a <em>chart</em> in different formats and <em>add</em> a <em>chart</em> to a new or existing dashboard. Change the appearance of your <em>chart</em> When you run your query in advanced (NRQL) mode or view your <em>chart</em> while using"
      },
      "id": "603ec29a196a67ef5da83d82"
    },
    {
      "image": "https://docs.newrelic.com/static/36ca4a14c623097dc63387c4023720ad/c1b63/chart_area.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/chart-types/",
      "sections": [
        "Chart types",
        "Area chart",
        "Bar chart",
        "Billboard",
        "Tip",
        "Bullet chart",
        "Funnel",
        "Heat map",
        "Histogram",
        "JSON",
        "Line",
        "Pie chart",
        "Pie chart percentage problem",
        "Table"
      ],
      "published_at": "2021-07-27T22:24:50Z",
      "title": "Chart types",
      "updated_at": "2021-07-21T10:57:59Z",
      "type": "docs",
      "external_id": "09f7d709ab07ae6010d85b21deb2e63a56c9bca6",
      "document_type": "page",
      "popularity": 1,
      "body": "When building a query using the query builder, there are a variety of types of visualizations for presenting your data in the optimal format. This table contains all chart types. Whether a chart type is available for your query will be dependent on: The type of query (some query results don't match some chart types) The query mode (basic or advanced) Area chart An area chart shows a time series for a single attribute. The area chart type shows a time series for a single attribute. To enable an area chart, add a FACET to your query. You can use facet to add up to five attributes, separated by commas. Use the TIMESERIES function when you use a FACET in an NRQL query. Use an area chart when you want to View the measurement of a single attribute over a period of time that you specify. Avoid an area chart when you want to View a chart that contains more than a single attribute. The line chart type is a good option; you can view multiple attributes over a time range that you specify. The bar chart type gives you a comparison view between the attributes; it uses a total of each attribute for the time range you choose. Bar chart The bar chart shows comparisons among the categories returned in the query results. The bar chart compares a related set of values. To enable a bar chart, add a FACET clause to the query. You can use FACET with up to 5 different attributes, separated by commas. Use a bar chart when you want to Create a chart that reports the total count of the data for a category over the specified time range. With the bar chart format, you can easily see the differences between each category. Avoid a bar chart when you want to Include measurements over a period of time. This chart type is not available when using a TIMESERIES clause. The line chart type is a good option for this visualization. Billboard The billboard chart type presents results as a single, highly-visible value. It's an option when your query returns a single number, such as from this query: SELECT uniqueCount(session) FROM PageView since 1 day ago Copy A billboard chart is useful for single-stat queries like the Apdex function. Use billboards to monitor values at a glance. Billboards can also be used to compare a single value across states. For instance, use the COMPARE WITH clause to compare the same attribute across two different time frames. The billboard chart displays a single value in a large, easy to read font. To enable the data for a billboard chart, search for a single value. You can view multiple values by adding a facet from the dropdown. You can set Warning and Critical thresholds on billboards, which will highlight a chart in yellow or red. The threshold fields are on the right side of the chart edit pane, highlighted in yellow and red respectively. If you want to highlight a chart when a value falls below a given value rather than above it, set the Warning threshold higher than the Critical threshold. Tip Threshold fields will only be available for dashboards that present a single value. For instance, the use of a COMPARE WITH clause will disable the threshold settings in the edit pane. Use a billboard chart when you want to Monitor values, including thresholds for Critical and Warning states, in a large, easy-to-read font. Avoid a billboard chart type when You want to view data over a period of time. The line chart type is a better option for viewing data by time. Bullet chart Use the bullet chart type to represent progress to a target or goal, called the limit. To use this chart type, run a query that returns a single number, such as: SELECT uniqueCount(session) FROM PageView SINCE 1 day ago Copy The bullet chart displays a value compared against a limit. Bullet defaults to a limit that is twice the resulting query value. To adjust the limit, use the Limit field to enter another number. The bullet will adjust accordingly. Tip The bullet chart type can only be used for charts that present a single value. For example, a query using COMPARE WITH will not list bullet as an option. Use a bullet chart when you want to View a chart uses a large, easy-to-read font that helps you view the value quickly. Avoid a bullet chart when you want to View data that has more than a single value. Bar and line chart types may be better choices in this instance. Funnel Use funnels to evaluate a series of related data types that make up the steps toward a specified goal. A funnel allows you to ask, “Of the people that did (A), how many also did (B), and of the people that did (A) and (B), how many also completed (C)?” Sample funnel chart for a shopping site. In this example, you want to determine that of all the visitors that viewed the landing page, how many of them: Browsed the products. Then added one or more products to a shopping cart. And finally, purchased the item(s) in the shopping cart. Unlike other queries, you must use a SELECT funnel() statement in your query; the funnel chart type is not selectable from any other type of query. Additionally, the funnel chart type is only available for queries with eight steps or fewer. A funnel query that includes more than eight steps will only return the results as JSON. SELECT funnel(session, WHERE pageUrl like '%/index.html' AS 'Landing', WHERE pageUrl LIKE '%/browse/phones' AS 'Browse ', WHERE pageUrl LIKE '%/shoppingcart' AS 'Cart', WHERE pageUrl LIKE '%/checkout' AS 'Purchased') FROM PageView where appName = 'WebPortal' AND duration < 1 SINCE 1 week ago Copy Use a funnel when you want to You want to visually evaluate the paths that visitors take after they hit a page that you designate as a landing page. Avoid a funnel when you want to You only want counts for the attributes in the WHERE clause. You will not be able to choose funnel unless you use SELECT funnel in your query. Heat map The heat map displays data in a tabular format using color gradations to show frequency in specific time buckets. The heat map is a faceted distribution of values where color density represents the values displayed. To enable a heat map, use the Histogram() function with a numeric attribute and use FACET to add up to five attributes, separated by commas. See Histograms: View data distribution for more detailed information about histogram-based charts. Use a heat map when you want to View tabular data for multiple attributes over a period of time, with gradated colors instead of numerals. Avoid a heat map when you want to View the exact data for multiple attributes over a period of time. A line or bar chart may be an option. Histogram A histogram charts frequency across a series of value ranges. Use histograms to show the distribution of data across time buckets. See Histograms: View data distribution for more detailed information about histogram-based charts. Use a histogram when you want to Chart frequency of data over a series of values. Avoid a histogram when you want to View the same data as heat map or to view the data without the time buckets. JSON Use the returned JSON to review the raw data returned and to help develop integrations with New Relic. To implement integrations, use remote queries to return raw JSON as a service. To use this, select the Share menu and click Copy JSON. Example NRQL query: SELECT uniqueCount(name) FROM Transaction WHERE httpResponseCode = '200' TIMESERIES FACET appName LIMIT 10 SINCE 24 hours ago Copy Example JSON response: { \"metadata\": { \"contents\": { \"messages\": [], \"timeSeries\": { \"messages\": [], \"contents\": [ { \"function\": \"uniquecount\", \"attribute\": \"name\", \"simple\": true } ] }, \"bucketSizeMillis\": 1800000 }, \"eventTypes\": [ \"Transaction\" ], \"eventType\": \"Transaction\", \"openEnded\": true, \"messages\": [], \"beginTimeMillis\": 1556226069396, \"endTimeMillis\": 1556312469396, \"beginTime\": \"2019-04-25T21:01:09Z\", \"endTime\": \"2019-04-26T21:01:09Z\", \"guid\": \"5238a2c6-328d-a5ff-9185-7f3f04c42d1e\", \"routerGuid\": \"1aea2ec5-0be8-3a60-7554-851e1b016eb0\", \"rawSince\": \"24 HOURS AGO\", \"rawUntil\": \"NOW\", \"rawCompareWith\": \"\", \"facet\": \"appName\", \"offset\": 0, \"limit\": 10 }, \"facets\": [ { \"name\": \"RPM Combined Production\", \"beginTimeSeconds\": 0, \"endTimeSeconds\": 0, \"timeSeries\": [ { \"results\": [ { \"uniqueCount\": 415 } ], \"beginTimeSeconds\": 1556226069, \"endTimeSeconds\": 1556227869, \"inspectedCount\": 4589471 }, [ { \"uniqueCount\": 1714 } ], \"beginTimeSeconds\": 1556310669, \"endTimeSeconds\": 1556312469, \"inspectedCount\": 53341469 } ], \"total\": { \"results\": [ { \"uniqueCount\": 2651 } ], \"beginTimeSeconds\": 0, \"endTimeSeconds\": 0, \"inspectedCount\": 5053841114 } }, \"performanceStats\": { \"inspectedCount\": 6088068932, \"responseTime\": 8077 } } ... Copy Line A line chart is useful for spotting trends over time. The line chart plots a timeseries for an attribute. When working in basic query mode, select a single attribute you can plot over time. When using NRQL, SELECT one or more attributes you can plot over time and then use the TIMESERIES function. Use a line chart when you want to Create a chart that lets you easily view trends over a specified time frame. Avoid a line chart when you want to View your data using one or more attributes and see the values associated with each attribute. A bar or table chart is an option. Pie chart A pie chart is the graphic representation of the table. It appears as an option for some functions when the FACET clause is used. To use this chart type, run a query that returns one value for each of a set of attributes. The pie chart maps a set of values as a portion of a whole. To enable pie chart, add a FACET from the dropdown. You can add only one FACET in basic query mode. If you're using NRQL, you can use FACET to add up to 5 attributes, separated by commas, and also include the TIMESERIES function. Pie charts are unavailable for the following aggregator functions: average, apdex, min, max, percentage, and percentile. For uniqueCount, percentages may add up to more than 100%. Use a pie chart when you want to Create a chart that that graphically presents a set of values as they relate to a whole. A pie chart is effective for displaying values for a time period, for example. Avoid a pie chart when you want to Present data that does not use values as they related to a whole, such as with line charts. Pie chart percentage problem When using a pie chart with the uniqueCount aggregator function, the percentages can add up to more than 100%. This is because the attributes being uniquely counted may be present in multiple facets. For example, in the query SELECT uniqueCount(user) FROM PageView FACET appName, a single unique user may use multiple apps. Each of these users are included in the unique value for each of the appropriate facets (apps), but the total number of unique users won't change. To solve this, use a bar chart or table to provide a more accurate visualization of uniqueCount data. Table A table is the standard view for a set of values related to a specific attribute (for example, the count of all page views by user agent name). By default, all tables are sortable by any one column. If you are using the FACET clause, the results will normally be returned as a table. Other features of tables: You can use a table as a shortcut to other dashboards. If a table is faceted by attribute, selecting an entry takes you to an existing dashboard filtered by that attribute. You can export a table chart to a CSV file. Details on this functionality: If a filter is applied to a dashboard, the download will only include the subset of data based on the filter. If a specific fixed time range is selected, the CSV includes the data for that time period. If you query with multiple attributes, the export includes columns for all FACETs in the query. For charts with a time range dependent on the present moment (for example, since 30 minutes ago), the data in the CSV is generated from the present moment, not from when the chart was initially generated. The table chart type, with its tabular format, works well for dashboards, as well as sharing the data for use in reports, for example. Use a table when you want to Create a text-compatible table consisting of your data. This table can be shared and used in reports or imported into spreadsheets, for example. Avoid a table when you want to View your data in a graphical format.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.04692,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Chart</em> types",
        "sections": "<em>Pie</em> <em>chart</em>",
        "body": " to a whole, such as with line <em>charts</em>. <em>Pie</em> <em>chart</em> percentage problem When using a <em>pie</em> <em>chart</em> with the uniqueCount aggregator function, the percentages can <em>add</em> up to more than 100%. This is because the attributes being uniquely counted may be present in multiple facets. For example, in the query SELECT"
      },
      "id": "6097bec5196a671044d52a6e"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-27T21:14:17Z",
      "updated_at": "2021-07-27T21:14:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also duplicate your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.40372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, <em>add</em>, and share dashboards and <em>charts</em>",
        "sections": "Import, export, <em>add</em>, and share dashboards and <em>charts</em>",
        "tags": "<em>Charts</em>",
        "body": " and share <em>charts</em> (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard&#x27;s permalink. Copy your dashboard as JSON and <em>add</em> it to the clipboard by clicking"
      },
      "id": "60e5877828ccbc77861881cc"
    }
  ],
  "/build-apps/ab-test/demo-setup": [
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 793.2831,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground <em>up</em>. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>"
      },
      "id": "6091faf1196a6714b4d52a39"
    },
    {
      "image": "https://developer.newrelic.com/static/1b7d6942b8c3c73de370700d4bcf1bbf/0086b/ab-test.png",
      "url": "https://developer.newrelic.com/ab-test/",
      "sections": [
        "Build an A/B test application",
        "Course"
      ],
      "published_at": "2021-07-30T01:44:16Z",
      "title": "Build an A/B test application",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "cd5dbe8eeef34d9b730fad359e6ffeed530ef310",
      "document_type": "page",
      "popularity": 1,
      "body": "Imagine you've developed a website and instrumented it with New Relic's Browser monitoring. New Relic's core feature set provides a lot of information, but you want something custom. You want to decide if a new design for your site will better engage your users. In other words, you want to A/B test a design and make a decision based on the data. For this task, you could create a New Relic One application, using React, the New Relic One software development kit, and the limitless power of modern web technologies. New Relic One applications are built with one of web development's most popular JavaScript libraries: React. Because you have freedom when writing React code, you can customize your app logic, design your own components, or take advantage of the abundance of open source component libraries. So, for your A/B test app, if you want to write custom logic to end the test based on results, you can do so. The New Relic One software development kit (SDK) allows you to create, serve, publish, and deploy applications to New Relic One. It also provides a host of React components for gathering data, presenting information, handling user interactions, and more. You use components like Button and Dropdown to create an interactive experience that looks and feels native to New Relic. You use Table and Chart components to display data from your New Relic account or elsewhere. When building your A/B test application, you'd use the SDK's NrqlQuery component to fetch Browser data from your account. With custom React code, SDK components, and the wide world of open source libraries, you can create your A/B test application in New Relic One. But before you create one for yourself, you might want to check the app catalog to see if someone has beaten you to it! If the catalog already had an app for that, you could add it to your account with a couple clicks, another benefit of creating apps in New Relic One. Throughout this course, you’re going to build a real-world New Relic One application for running and managing A/B tests. You’ll visualize Browser data for your competing designs, see historical data from past tests, and even choose a winning design and end the test, all from your New Relic One application! But before you get into the weeds of building charts and making http requests, you need to learn what New Relic One applications are made of. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the first lesson: Spin up your demo services.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 774.0394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is part of a course that teaches you how to build a New Relic One application from the ground <em>up</em>. Continue on to the first lesson: <em>Spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>."
      },
      "id": "6091faf1e7b9d24f885068c6"
    },
    {
      "sections": [
        "Docker container for infrastructure monitoring",
        "What you need",
        "Custom setup (recommended)",
        "Docker CLI",
        "Docker Compose",
        "Basic setup",
        "Required container privileges",
        "Next steps after install",
        "Inventory collected",
        "Container data",
        "Containerized agent image",
        "Check the source code"
      ],
      "title": "Docker container for infrastructure monitoring",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Install the infrastructure agent",
        "Linux installation"
      ],
      "external_id": "022f4fba474d662414d9542a107d4d8a30d24895",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/linux-installation/docker-container-infrastructure-monitoring/",
      "published_at": "2021-07-27T10:07:18Z",
      "updated_at": "2021-07-27T10:07:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The infrastructure monitoring agent for Linux supports Docker environments by default. If you're running a container OS or have restrictions that require deploying the agent as a container, you can run a containerized version of our infrastructure monitoring agent. This can monitor metrics for the container itself, as well as the underlying host. Using the custom (recommended) or basic setup allows the infrastructure agent to run inside a container environment. A host can only run one instance of the agent at a time, whether that's the containerized agent or the non-containerized version. What you need The containerized version of the infrastructure agent requires Docker 1.12 or higher. The container must run any of the Linux distributions and versions supported by our agent. The log forwarder is not included with the containerized agent. We recommend installing the agent on the underlying host which provides all capabilities. Custom setup (recommended) The following are basic instructions for creating a custom Docker image on Linux. This allows you to deploy the infrastructure agent as a container that can monitor its underlying host. Recommendation: Extend the newrelic/infrastructure image, and use your own newrelic-infra.yml agent config file. Once your image is built, you can easily spin up a container without having to provide more launch time configurations. Do not provide secrets using environment variables with Docker. Docker CLI Create the newrelic-infra.yml agent config file with your New Relic license key. For config option explanations, see configuration settings. license_key: YOUR_LICENSE_KEY Copy Create the Dockerfile extending the newrelic/infrastructure image, and add your config to /etc/newrelic-infra.yml: FROM newrelic/infrastructure:latest ADD newrelic-infra.yml /etc/newrelic-infra.yml Copy Build and tag your image: docker build -t YOUR_IMAGE_NAME . Copy Run the container from the image you built with the required required run flags: docker run \\ -d \\ --name newrelic-infra \\ --network=host \\ --cap-add=SYS_PTRACE \\ --privileged \\ --pid=host \\ -v \"/:/host:ro\" \\ -v \"/var/run/docker.sock:/var/run/docker.sock\" \\ YOUR_IMAGE_NAME Copy For potential next steps, like how to see data in the UI, see What's next? Docker Compose Create a folder to store the configuration files: mkdir ~/newrelic-infra-setup Copy Change directory to the one you've just created: cd ~/newrelic-infra-setup Copy Create the newrelic-infra.yml agent config file with your New Relic license key. For config option explanations, see configuration settings. echo \"license_key: YOUR_LICENSE_KEY\" > newrelic-infra.yml Copy Create the newrelic-infra.dockerfile extending the newrelic/infrastructure image, and add your config to /etc/newrelic-infra.yml: touch newrelic-infra.dockerfile Copy vim newrelic-infra.dockerfile #you can use any text editor Copy Put the following content in the file: FROM newrelic/infrastructure:latest ADD newrelic-infra.yml /etc/newrelic-infra.yml Copy Create docker-compose.yaml: touch docker-compose.yaml Copy vim docker-compose.yaml #you can use any text editor Copy Put following content in the file: version: '3' services: agent: container_name: newrelic-infra build: context: . dockerfile: newrelic-infra.dockerfile cap_add: - SYS_PTRACE network_mode: host pid: host privileged: true volumes: - \"/:/host:ro\" - \"/var/run/docker.sock:/var/run/docker.sock\" restart: unless-stopped Copy Build and start docker-compose: docker-compose -f docker-compose.yaml up -d Copy For potential next steps, like how to see data in the UI, see What's next? Basic setup To use the basic setup with a base New Relic infrastructure image: Docker CLI Run the container with the required run flags: docker run \\ -d \\ --name newrelic-infra \\ --network=host \\ --cap-add=SYS_PTRACE \\ --privileged \\ --pid=host \\ -v \"/:/host:ro\" \\ -v \"/var/run/docker.sock:/var/run/docker.sock\" \\ -e NRIA_LICENSE_KEY=YOUR_LICENSE_KEY \\ newrelic/infrastructure:latest Copy For potential next steps, like how to see data in the UI, see What's next? Docker Compose Create docker-compose.yaml: touch docker-compose.yaml Copy vim docker-compose.yaml #you can use any text editor Copy Put following content in the file: version: '3' services: agent: container_name: newrelic-infra image: newrelic/infrastructure:latest cap_add: - SYS_PTRACE network_mode: host pid: host privileged: true volumes: - \"/:/host:ro\" - \"/var/run/docker.sock:/var/run/docker.sock\" environment: NRIA_LICENSE_KEY: \"YOUR_LICENSE_KEY\" restart: unless-stopped Copy Build and start docker-compose: docker-compose -f docker-compose.yaml up -d Copy For potential next steps, like how to see data in the UI, see What's next? Required container privileges Due to resource isolation from the host and other containers via Linux namespaces, a container has a very restricted view and control of its underlying host's resources by default. Without these extra privileges, the infrastructure agent cannot monitor the host and its containers. The infrastructure agent collects data about its host using system files and system calls. For more information about how the infrastructure agent collects data, see our documentation about infrastructure monitoring and security. Required privileges include: Privilege Description --network=host Sets the container's network namespace to the host's network namespace. This allows the agent to collect the network metrics about the host. -v \"/:/host:ro\" Bind mounts the host's root volume to the container. This read-only access to the host's root allows the agent to collect process and storage metrics as well as Inventory data from the host. --cap-add=SYS_PTRACE Adds the Linux capability to trace system processes. This allows the agent to gather data about processes running on the host. Read more here. --privileged --pid=host -v \"/var/run/docker.sock:/var/run/docker.sock\" Bind mounts the host's Docker daemon socket to the container. This allows the agent to connect to the Engine API via the Docker daemon socket to collect the host's container data. Next steps after install For next steps after install is completed, see What's next? Inventory collected Inventory is collected from the infrastructure agent's built-in data collectors. The infrastructure agent collects this data for Linux systems running with containers. Category Source Data collected using metadata agent_config Agent's complete config file system uptime -s, /etc/redhat-release, /proc/cpuinfo, /etc/os-release, /proc/sys/kernel/random/boot_id, /proc/sys/kernel/osrelease, /sys/class/dmi/id/product_uuid, /sys/devices/virtual/dmi/id/sys_vendor, /sys/devices/virtual/dmi/id/product_name Container data Once the infrastructure agent is running in a Docker container, it can collect the same host compute data and event data that the infrastructure agent is capable of collecting when running natively on a host. For more information, see our documentation about how to view your Docker container data. Containerized agent image The containerized agent image is built from an Alpine base image. A CentOS base image is also available. Alpine is used as the base image since version 0.0.55. This is the one pointed by latest tag. Earlier versions used CentOS 7 as base image. In order to keep using that legacy image, some backports may be included there. To fetch the latest CentOS 7 based image, point to the latest-centos tag. Check the source code This integration is open source software. You can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.914856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&#x2F;infrastructure image, and use <em>your</em> own newrelic-infra.yml agent config file. Once <em>your</em> image is built, you can easily <em>spin</em> <em>up</em> a container without having to provide more launch time configurations. Do not provide secrets using environment variables with Docker. Docker CLI Create the newrelic-infra.yml agent"
      },
      "id": "6043ef6a28ccbce71b2c6062"
    },
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-07-30T01:44:16Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.208504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>your</em> <em>services</em>",
        "info": "Automatically <em>spin</em> <em>up</em> a microservice infrastructure, and use New Relic to diagnose its issues.",
        "tags": "<em>demo</em>",
        "body": " to investigate simulated issues in Telco Lite <em>services</em> Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in <em>your</em> <em>services</em>. To get <em>your</em> hands on more features of New Relic, pick another <em>demo</em> from the catalog and <em>spin</em> it <em>up</em> with the deployer!"
      },
      "id": "6091fa98e7b9d215455068c4"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-07-30T01:54:32Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.20469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure <em>your</em> custom visualization",
        "sections": "Configure <em>your</em> custom visualization",
        "info": "Configure <em>your</em> custom visualization",
        "body": ", but unlike index.js <em>your</em> locally served visualization requires a restart to see its changes. So, if you&#x27;re serving <em>your</em> visualization locally, teardown <em>your</em> local server with CTRL+C and <em>spin</em> it <em>up</em> again: bash Copy $ nr1 nerdpack:serve If <em>your</em> visualization is already published, you need to update <em>your</em> Nerdpack&#x27;s version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe"
      },
      "id": "6091fa3a64441fa2172f3714"
    }
  ],
  "/build-apps/ab-test/platform-state-context": [
    {
      "image": "https://developer.newrelic.com/static/d2303a01613c5e0506712d9e593ec1db/ba3ac/nerdsletter-success.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/",
      "sections": [
        "Fetch data from a third-party service",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Fetch data from a third-party service",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92ddade6115ab659f26d62248a75ff9ec3ed7203",
      "document_type": "page",
      "popularity": 1,
      "info": "Fetch data from a third-party service",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 605.11487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on: <em>Platform</em> APIs. These will come in handy in improving the usability of <em>your</em> New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>PlatformStateContext</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091fb4464441f43272f3724"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 537.5459,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " to <em>your</em> <em>nerdlet</em>, before starting this one. In the last lesson, you used <em>PlatformStateContext</em> from the New Relic One SDK to look up the time range that the user selected from the app&#x27;s time picker. Now, you&#x27;ll learn about another component that interacts with the New Relic <em>platform</em>: navigation"
      },
      "id": "6091faf128ccbcb641a268f9"
    },
    {
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "title": "Add a time picker",
      "type": "developer",
      "tags": [
        "time picker",
        "app",
        "helper method",
        "platformstatecontext"
      ],
      "external_id": "2602edf3077388ba4fded3a76208e5e0ae1be98f",
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-06-25T01:40:38Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a time picker to a sample application",
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the platformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(platformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(platformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the platformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(platformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(platformState) => { /* Taking a peek at the platformState */ console.log(platformState); const since = timeRangeToNrql(platformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 324.45776,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a time picker",
        "sections": "<em>Add</em> the time <em>to</em> the queries",
        "info": "<em>Add</em> a time picker <em>to</em> a sample application",
        "tags": "<em>platformstatecontext</em>",
        "body": " Complete these steps: Step 1 of 5 In a text editor, open &#x2F;<em>add</em>-time-picker&#x2F;nerdlets&#x2F;nr1-howto-<em>add</em>-time-picker-<em>nerdlet</em>&#x2F;index.js. Step 2 of 5 <em>Add</em> the <em>PlatformStateContext</em> component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart"
      },
      "id": "6091f827196a672a2ed52a6f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/platform-state-context/",
      "sections": [
        "PlatformStateContext",
        "Usage",
        "Examples",
        "Props",
        "Methods",
        "PlatformStateContext.subscribe"
      ],
      "published_at": "2021-07-30T01:46:49Z",
      "title": "PlatformStateContext",
      "updated_at": "2021-06-25T01:42:52Z",
      "type": "developer",
      "external_id": "aa6b86b3dc0dcd7cd758b20655318b108875cce7",
      "document_type": "page",
      "popularity": 1,
      "body": "React context to access the platform URL state. Usage import { PlatformStateContext } from 'nr1' Copy Examples Props There are no props for this component. Methods PlatformStateContext.subscribe Methods to subscribe for context value updates. function ( subscriber : function // Function that will be called. )",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 258.13892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PlatformStateContext</em>",
        "sections": "<em>PlatformStateContext</em>",
        "body": "React <em>context</em> to access the <em>platform</em> URL <em>state</em>. Usage import { <em>PlatformStateContext</em> } from &#x27;nr1&#x27; Copy Examples Props There are no props for this component. Methods <em>PlatformStateContext</em>.subscribe Methods to subscribe for <em>context</em> value updates. function ( subscriber : function &#x2F;&#x2F; Function that will be called. )"
      },
      "id": "6091f8ce196a67b795d52a6d"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.42581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro <em>to</em> New Relic One SDK",
        "sections": "<em>Platform</em> APIs",
        "info": "Intro <em>to</em> New Relic One SDK",
        "tags": "<em>Platform</em> APIs",
        "body": ": <em>PlatformStateContext</em>: provides read access to the <em>platform</em> URL <em>state</em> variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new <em>Nerdlet</em>. <em>NerdletStateContext</em>: provides read access"
      },
      "id": "6091fa39196a67a4ead52a4b"
    }
  ],
  "/build-apps/ab-test/grid": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add user interface components to your application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "ed894ca79a689bdfbf6cff8d64273d4921872e41",
      "document_type": "page",
      "popularity": 1,
      "info": "Add user interface components to your application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 546.37164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> user interface components to your <em>application</em>",
        "sections": "<em>Add</em> user interface components to your <em>application</em>",
        "info": "<em>Add</em> user interface components to your <em>application</em>",
        "body": " functionality. First, you’ll use a <em>Grid</em> component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> headings to clarify what each chart represents. Third, you&#x27;ll <em>add</em> descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section"
      },
      "id": "6091fb4464441f44672f36fa"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add chart headings",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "01dece7fe0259e5d6ff3c32f2022c97034db7a5a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart headings",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 462.5475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> chart headings",
        "sections": "<em>Add</em> chart headings",
        "info": "<em>Add</em> chart headings",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>grid</em>, before starting"
      },
      "id": "6091faf128ccbcdaa2a26895"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2021-07-30T01:45:27Z",
      "updated_at": "2021-05-21T01:41:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.86722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em>, query, <em>and</em> mutate data using NerdStorage",
        "sections": "<em>Add</em>, query, <em>and</em> mutate data using NerdStorage",
        "info": "NerdStorage is <em>a</em> document database <em>accessible</em> within New Relic One. It <em>allows</em> you to modify, save, <em>and</em> retrieve documents from one session to the next.",
        "tags": "<em>add</em> data",
        "body": " of 2 <em>Add</em> a new <em>Grid</em>Item to the application immediately before the closing <em>Grid</em> tag. In the new <em>Grid</em>Item <em>add</em> the following code to display your new button: &lt;Button onClick={() =&gt; this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType"
      },
      "id": "6091f9c8196a67648ed52a3c"
    },
    {
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "title": "Add a time picker",
      "type": "developer",
      "tags": [
        "time picker",
        "app",
        "helper method",
        "platformstatecontext"
      ],
      "external_id": "2602edf3077388ba4fded3a76208e5e0ae1be98f",
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-06-25T01:40:38Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a time picker to a sample application",
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the platformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(platformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(platformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the platformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(platformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(platformState) => { /* Taking a peek at the platformState */ console.log(platformState); const since = timeRangeToNrql(platformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.379845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>a</em> time picker",
        "sections": "<em>Add</em> <em>a</em> time picker",
        "info": "<em>Add</em> <em>a</em> time picker to <em>a</em> sample <em>application</em>",
        "tags": "<em>app</em>",
        "body": " Complete these steps: Step 1 of 5 In a text editor, open &#x2F;<em>add</em>-time-picker&#x2F;nerdlets&#x2F;nr1-howto-<em>add</em>-time-picker-nerdlet&#x2F;index.js. Step 2 of 5 <em>Add</em> the PlatformStateContext component to the end of the import statement so it looks like this: import { <em>Grid</em>, <em>Grid</em>Item, HeadingText, AreaChart, TableChart"
      },
      "id": "6091f827196a672a2ed52a6f"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-07-30T01:50:29Z",
      "title": "Add a section to end your test",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "b6a72d3fa08cce5a0edcacd34e8fa438dcfeaede",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a section to end your test",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.482994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>a</em> section to end your test",
        "sections": "<em>Add</em> <em>a</em> section to end your test",
        "info": "<em>Add</em> <em>a</em> section to end your test",
        "body": " column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet&#x27;s index.js file, <em>add</em> EndTestSection to your Nerdlet: import React from &#x27;react&#x27;; import { ChartGroup, <em>Grid</em>, <em>Grid</em>Item } from &#x27;nr1&#x27;; import"
      },
      "id": "6091faf228ccbcbf1fa268ea"
    }
  ],
  "/build-apps/ab-test/nrql-customizations": [
    {
      "image": "https://developer.newrelic.com/static/2df9afe07c6b32c8a1829a79d3096b53/ba3ac/nrql-query-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add NrqlQuery components to your Nerdlet",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "36c80e35fb841effd378c038e904ae1082a708fb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add NrqlQuery components to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.1926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>NrqlQuery</em> components to your Nerdlet",
        "sections": "Add <em>NrqlQuery</em> components to your Nerdlet",
        "info": "Add <em>NrqlQuery</em> components to your Nerdlet",
        "body": " to handle these differently than you did for the charts you&#x27;ve been dealing with because <em>NRQL</em> has no method for querying <em>data</em> from multiple sources. In the next lesson, you&#x27;ll learn how to supply <em>data</em> to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Customize</em> <em>NRQL</em> <em>data</em>."
      },
      "id": "6091faf2196a6723c0d52a32"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.873245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> open-source Nerdpacks",
        "body": " visualization with configuration options 10 min <em>Customize</em> your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a <em>custom</em> map view 30 min Build an app to show page view <em>data</em> on a map"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Query data with NRQL",
        "Learn more and start building",
        "Documentation",
        "Community forum",
        "GitHub"
      ],
      "title": "Query data with NRQL",
      "type": "developer",
      "tags": [
        "NRQL",
        "NRQL syntax",
        "calculate data NRQL"
      ],
      "external_id": "7bb23b086badd7a572964357aad776116f5bfbbe",
      "image": "https://developer.newrelic.com/static/eb2adf50e7680e8ba5b7daaf06c203d1/757a2/nr1-dashboard.png",
      "url": "https://developer.newrelic.com/collect-data/query-data-nrql/",
      "published_at": "2021-07-30T01:47:00Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Query default data as well as custom events and attributes with our powerful, SQL-like query language. Start querying now.",
      "body": "With NRQL, you can query any of the default data being reported by New Relic, plus any custom events and attributes you’ve added. Step 1 of 4 NRQL syntax is comparable to ANSI SQL. Learn more about NRQL syntax SELECT function(attribute) [AS 'label'][, ...] FROM event [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Step 2 of 4 NRQL queries can be as simple as fetching rows of data in a raw tabular form to inspect individual events. Learn what events open source agents provide out of the box -- Fetch a list of Browser PageView events SELECT * FROM PageView Copy Step 3 of 4 NRQL queries can also do extremely powerful calculations before the data is presented to you, such as crafting funnels based on the way people actually use your website. Learn more about NRQL funnels -- See how many users visit, signup, browse and purchase from your site as a funnel SELECT funnel(session, WHERE pageUrl='http://www.demotron.com/' AS 'Visited Homepage', WHERE pageUrl='http://www.demotron.com/signup' AS 'Signed Up', WHERE pageUrl='http://www.demotron.com/browse' AS 'Browsed Items', WHERE pageUrl='http://www.demotron.com/checkout' AS 'Made Purchase') FROM PageView SINCE 12 hours ago Copy Step 4 of 4 Using NRQL, you can customize your New Relic experience by crafting diverse dashboards that show your data from multiple angles. You can share these dashboards with technical and non-technical stakeholders alike. Learn more and start building Documentation For an overview of NRQL syntax, see Introduction to NRQL. For a detailed description of all available functions, see NRQL syntax, components, and functions. Community forum Connect with other developers in the our Explorers Hub. GitHub For examples of integrations and other technologies, check us out on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.500946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query <em>data</em> with <em>NRQL</em>",
        "sections": "Query <em>data</em> with <em>NRQL</em>",
        "info": "Query default <em>data</em> as well as <em>custom</em> events and attributes with our powerful, SQL-like query language. Start querying now.",
        "tags": "calculate <em>data</em> <em>NRQL</em>",
        "body": "With <em>NRQL</em>, you can query any of the default <em>data</em> being reported by New Relic, plus any <em>custom</em> events and attributes you’ve added. Step 1 of 4 <em>NRQL</em> syntax is comparable to ANSI SQL. Learn more about <em>NRQL</em> syntax SELECT function(attribute) [AS &#x27;label&#x27;][, ...] FROM event [WHERE attribute [comparison"
      },
      "id": "6091fa3964441f9f642f370d"
    },
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-07-27T22:25:48Z",
      "updated_at": "2021-07-21T13:27:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in New Relic One. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, browser, and mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the data explorer. Learn more about querying data in New Relic. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of browser data Here's a NRQL query of PageView data from browser monitoring. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for browser monitoring PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.45998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "tags": "Query your <em>data</em>",
        "body": " it to make your own <em>custom</em> chart. Where can you use <em>NRQL</em>? You can use <em>NRQL</em> in these places: New Relic One query builder NerdGraph: our GraphQL-format API, which includes options for making <em>NRQL</em> queries one.newrelic.com &gt; Query your <em>data</em>: You can run a <em>NRQL</em> query in New Relic One. This <em>NRQL</em> query"
      },
      "id": "60445a0e196a67cb09960f6e"
    },
    {
      "sections": [
        "Use your charts",
        "Change the appearance of your chart",
        "Customize your charts",
        "Tip",
        "Format date and time",
        "Customize the Y axis",
        "Enable or disable the legend",
        "Remove the other groups facet",
        "More chart-specific features",
        "Chart share and view options"
      ],
      "title": "Use  your charts ",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Use charts"
      ],
      "external_id": "947a92d0243924f412fedb47bcb95dc40ec953fb",
      "image": "https://docs.newrelic.com/static/9bd74f30a31df0cb0ab112a325296b92/59415/crop-cb-chart-menu-tooltip_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/use-your-charts/",
      "published_at": "2021-07-27T22:25:48Z",
      "updated_at": "2021-07-21T13:02:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Once you've created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using the data explorer to specify data, the query builder analyzes your data and applies a chart type that fits your data. For some queries, you'll have several options of chart types to choose from. To change chart type, use the Chart type menu to the right of the current chart. Each type in the list has a tooltip with information about using that type. Example of the chart type menu, showing a tooltip. Customize your charts While we try our best to optimize how we display your data, sometimes you may have other needs. To this end, you can customize charts to display information at your convenience. Tip Customizations are available depending on the chart type. Format date and time Tip For table and billboard charts. Customize the date and time format for tables and billboards: for each type of data, you can select if you want to leave it as it is, or modify the format as Numeric or Date. If data is a timestamp, you can choose how to represent the date and time: For numbers, select if you want us to auto-format them, or chose the number of decimals you want to see. Customize the Y axis Tip For line and area charts. On line charts and area charts you can adjust the Y axis to display the data within certain values by setting a minimum and maximum value for the axis. If no customization option is selected, dashboards automatically displays the full Y axis from 0 to the top value plus a margin. Enable or disable the legend Tip For line and area charts, and histograms. For line charts, area charts, and histograms, you can disable or enable the legend. Remove the other groups facet Tip For bar and pie charts, and tables. When faceting on bar charts, pie charts, or tables, and if the number of faceting on queries is larger than 2,000, the Other groups facet aggregates the rest of facets. With this customization you can select whether to see Other groups, or remove it. More chart-specific features For more chart type-specific features, see Chart types. Chart share and view options Most charts have various options, including a chart-embed option, getting a chart as an image, and adding a chart to a dashboard. To read about general chart options, see Basic UI features.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.20502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> your charts",
        "tags": "Query your <em>data</em>",
        "body": "Once you&#x27;ve created a chart, you can <em>customize</em> the appearance of it to best present the <em>data</em>. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (<em>NRQL</em>) mode or view your chart while using"
      },
      "id": "603ec29a196a67ef5da83d82"
    }
  ],
  "/build-apps/ab-test/confirmation-modal": [
    {
      "image": "https://developer.newrelic.com/static/e886dd8ae5b9e23c13d355abf15ea2b1/ba3ac/persist-selected-version-final.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/",
      "sections": [
        "Persist the selected version",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:41Z",
      "title": "Persist the selected version",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "a1867dc5e8e1ba4771a570e3c41e3e05c15e1977",
      "document_type": "page",
      "popularity": 1,
      "info": "Persist the selected version",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a section to end your test, before starting this one. In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version/ab-test Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Present an end test confirmation modal.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1041.098,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is reflected in the menu. However, when you press <em>End</em> <em>test</em>, nothing happens. In the next lesson, you&#x27;ll create a <em>confirmation</em> dialog to protect yourself from prematurely ending your A&#x2F;B <em>test</em>. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Present</em> an <em>end</em> <em>test</em> <em>confirmation</em> <em>modal</em>."
      },
      "id": "6091fb4428ccbc0a06a268ab"
    },
    {
      "image": "https://developer.newrelic.com/static/2df9afe07c6b32c8a1829a79d3096b53/ba3ac/nrql-query-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add NrqlQuery components to your Nerdlet",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "36c80e35fb841effd378c038e904ae1082a708fb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add NrqlQuery components to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 763.7413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Present</em> an <em>end</em> <em>test</em>"
      },
      "id": "6091faf2196a6723c0d52a32"
    },
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-07-27T17:34:54Z",
      "updated_at": "2021-07-27T17:34:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Hover an element Navigate to a URL Secure a credential Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.77217,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " monitor Provide a url and this monitor will <em>test</em> all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor Proactively ping your domain certificates based on a configurable threshold. Pair"
      },
      "id": "603e873864441f3e154e888f"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-07-30T01:50:30Z",
      "title": "Access NerdStorage from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "8c49cf33a6d954510f5c4b309a8a4d2f848fd68c",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorage from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.35733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Save <em>test</em> information to NerdStorage",
        "body": " value={&#x27;A&#x27;}&gt;Version A&lt;&#x2F;SelectItem&gt; &lt;SelectItem value={&#x27;B&#x27;}&gt;Version B&lt;&#x2F;SelectItem&gt; &lt;&#x2F;Select&gt; } } class <em>EndTest</em>Button extends React.Component { constructor() { super(...arguments); this.state = { <em>modal</em>Hidden: true, } this.show<em>Modal</em> = this.show<em>Modal</em>.bind(this); this.close<em>Modal</em> = this.close<em>Modal</em>"
      },
      "id": "6091faf1196a67250bd52a2b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/modal/",
      "sections": [
        "Modal",
        "Usage",
        "Examples",
        "Props"
      ],
      "published_at": "2021-07-30T01:57:18Z",
      "title": "Modal",
      "updated_at": "2021-06-25T01:50:51Z",
      "type": "developer",
      "external_id": "d0b0ddbfd4564c59b6711dcc5d6f9a17cdc5acd2",
      "document_type": "page",
      "popularity": 1,
      "body": "Modals are used for single-step create, add, edit, or delete actions. They are also used to display additional metadata about a screen or specific object on the screen. Usage import { Modal } from 'nr1' Copy Examples Props ariaLabelledBystring Pass the string of the text content which should better describe the purpose of the modal to be correctly announced by screen readers. childrennode Content to render inside the modal. classNamestring Appends class names to the component. hiddenboolean DEFAULT false If true, the modal is hidden. onCloserequiredfunction Callback fired when clicking on the Modal's close button. onHideEndfunction Callback fired when the Modal finishes the closing animation. Use this to unmount the Modal component. This ensures that the closing animation works properly. onHideStartfunction Callback fired when the Modal starts the closing animation. onShowEndfunction Callback fired when the Modal finishes the opening animation. onShowStartfunction Callback fired when the Modal starts the opening animation. styleobject Inline style for custom styling. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.978806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Modal</em>",
        "sections": "<em>Modal</em>",
        "body": " Callback fired when the <em>Modal</em> finishes the opening animation. onShowStartfunction Callback fired when the <em>Modal</em> starts the opening animation. styleobject Inline style for custom styling. <em>test</em>Idstring Adds a data-<em>test</em>-id attribute. Use it to target the component in unit and e2e tests."
      },
      "id": "6091f8ce28ccbc5e71a2689c"
    }
  ],
  "/build-apps/ab-test/install-nr1": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2209.1587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Install</em> and <em>configure</em>"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "image": "https://developer.newrelic.com/static/555c6dd44f2ffbceff682f7fbc78e01c/ba3ac/demo-service.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/demo-setup/",
      "sections": [
        "Spin up your demo services",
        "Course",
        "Important"
      ],
      "published_at": "2021-07-30T01:51:41Z",
      "title": "Spin up your demo services",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "9485b737ad7e595a2e2354438b2532748e978b42",
      "document_type": "page",
      "popularity": 1,
      "info": "Spin up your demo services",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Before you build your New Relic One application, you need to spin up your demo services. This coursework depends on two important services: A web service that shows a newsletter signup form. The form's heading text alternates between two versions because you're performing an A/B test to determine which text leads to more high-quality subscriptions. A simulator service that sends steady traffic to the website so that you don't have to manually generate data To spin up your demo services, you first need to install Docker and Docker compose. Spin up your demo services Step 1 of 5 Clone the coursework repository from GitHub: bash Copy $ git clone https://github.com/newrelic-experimental/nru-programmability-course This repository contains code for creating NodeJS New Relic automations. It also contains a an app code directory for each lesson in the course. You'll use these directories to follow along with the course content. Step 2 of 5 Change to the demo directory, called ab-test-app: bash Copy $ cd nru-programmability-course/ab-test-app This directory contains configuration files and READMEs for using the demo. Step 3 of 5 Build and run the web service and simulator containers, using docker-compose: bash Copy $ NEW_RELIC_LICENSE_KEY=<your New Relic license key> docker-compose up -d Important Make sure you replace <your New Relic license key> with your actual license key. Once it's finished, view the website at localhost:3001: Step 4 of 5 Visit New Relic, and navigate to APM in the top navigation menu. Select Newsletter from the list of instrumented services: You may have to wait a minute or two for New Relic to recieve data from your demo services. Once it's ready, you'll see transaction data, such as performance, throughput, and an Apdex score: Step 5 of 5 To spin down your demo services, run docker-compose down from your ab-test-app directory: bash Copy $ docker-compose down Now you're ready to build your New Relic One application! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Install and configure the New Relic One CLI.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1611.4803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to build your <em>New</em> <em>Relic</em> <em>One</em> application! Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> application from the ground up. Continue on to the next lesson: <em>Install</em> and <em>configure</em> the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>."
      },
      "id": "6091faf164441f20702f36f0"
    },
    {
      "image": "https://developer.newrelic.com/static/a618501b792e17a063fb841a8dcaa2bb/0086b/nerdlet-attached-to-app.png",
      "url": "https://developer.newrelic.com/build-apps/attach-nerdlet-to-entities/",
      "sections": [
        "Attach your Nerdlet to entities",
        "Before you begin",
        "Create a Nerdpack",
        "Configure your entities context",
        "Specify an entity domain",
        "Specify an entity type",
        "Specify entity tags",
        "Combine filters"
      ],
      "published_at": "2021-07-30T01:45:27Z",
      "title": "Attach your Nerdlet to entities",
      "updated_at": "2021-05-21T01:41:19Z",
      "type": "developer",
      "external_id": "36b82245d4253dfcef63961f0e01669eac041be8",
      "document_type": "page",
      "popularity": 1,
      "info": "Attach your Nerdlet to entities",
      "body": "One way for users to access your Nerdlet is by creating a launcher. The launcher opens a Nerdlet from the Apps page in New Relic. You can also provide access to your Nerdlet from an entity in your account. In this guide, you'll learn how to attach your Nerdlet to your entities. Before you begin If you haven't already: Sign up for a New Relic account Install and configure the New Relic One CLI Create a Nerdpack Step 1 of 5 Update your CLI: bash Copy $ nr1 update Step 2 of 5 Create a Nerdpack with the CLI: bash Copy $ nr1 create --type nerdpack --name entity-nerdlet This results in a Nerdpack, called entity-nerdlet, which consists of a launcher, called entity-nerdlet-launcher, and a Nerdlet, called entity-nerdlet-nerdlet. Step 3 of 5 Serve your Nerdpack: bash Copy $ cd entity-nerdlet $ nr1 nerdpack:serve Step 4 of 5 Go to https://one.newrelic.com/?nerdpacks=local, and navigate to Apps: ?nerdpacks=local is required to enable your locally served Nerdpacks to load in New Relic. Step 5 of 5 Under Your apps, click your launcher to view your New Relic One application: Attach your Nerdlet to entities You've seen how you can access your Nerdlet from a launcher. Now, access your Nerdlet from your entities. Step 1 of 6 From inside your Nerdpack's root directory, open nerdlets/entity-nerdlet-nerdlet/nr1.json. This is your Nerdlet's metadata file. You'll use this file to attach your Nerdlet to entities. Step 2 of 6 Add a context object with an entities array: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [] 8 } 9 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy This tells New Relic that you want to surface your Nerdlet in an array of entity contexts. Step 3 of 6 Add an entity context: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [ 8 { 9 \"domain\": \"APM\", 10 \"type\": \"APPLICATION\" 11 } 12 ] 13 } 14 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy Here, you've attached your Nerdlet to all application entities in the APM domain. Step 4 of 6 Go to APM: Because you're serving your Nerdpack locally, remember that you must still specify the ?nerdpacks=local query string. Step 5 of 6 Choose any of your applications: Step 6 of 6 Scroll down to see your Nerdlet attached to the application: Click this menu option and see your Nerdlet the same way you did with the launcher. Configure your entities context The context.entities key in your Nerdlet's nr1.json file specifies which entities your Nerdlet should be attached to. Specify an entity domain Attach your Nerdlet to a certain entity domain by specifying the domain as one of the following values: APM: Application Performance Monitoring BROWSER: Browser INFRA: Infrastructure monitoring MOBILE: Mobile monitoring SYNTH: Synthetic monitoring For example, attach your Nerdlet to all entities in the APM domain: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }] } } Copy Attach your Nerdlet to all entities except those in a domain: { \"context\": { \"entities\": [{ \"domain\": \"!APM\" }] } } Copy Attach your Nerdlet to all entities in multiple domains: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }, { \"domain\": \"BROWSER\" }] } } Copy Specify an entity type Attach your Nerdlet to a certain entity type by specifying the type as one of the following values: APPLICATION HOST MONITOR For example, attach your Nerdlet to all entities of the APPLICATION type: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }] } } Copy Attach your Nerdlet to all entities except those of a specified type: { \"context\": { \"entities\": [{ \"type\": \"!APPLICATION\" }] } } Copy Attach your Nerdlet to every entity whose type matches one of an array of types: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }, { \"type\": \"MONITOR\" }] } } Copy Specify entity tags Attach your Nerdlet to entities that have a given tag. For example, attach your Nerdlet to the entity which has a particular GUID: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"guid\", \"values\": [\"<SOME ENTITY GUID>\"] } ] } ] } } Copy Attach your Nerdlet to every entity which has particular accountId and uses the Python programming language: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"accountId\", \"values\": [\"<SOME ACCOUNT ID>\"] }, { \"key\": \"language\", \"values\": [\"python\"] } ] } ] } } Copy Combine filters When you filter the entities to which your Nerdlet will be added, you can combine domain, type, and tags: { \"context\": { \"entities\": [ { \"domain\": \"APM\", \"type\": \"APPLICATION\", \"tags\": [ { \"key\": \"language\", \"values\": [\"python\"] } ] }, { \"domain\": \"SYNTH\", \"type\": \"MONITOR\" }, { \"domain\": \"BROWSER\" } ] } } Copy In this example, you've attached your Nerdlet to: All APM applications whose metadata tags specify the python language AND all Synthetic monitors AND all Browser entities",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1259.8789,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Configure</em> your entities context",
        "body": " If you haven&#x27;t already: Sign up for a <em>New</em> <em>Relic</em> account <em>Install</em> and <em>configure</em> the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Create a Nerdpack Step 1 of 5 Update your <em>CLI</em>: bash Copy $ nr1 update Step 2 of 5 Create a Nerdpack with the <em>CLI</em>: bash Copy $ nr1 create --type nerdpack --name entity-nerdlet This results in a Nerdpack"
      },
      "id": "609c84b7e7b9d237155068d3"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.9782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Workloads: Isolate <em>and</em> resolve incidents faster",
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 336.71564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/ab-test/end-test": [
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add version descriptions",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "13644740111a7835d4738836f19589a74c711e26",
      "document_type": "page",
      "popularity": 1,
      "info": "Add version descriptions",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 966.16864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> version descriptions",
        "sections": "<em>Add</em> version descriptions",
        "info": "<em>Add</em> version descriptions",
        "body": " <em>section</em> of <em>your</em> application from user interface components. This <em>section</em> will be used to <em>end</em> the A&#x2F;B <em>test</em> with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> a <em>section</em> to <em>end</em> <em>your</em> <em>test</em>."
      },
      "id": "6091fb44196a6744a7d52a81"
    },
    {
      "image": "https://developer.newrelic.com/static/e886dd8ae5b9e23c13d355abf15ea2b1/ba3ac/persist-selected-version-final.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/",
      "sections": [
        "Persist the selected version",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:41Z",
      "title": "Persist the selected version",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "a1867dc5e8e1ba4771a570e3c41e3e05c15e1977",
      "document_type": "page",
      "popularity": 1,
      "info": "Persist the selected version",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a section to end your test, before starting this one. In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version/ab-test Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Present an end test confirmation modal.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 702.5379,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>section</em> to <em>end</em> <em>your</em>"
      },
      "id": "6091fb4428ccbc0a06a268ab"
    },
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-07-30T01:44:23Z",
      "updated_at": "2021-07-30T01:44:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.5202,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> default tags that <em>apply</em> <em>to</em> <em>all</em> metrics",
        "body": " the disabled-sub-metrics configuration <em>section</em>. <em>Add</em> tags (attributes) You can <em>add</em> tags to <em>your</em> data, which we save as attributes (key-value pairs). There are two options for adding tags: <em>Add</em> default tags that apply to all metrics: These apply to all metrics. They are fixed and don&#x27;t change over time. <em>Add</em>"
      },
      "id": "6043a32364441fa554378eee"
    },
    {
      "sections": [
        "Automated user management: SCIM API",
        "Requirements",
        "SCIM service provider",
        "Authentication",
        "Supported resources",
        "Schemas",
        "Supported actions",
        "Create group",
        "Get group",
        "Get group by query",
        "Update group with PUT",
        "Update group with PATCH (Non-member fields)",
        "Update group with PATCH (Add members)",
        "Update group with PATCH (Remove members)",
        "Delete group",
        "Create user",
        "Get user",
        "Get user by query",
        "Update user with PUT",
        "Update user with PATCH",
        "Delete user",
        "Deviations from the RFC",
        "Next steps when you're done",
        "Downgrade users",
        "Assign access grants"
      ],
      "title": "Automated user management: SCIM API",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "Automated user management"
      ],
      "external_id": "9e7992bec73759ba6c820721101618de28859b33",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/automated-user-management/scim-support-automated-user-management/",
      "published_at": "2021-07-27T06:21:55Z",
      "updated_at": "2021-07-27T06:21:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to implement New Relic's automated user management (AUM) and import your users from an identity provider, first read Introduction to AUM to learn about supported identity providers and when you'd want to use our SCIM API, documented below. Requirements Before using our SCIM API, you must first enable SCIM for an authentication domain. Note that after you enable SCIM, there are necessary next steps to do, including downgrading some users to basic users, and granting user groups access to New Relic accounts. SCIM service provider New Relic’s SCIM service provider follows the SCIM 2.0 API as described in RFCs 7643 and 7644. You do not need to implement all aspects of the SCIM 2.0 specification to integrate your user information with New Relic. In fact, the New Relic service provider itself does not implement all aspects of the specification. This document describes the features from the specification available for an integration with New Relic. Authentication Authentication is done using a bearer token. This bearer token is specific to your New Relic authentication domain. Supported resources The New Relic service provider supports the following SCIM resources: Group , User , Service provider config , Resource type and Schema. Bulk and Search are not supported. For more information on how the RFC describes the resource endpoints, see RFC 7644 SCIM Protocol Specification. Schemas New Relic uses a subset of the available fields in the SCIM core schema. Other SCIM fields are ignored if they are included in incoming requests. The fields used by New Relic are: Group: SCIM Field Name Description displayName Required. Name of the group. members List of users in the group. User: SCIM Field Name Description externalId Unique identifier for the user used by your system. userName Required. Unique identifier for the user within New Relic’s system. Use the user’s email address. name.familyName Last name of the user. name.givenName First name of the user. emails or emails.value Required. Email address of the user. timezone Time zone of the user in IANA Time Zone database format, also known as the \"Olson\" time zone database format (e.g., \"America/Los_Angeles\"). active Required. Boolean indicating whether or not the user should be active or inactive within New Relic. groups List of groups to which the user belongs. Supported actions SCIM provides several options for manipulating groups and users. The New Relic service provider supports the following options. When configuring, be aware that: Only simple filtering is supported. The eq operator may be used with a basic filter expression. For example, “displayName eq \"Example Group 1”. Other operators are not supported. PUT updates do not require that all fields be included. Fields that are not included will not be changed. When doing a PUT, if a required field already has the appropriate value, it is not necessary to include the field. Supported actions are: Create group Example request: POST /Groups { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"displayName\": \"Example Group 1\", \"members\": [] } Copy Example response: 201 Created { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T21:33:13.055Z\" }, \"members\": [] } Copy Get group Example request: GET /Groups/YOUR_GROUP_ID Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T21:33:13.055Z\" }, \"members\": [] } Copy Get group by query Example request: GET /Groups?filter=displayName eq \"Example Group 1\" Copy Example response: 200 OK { \"totalResults\": 1, \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:ListResponse\" ], \"Resources\": [{ \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T21:33:13.055Z\" }, \"members\": [] }] } Copy Update group with PUT In the request, include the fields that you want to change. If you include the members field, the group’s users will be adjusted to match the contents of the members field. Example request: PUT /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"displayName\": \"Example Group 1a\" } Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1a\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T22:47:14.019Z\" }, \"members\": [] } Copy Update group with PATCH (Non-member fields) Example request: PATCH /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Replace\", \"path\": \"displayName\", \"value\": \"Example Group 1b\" }] } Copy Example response: 204 No Content Copy Update group with PATCH (Add members) Example request: PATCH /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Add\", \"path\": \"members\", \"value\": [{ \"value\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\" }] }] } Copy Example response: 204 No Content Copy Update group with PATCH (Remove members) Example request: PATCH /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Remove\", \"path\": \"members\", \"value\": [{ \"value\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\" }] }] } Copy Example response: 204 No Content Copy Delete group Example request: DELETE /Groups/YOUR_GROUP_ID Copy Example response: 204 No Content Copy Create user Example request: POST /Users { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"groups\": [] } Copy Example response: 201 Created { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:07:12.477Z\" }, \"groups\": [] } Copy Get user Example request: GET /Users/YOUR_USER_ID Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:07:12.477Z\" }, \"groups\": [] } Copy Get user by query Example request: GET /Users?filter=externalId eq \"external-id-1\" Copy Example response: 200 OK { \"totalResults\": 1, \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:ListResponse\" ], \"Resources\": [{ \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:07:12.477Z\" }, \"groups\": [] }] } Copy Update user with PUT In the request, include the fields that you want to change. If you include the groups field, the user’s groups will be adjusted to match the contents of the groups field. Example request: PUT /Users/YOUR_USER_ID { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"name\": { \"familyName\": \"User 1A\", \"givenName\": \"Example\" } } Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1A\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:28:33.552Z\" }, \"groups\": [] } Copy Update user with PATCH Example request: PATCH /Users/YOUR_USER_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Replace\", \"path\": \"active\", \"value\": \"false\" }] } Copy Example response: 204 No Content Copy Delete user Example request: DELETE /Users/YOUR_USER_ID Copy Example response: 204 No Content Copy Deviations from the RFC This section describes areas where the New Relic SCIM service provider deviates from the SCIM protocol RFC 7644. Section numbers refer to RFC section numbers. Items in this section could change as we work to bring our service provider into full compliance with the RFC. RFC section name RFC section number Deviation description Creating Resources 3.3. The meta.location field is not set. Filtering 3.4.2.2. The only currently supported operator is eq. Field names are case sensitive. String attributes are compared in a case sensitive manner. Prefixing the field name with the schema is not supported. For example, filter=urn:ietf:params:scim:schemas:core:2.0:User:userName eq \"johnsmith\" will not work. /Me Authenticated Subject Alias 3.11. GET with the /Me resource returns a 404 Not Found. Service Provider Configuration Endpoints 4. The service provider feature discovery endpoints do not support filtering. Bearer Token and Cookie Considerations 7.4. Bearer tokens do not have a set expiration date. Next steps when you're done Downgrade users When your users are provisioned in New Relic, you should be able to see them in the User management UI. Users provisioned via your identity provider start out as full users. If your organization is on New Relic One pricing, these users are billable. To convert users to free basic users, use the User management UI. Assign access grants Once your users are in New Relic, you need to grant them access to specific New Relic accounts, specific groups, and specific roles. Without doing this, your users have no access to New Relic accounts. To learn how to do this, see: How access grants work The user management tutorial",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.41184,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automated</em> user management: SCIM <em>API</em>",
        "sections": "Update group with PATCH (<em>Add</em> members)",
        "tags": "<em>Accounts</em>",
        "body": ":2.0:PatchOp&quot; ], &quot;Operations&quot;: [{ &quot;op&quot;: &quot;Replace&quot;, &quot;path&quot;: &quot;displayName&quot;, &quot;value&quot;: &quot;Example Group 1b&quot; }] } Copy Example response: 204 No Content Copy Update group with PATCH (<em>Add</em> members) Example request: PATCH &#x2F;Groups&#x2F;<em>YOUR</em>_GROUP_ID { &quot;schemas&quot;: [ &quot;urn:ietf:params:scim:api:messages:2.0:PatchOp"
      },
      "id": "6043f38a64441f7d39378f0b"
    },
    {
      "sections": [
        "Forward your logs using the infrastructure agent",
        "Enable log forwarding using the infrastructure agent",
        "System Requirements",
        "Caution",
        "Install the infrastructure agent",
        "Configure the infrastructure agent",
        "Log forwarding parameters",
        "Name (required)",
        "name",
        "Log source (required)",
        "file",
        "Important",
        "systemd",
        "syslog",
        "tcp",
        "winlog",
        "Optional Configuration",
        "attributes",
        "Log attributes automatically inserted by the infrastructure agent(#automatically-inserted-attributes)",
        "pattern",
        "max_line_kb",
        "fluentbit",
        "Sample configuration file",
        "logging.d/sample.yaml",
        "View your log data",
        "Troubleshoot log forwarding",
        "No data appears when tailing a file",
        "Example: checking file access under Linux",
        "No data appears when capturing via a Syslog socket",
        "No data appears using infrastructure agent proxy",
        "Send the agent's logs to New Relic",
        "Fluent Bit does not start with the infra-agent",
        "Runtime error on Windows",
        "What's next?"
      ],
      "title": "Forward your logs using the infrastructure agent",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "dddab40697224ea7f816e70b05d18f8d75fb5084",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/forward-your-logs-using-infrastructure-agent/",
      "published_at": "2021-07-28T08:04:39Z",
      "updated_at": "2021-07-28T08:04:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can forward your logs to New Relic using our infrastructure monitoring agent. This makes all of your logging data available in one location and provides deeper visibility into both your application and your platform performance data. Enable log forwarding using the infrastructure agent To enable log forwarding through the infrastructure agent: Start by verifying the system requirements needed for configuring Logs. Ensure you have installed the infrastructure agent, version 1.11.4 or higher. Create a logging.yml file in the infrastructure agent's logging.d directory. Configure your log sources and other parameters. Generate some traffic and wait a few minutes, then check your account for data. Explore your log data in the Logs UI and benefit from the log attributes automatically inserted by the infrastructure agent. System Requirements To use the log forwarder of the infrastructure agent, make sure you meet the following requirements: Infrastructure agent version 1.11.4 or higher OpenSSL library 1.1.0 or higher is required by infra-agent starting from v1.16.4. The log forwarding feature is compatible with the following operating systems: Operating system Supported version Amazon Linux Amazon Linux 2 CentOS Version 7 or higher Debian Version 9 (\"Stretch\") or higher Red Hat Enterprise Linux (RHEL) Version 7 or higher SUSE Linux Enterprise Server (SLES) Version 12 Ubuntu Versions 16.04.x, 18.04.x and 20.04.x (LTS versions) Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 Caution The log forwarding feature is not supported on containerized infrastructure agents. Install the infrastructure agent Starting with version 1.11.4, the infrastructure agent can forward logs to New Relic. To install and run the agent, use a package manager (Linux) or the MSI installer (Windows). To use the following links, make sure you are logged to your New Relic account. Amazon Linux CentOS Debian RHEL SLES Ubuntu Windows If you don't have a New Relic account yet, or prefer to follow the procedure manually, see our tutorial to install the package manager. Configure the infrastructure agent Configuration files describe which log sources are forwarded. The Infrastructure agent uses .yml files for configuring logging. You can add as many config files as you want. To add a new configuration file for the log forwarding feature: Navigate to the logging forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a logging.yml configuration file and add the parameters you need. The logging.d directory has various .yml.example files that can be used as a reference or starting point. The agent automatically processes new configuration files without having to restart the Infrastructure service. The only exception to this is when configuring a custom Fluent Bit configuration. Log forwarding parameters The infrastructure log forwarding .yml config supports the following parameters: Name (required) To start, make sure to define a name for the logs you want to forward: name Name of the log or logs being forwarding to New Relic. Log source (required) What you use for the log source will depend on where you want to forward your logs from. The available options are listed below: file Path to the log file or files. The agent tracks changes on the log files in a way similar to tail -f shell. Example: logs: - name: example-log file: /var/log/example.log # Path to a single log file - name: example-log-two file: /var/log/example-two.log # Path to another single log file Copy The file parameter can point to a specific log file or multiple files by using wildcards applied to names and extensions; for example, /logs/*.log. You can use wildcards in place of directories in a file path, which can be used to tail files located in different directories. Example: logs: - name: docker-logs file: /var/lib/docker/containers/*/*.log # Path to multiple folders and files Copy Important Use of wildcards may significantly increase the number of file descriptors the Fluent Bit process keeps open, which can interfere with log collection if the host's file descriptor limit is reached. We recommend increasing the file descriptor limit on Linux hosts running Fluent Bit by adding the following to the host's /etc/security/limits.conf file: root soft nofile 65536 root hard nofile 65536 *soft nofile 65536 *hard nofile 65536 Copy If you add these changes, reboot the host to ensure your changes are applied. systemd Use the systemd paramater to forward log messages that are collected by the journald daemon in Linux environments. This input type requires the agent to run in root mode. Example: logs: - name: systemd-example systemd: cupsd Copy syslog Syslog data source. Parameters: uri: Syslog socket. Format varies depending on the protocol: TCP/UDP network sockets: [tcp/udp]://LISTEN_ADDRESS:PORT Unix domain sockets: unix_[tcp/udp]:// + /socket/path parser: Syslog parser. Default is rfc3164. Use rfc5424 if your messages include fractional seconds. Note: rfc3164 currently does not work on SuSE. unix_permissions: default is 0644 for domain sockets; this limits entries to processes running as root. You can use 0666 to listen for non-root processes, at your own risk. When running the agent in privileged mode, ports and sockets must be available or owned by nri-agent, with 0666 file permissions, so that other processes can write logs to the sockets. logs: # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 Copy tcp Logs retrieved over TCP connections. Parameters: uri: TCP/IP socket to listen for incoming data. The URI format is tcp://LISTEN_ADDRESS:PORT format: format of the data. It can be json or none. separator: If format: none is used, you can define a separator string for splitting records (default: \\n). logs: - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json Copy winlog Collect events from Windows log channels. Parameters: channel: name of the channel logs will be collected from. collect-eventids: a list of Windows Event IDs to be collected and forwarded to New Relic. Event ID ranges are supported. exclude-eventids: a list of Windows Event IDs to be excluded from collection. Event ID ranges are supported. All events are collected from the specified channel by default. Configure the collect-eventids and exclude-eventids sections to avoid sending unwanted logs to your New Relic account. Add event IDs or ranges to collect-eventids or exclude-eventids to forward or drop specific events. exclude-eventids takes precedence over collect-eventids if the same event ID is present in both sections. Example: logs: # Winlog log ingestion with eventId filters. - name: windows-security winlog: channel: Security collect-eventids: - 4624 - 4265 - 4700-4800 exclude-eventids: - 4735 # entries for the application, system, powershell, and SCOM channels - name: windows-application winlog: channel: Application - name: windows-system winlog: channel: System - name: windows-pshell winlog: channel: Windows Powershell - name: scom winlog: channel: Operations Manager # Entry for Windows Defender Logs - name: windows-defender winlog: channel: Microsoft-Windows-Windows Defender/Operational # Entry for Windows Clustering Logs - name: windows-clustering winlog: channel: Microsoft-Windows-FailoverClustering/Operational # Entry for IIS logs with logtype attribute for automatic parsing - name: iis-log file: C:\\inetpub\\logs\\LogFiles\\w3svc.log attributes: logtype: iis_w3c Copy Optional Configuration The following are configuration paramaters that are not required but are still recommended. attributes List of custom attributes as key-value pairs that can be used to send additional data with the logs which you can then query. Add attributes to any log source. Example: logs: - name: example-file-attributes file: /var/log/example.log attributes: logtype: nginx region: example-us-02 team: A-team - name: example-tcp-attributes tcp: uri: tcp://0.0.0.0:2345 format: json attributes: logtype: nginx region: example-us-02 team: B-team Copy Log attributes automatically inserted by the infrastructure agent(#automatically-inserted-attributes) The infrastructure agent automatically inserts log attributes for your convenience. Some of them are inserted for any log record, while others depend on the configuration parameters you used while setting up the log forwarder. Find a summary of these attributes in the following table: Attribute name Inserting conditions Description entity.guids Always inserted The infrastructure agent inserts the Entity GUID assigned by New Relic to identify the host where it's running. It is available in the entity.guids field. Note: If the captured logs belong to an application instrumented using APM, the entity.guids field contains both the entity GUID of infrastructure, as well as the GUID of APM, separated by a pipe ( | ) delimiter. fb.input Always inserted The underlying Fluent Bit input plugin type used to capture the logs. Currently, its values are tail, systemd, winlog, syslog, and tcp. filePath When using the file input type Absolute file path of the file being monitored. hostname Always inserted The hostname of the machine/VM/container executing the infrastructure agent. plugin.type Always inserted Indicates the utility used to capture the logs. In this case, it is the infrastructure agent itself, so this attribute always has the value nri-agent. pattern Regular expression for filtering records. Only supported for the tail, systemd, syslog, and tcp (only with format none) sources. This field works in a way similar to grep -E in Unix systems. For example, for a given file being captured, you can filter for records containing either WARN or ERROR using: - name: only-records-with-warn-and-error file: /var/log/logFile.log pattern: WARN|ERROR Copy No filtering is applied by default. max_line_kb Maximum size of log entries/lines in KB. If log entries exceed the limit, they are skipped. Default is 128. fluentbit External Fluent Bit configuration and parser files. If defined, they are merged with the existing configuration and parser files generated by the infrastructure agent. The infrastructure agent processes the configuration files located in the logging.d directory and will generate a run-time Fluent Bit configuration file that contains the appropriate [INPUT], [FILTER] and [OUTPUT] sections. Optionally, it will also declare an @INCLUDE in case you provided an external Fluent Bit configuration file via the fluentbit option. The runtime file does not define a [SERVICE] section, leaving all default Fluent Bit configuration values. You can still override Fluent Bit's default settings by defining your own [SERVICE] section in your external Fluent Bit configuration file and include it via the fluentbit option. Parameters: config_file: path to an existing Fluent Bit configuration file. Note that any overlapping source results in duplicate messages in New Relic Logs. parsers_file: path to an existing Fluent Bit parsers file. The following parser names are reserved: rfc3164, rfc3164-local and rfc5424. Sample configuration file Here is an example of a logging.d/ configuration file in YAML format. For more configuration examples, see the infrastructure agent repository. logging.d/sample.yaml # Remember to only use spaces for indentation logs: # Example of 'file' source - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern attributes: # You can use custom attributes to enrich your data logtype: nginx team: The A Team pattern: Error # Regular expression to filter log entries # Example of 'systemd' source (Linux only) - name: systemd-example systemd: cupsd # Examples of 'syslog' source, one per protocol # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Paths for Unix sockets are defined by combining protocol and path: # unix_udp:// + /path/socket - for example, unix_udp:///tmp/socket # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 # Examples of 'tcp' source for formats 'none' and 'json' - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries attributes: # You can add custom attributes to any source of logs tcpFormat: none someOtherAttribute: associatedValue max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json attributes: tcpFormat: json yetAnotherAttribute: 12345 # Example of Fluent Bit configuration import - name: fluentbit-import fluentbit: config_file: /path/to/fluentbit.config parsers_file: /path/to/fluentbit/parsers.conf Copy View your log data If everything is configured correctly and data is being collected, you should see data in both of these places: New Relic Logs UI New Relic tools for running NRQL queries; for example, you can execute a query like this: SELECT * FROM Log Copy Troubleshoot log forwarding Important Fluent Bit's tail plugin does not support network drives. If no data appears after you enable log management, follow standard troubleshooting procedures. No data appears when tailing a file The log forwarding feature requires the agent to have permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes, make sure that the log files you want to forward (and any intermediary directory in its path) are readable by the user running nri-agent. Example: checking file access under Linux Let's check whether the file /var/log/restrictedLogs/logFile.log can be monitored by the nri-agent user. In Linux, you can do a quick check with the namei command: sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr--r-- root root restrictedLogs logFile.log - No such file or directory Copy This command failed because the file is not visible to the nri-agent user. By inspecting the previous output, we can detect that the restrictedLogs directory is missing the execution flag for others\". We can fix this by executing: sudo chmod 755 /var/log/restrictedLogs Copy And then check for file access again: # sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr-xr-x root root restrictedLogs -rw-r----- vagrant vagrant logFile.log Copy The file is now visible to the nri-agent user. You must ensure that the file is also readable by the nri-agent user. To check this, use: # sudo -u nri-agent head /var/log/restrictedLogs/logFile.log head: cannot open '/var/log/restrictedLogs/logFile.log' for reading: Permission denied Copy In this example, the file is missing the read rights for the others group (users other than vagrant and the vagrant user group). You could fix this by granting read permissions to others, but the application could change these permissions upon restart. To avoid this, a better approach is to add the nri-agent user to the vagrant user group. No data appears when capturing via a Syslog socket The log forwarding feature requires that the agent has permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes: If you're using Unix domain socket files, make sure that the nri-agent user can access these files (please refer to the previous section) and that they have read and write permissions (666) so that other users than nri-agent can write to them. If you're using IP sockets, ensure that the port that you are using is not a system reserved one (like port 80, for example). If no data appears after you enable log management, follow standard log management troubleshooting procedures. No data appears using infrastructure agent proxy As explained in the infrastructure agent configuration guidelines, the proxy parameter must use either HTTP or HTTPS and be in the form https://user:password@hostname:port. The agent can parse the parameter without the HTTP or HTTPS, but the log-forwarder cannot. You will see an error like the following in the agent verbose logs: [ERROR] building HTTP transport: parse \\\"hostname:port\\\": first path segment in URL cannot contain colon Copy To solve this problem, check your newrelic-infra.yml file, and ensure the proxy parameter adheres to this form. Send the agent's logs to New Relic You can configure the infrastructure agent to send its own logs to New Relic. This is useful for troubleshooting issues with log forwarding, the agent, or when contacting support. To forward the infrastructure agent logs to New Relic: Edit your newrelic-infra.yml file. Enable agent logging in troubleshooting mode by adding verbose: 3 Important On Windows and systems that don't use systemd or where journald is inaccessible, verbose:3 causes the agent to write the logs on the disk. Revert to verbose:0 to prevent this. (Recommended): Enable agent logging in JSON format to log_format: json. Restart the agent to load the new settings. This configuration sets up the agent in troubleshooting mode, but the log forwarder (based on Fluent Bit) will continue in a non-verbose mode. Sometimes you can have issues with the log forwarder itself. For example, there may be problems accessing a specific channel when shipping Windows log events or when accessing a particular log file. In these situations, you can also enable the verbose mode for the log forwarder: Set verbose to a value other than 0. Add the following configuration option: trace: [\"log.fw\"]. Caution Check whether you are using the fluentbit option. When setting verbose: 3 and trace: [\"log.fw\"], ensure that you don't define any [OUTPUT] section pointing to stdout in an external Fluent Bit configuration file, Fluent Bit does not start with the infra-agent For Linux versions previous to 2016 you may need to update the OpenSSL library to 1.1.0 (or higher). To check if you have this problem: See if infra-agenthas started Fluent Bit by doing ps -aux | grep fluent-bit Copy If it isn't running go to /var/db/newrelic-infra/newrelic-integrations/logging and run ./fluent-bit -i systemd -o stdout Copy If you get the following error, update OpenSSL to 1.1.0 or higher: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory Runtime error on Windows One of the following error messages may appear when enabling log forwarding on Windows: The code execution cannot proceed because VCRUNTIME140.dll was not found. Copy OR error=\"exit status 3221225781\" process=log-forwarder Copy This is caused by a missing DLL. To solve the issue, install the Microsoft Visual C++ Redistributable: x64 or x86. What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.758026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Forward <em>your</em> logs using the infrastructure <em>agent</em>",
        "sections": "Forward <em>your</em> logs using the infrastructure <em>agent</em>",
        "body": "-<em>test</em> syslog: uri: udp:&#x2F;&#x2F;0.0.0.0:6140 # Use the udp:&#x2F;&#x2F;LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-<em>test</em> syslog: uri: unix_tcp:&#x2F;&#x2F;&#x2F;var&#x2F;unix-tcp-socket-<em>test</em> unix_permissions: 0666 # Default is 0644. Change at <em>your</em> own risk # Unix UDP domain socket - name"
      },
      "id": "603e9df164441f6b6f4e8843"
    }
  ],
  "/build-apps/ab-test/table-charts": [
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add pie charts",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "cd10196320620683a525a97cc3770662466e5134",
      "document_type": "page",
      "popularity": 1,
      "info": "Add pie charts",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.7942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> pie charts",
        "sections": "<em>Add</em> pie charts",
        "info": "<em>Add</em> pie charts",
        "body": " application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>tables</em>."
      },
      "id": "6091fb44e7b9d280165068d6"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add a chart group",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6ad93629eaf632d87125194995d2b7caa432f548",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a chart group",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.88878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a chart group",
        "sections": "<em>Add</em> a chart group",
        "info": "<em>Add</em> a chart group",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>tables</em>, before starting"
      },
      "id": "6091faf1196a6726c2d52a20"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2021-07-30T01:41:42Z",
      "updated_at": "2021-05-21T01:40:23Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component. Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows. As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells. The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.85864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>tables</em> to your New Relic One application",
        "sections": "<em>Add</em> <em>tables</em> to your New Relic One application",
        "info": "<em>Add</em> a <em>table</em> to your New Relic One app.",
        "tags": "<em>table</em> in app",
        "body": " <em>Add</em> some action to your table! <em>Tables</em> are great, but interactive <em>tables</em> can be better: As a last update, you are going to allow users to act on each data row. <em>Add</em> the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns"
      },
      "id": "6091f7cae7b9d209f45068a1"
    },
    {
      "sections": [
        "MySQL monitoring integration",
        "Compatibility and requirements",
        "Important",
        "Quick start",
        "Install and activate",
        "ECS",
        "Kubernetes",
        "Linux",
        "Windows",
        "Configuration",
        "Activate remote monitoring",
        "Environment variable passthroughs",
        "HOSTNAME",
        "PORT",
        "USERNAME",
        "PASSWORD",
        "DATABASE",
        "EXTENDED_METRICS",
        "EXTENDED_INNODB_METRICS",
        "EXTENDED_MY_ISAM_METRICS",
        "Find and use data",
        "Metric data",
        "Default metrics",
        "Extended metrics",
        "Extended innodb metrics",
        "Extended myisam metrics",
        "Extended slave cluster metrics",
        "Inventory",
        "System metadata",
        "Source code"
      ],
      "title": "MySQL monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "50b118a06500c42ca8f26ce475d00f70c6fda148",
      "image": "https://docs.newrelic.com/static/6bf45ccf002250f7ebaa69cbe3ff706c/c1b63/guided-install-cli.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/mysql-monitoring-integration/",
      "published_at": "2021-07-30T01:55:45Z",
      "updated_at": "2021-07-30T01:55:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our MySQL integration collects and sends inventory and metrics from your MySQL database to our platform, where you can see the health of your database server and analyze metric data so that you can easily find the source of any problems. Read on to install the integration, and to see what data we collect. Compatibility and requirements Our integration is compatible with MySQL version 5.6 or higher. Before installing the integration, make sure that you meet the following requirements: A New Relic account. Don't have one? Sign up for free! No credit card required. If MySQL is not running on Kubernetes or Amazon ECS, you can install the infrastructure agent on a Linux or Windows OS host. Otherwise: If running on Kubernetes, see these requirements. If running on ECS, see these requirements. Important For MySQL v8.0 and higher we do not support the following metrics: cluster.slaveRunning, db.qCacheFreeMemoryBytes, db.qCacheHitRatio, db.qCacheNotCachedPerSecond. Quick start Instrument your MySQL database quickly and send your telemetry data with guided install. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click one of these button to try it out. Guided install EU Guided install Our guided install uses the infrastructure agent to set up the MySQL integration. Not only that, it discovers other applications and log sources running in your environment and then recommends which ones you should instrument. The guided install works with most setups. But if it doesn't suit your needs, you can find other methods below to get started monitoring your MySQL database. Install and activate To install the MySQL integration, follow the instructions for your environment: ECS See Monitor service running on ECS. Kubernetes See Monitor service running on Kubernetes. Linux Follow the instructions for installing an integration, using the file name nri-mysql. From the command line, create a user with replication and select privileges: This command creates a user newrelic@localhost with a specific password. sudo mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'YOUR_SELECTED_PASSWORD' WITH MAX_USER_CONNECTIONS 5;\" Copy sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost';\" Copy Gives replication privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Gives select privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Change the directory to the integration's folder. cd /etc/newrelic-infra/integrations.d Copy Copy the sample configuration file: sudo cp mysql-config.yml.sample mysql-config.yml Copy Edit the configuration file mysql-config.yml as explained in the next section. Restart the infrastructure agent. Windows Download the nri-mysql .MSI installer image from: https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mysql/nri-mysql-amd64.msi To install from the Windows command prompt, run: msiexec.exe /qn /i PATH\\TO\\nri-mysql-amd64.msi Copy In the Integrations directory, C:\\Program Files\\New Relic\\newrelic-infra\\integrations.d\\, create a copy of the sample configuration file by running: cp mysql-config.yml.sample mysql-config.yml Copy Edit the mysql-config.yml file as described in the configuration settings. Restart the infrastructure agent. Additional notes: Advanced: Integrations are also available in tarball format to allow for install outside of a package manager. On-host integrations do not automatically update. For best results, regularly update the integration package and the infrastructure agent. Configuration An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference. There are several ways to configure the integration, depending on how it was installed: If enabled via Kubernetes: see Monitor services running on Kubernetes. If enabled via Amazon ECS: see Monitor services running on ECS. If installed on-host: edit the config in the integration's YAML config file, mysql-config.yml. The configuration provides a single command, status, that captures the metrics and all the config options. It accepts these arguments: hostname: the MySQL hostname. port: the port where the MySQL server is listening. username: the user connected to the MySQL server. If you used the CREATE USER command in the activation instructions, this should be set to newrelic. password: the password for the user specified above. extended_metrics: captures an extended set of metrics. Disabled by default. Set to 1 to enable. This also enables the capture of slave metrics. extended_innodb_metrics: captures additional innodb metrics. Disabled by default. Set to 1 to enable. extended_myisam_metrics: captures additional MyISAM metrics. Disabled by default. Set to 1 to enable. Optional: labels field. For example, the env label controls the environment inventory data. The default value is production. Optional: metrics field. Set to 1 to disable the collection of inventory. See a sample of a configuration file. Activate remote monitoring The remote_monitoring parameter enables remote monitoring and multi-tenancy for this integration. This parameter is enabled by default and should not be changed unless you require it in your custom environment. Activating remote_monitoring may change some attributes and/or affect your configured alerts. For more information, see remote monitoring in on-host integrations. Important Infrastructure agent version 1.2.25 or higher is required to use remote_monitoring. Environment variable passthroughs Environment variables can be used to control config settings, and are then passed through to the infrastructure agent. For instructions on how to use this feature, see Configure the infrastructure agent. Important With secrets management, you can configure on-host integrations with New Relic infrastructure's agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file. For more information, see Secrets management. HOSTNAME Specifies the hostname or IP where MySQL is running. Type String Default localhost Example: HOSTNAME='MySQL DB' Copy PORT Port on which MySQL server is listening. Type Integer Default 3306 Example: PORT=6379 Copy USERNAME The user connected to the MySQL server. Type String Default (none) Example: USERNAME='DBAdmin' Copy PASSWORD Password for the given user. Type String Default (none) Example: PASSWORD='Hh7$(uvRt' Copy DATABASE Name of the database to be monitored. Type String Default (none) Example: DATABASE='My MySQL DB' Copy EXTENDED_METRICS Captures an extended set of metrics. This also enables the capture of slave metrics. Type Boolean Default false Example: EXTENDED_METRICS=true Copy EXTENDED_INNODB_METRICS Captures additional innodb metrics. Type Boolean Default false Example: EXTENDED_INNODB_METRICS=true Copy EXTENDED_MY_ISAM_METRICS Captures additional MyISAM metrics. Type Boolean Default false Example: EXTENDED_MY_ISAM_METRICS=true Copy For more about the general structure of on-host integration configuration, see Configuration. Find and use data Data from this service is reported to an integration dashboard. Metrics are attached to the MysqlSample event type. You can query this data for troubleshooting purposes or to create custom charts and dashboards. For more on how to find and use your data, see Understand integration data. Metric data The MySQL integration collects the following metrics: Default metrics These metrics are captured by default: Name Description cluster.slaveRunning Boolean. 1 if this server is a replication slave that is connected to a replication master, and both the I/O and SQL threads are running; otherwise, it is 0. For metrics reported if enabled, see replication slave metrics. db.handlerRollbackPerSecond Rate of requests for a storage engine to perform a rollback operation, per second. db.innodb.bufferPoolPagesData Number of pages in the InnoDB buffer pool containing data. db.innodb.bufferPoolPagesFree Number of free pages in the InnoDB buffer pool. db.innodb.bufferPoolPagesTotal Total number of pages of the InnoDB buffer pool. db.innodb.dataReadBytesPerSecond Rate at which data is read from InnoDB tables in bytes per second. db.innodb.dataWrittenBytesPerSecond Rate at which data is written to InnoDB tables in bytes per second. db.innodb.logWaitsPerSecond Number of times that the log buffer was too small and a wait was required for it to be flushed before continuing, in waits per second. db.innodb.rowLockCurrentWaits Number of row locks currently being waited for by operations on InnoDB tables. db.innodb.rowLockTimeAvg Average time to acquire a row lock for InnoDB tables, in milliseconds. db.innodb.rowLockWaitsPerSecond Number of times operations on InnoDB tables had to wait for a row lock per second. db.openedTablesPerSecond Number of files that have been opened with my_open() (a mysys library function) per second. Parts of the server that open files without using this function do not increment the count. db.openFiles Number of files that are open. This count includes regular files opened by the server. It does not include other types of files such as sockets or pipes. db.openTables Number of tables that are open. db.qCacheFreeMemoryBytes Amount of free memory in bytes for the query cache. db.qCacheHitRatio Percentage of queries that are retrieved from the cache. db.qCacheNotCachedPerSecond Number of noncached queries (not cacheable, or not cached due to the query_cache_type setting) per second. db.qCacheUtilization Percentage of query cache memory that is being used. db.tablesLocksWaitedPerSecond Number of times per second that a request for a table lock could not be granted immediately and a wait was needed. net.abortedClientsPerSecond Number of connections per second that were aborted because the client died without closing the connection properly. net.abortedConnectsPerSecond Number of failed attempts to connect to the MySQL server, per second. net.bytesReceivedPerSecond Byte throughput received from all clients, per second. net.bytesSentPerSecond Byte throughput sent to all clients, per second. net.connectionErrorsMaxConnectionsPerSecond Rate per second at which connections were refused because the server max_connections limit was reached. net.connectionsPerSecond Number of connection attempts per second. net.maxUsedConnections Maximum number of connections that have been in use simultaneously since the server started. net.threadsConnected Number of currently open connections. net.threadsRunning Number of threads that are not sleeping. query.comCommitPerSecond Number of COMMIT statements executed per second. query.comDeletePerSecond Number of DELETE statements executed per second. query.comDeleteMultiPerSecond Number of DELETE statements that use the multiple-table syntax executed per second. query.comInsertPerSecond Number of INSERT statements executed per second. query.comInsertSelectPerSecond Number of INSERT SELECT statements executed per second. query.comReplaceSelectPerSecond Number of REPLACE SELECT statements executed per second. query.comRollbackPerSecond Number of ROLLBACK statements executed per second. query.comSelectPerSecond Number of SELECT statements executed per second. query.comUpdateMultiPerSecond Number of UPDATE statements that use the multiple-table syntax executed per second. query.comUpdatePerSecond Number of UPDATE statements executed per second. query.preparedStmtCountPerSecond Current number of prepared statements per second. (The maximum number of statements is given by the max_prepared_stmt_count system variable.) query.queriesPerSecond Total number of statements executed by the server per second, including statements executed within stored programs. query.questionsPerSecond Number of statements executed by the server per second, limited to only those sent by clients. query.slowQueriesPerSecond Number of queries per second that have taken more than long_query_time seconds. This counter increments regardless of whether the slow query log is enabled. Extended metrics Additional metrics captured when extended_metrics is enabled (set to 1 in the configuration file): Name Description db.createdTmpDiskTablesPerSecond Number of internal on-disk temporary tables created per second by the server while executing statements. db.createdTmpFilesPerSecond Number of temporary files created per second by mysqld. db.createdTmpTablesPerSecond Number of internal temporary tables created per second by the server while executing statements. db.handlerDeletePerSecond Number of times per second that rows have been deleted from tables. db.handlerReadFirstPerSecond Number of times per second the first entry in an index was read. db.handlerReadKeyPerSecond Number of requests per second to read a row based on a key. db.handlerReadRndNextPerSecond Number of requests per second to read the next row in the data file. db.handlerReadRndPerSecond Number of requests per second to read a row based on a fixed position. db.handlerUpdatePerSecond Number of requests per second to update a row in a table. db.handlerWritePerSecond Number of requests per second to insert a row in a table. db.maxExecutionTimeExceededPerSecond Number of SELECT statements per second for which the execution timeout was exceeded. db.qCacheFreeBlocks Number of free memory blocks in the query cache. db.qCacheHitsPerSecond Number of query cache hits per second. db.qCacheInserts Number of queries added to the query cache. db.qCacheLowmemPrunesPerSecond Number of queries per second that were deleted from the query cache because of low memory. db.qCacheQueriesInCachePerSecond Number of queries per second registered in the query cache. db.qCacheTotalBlocks Total number of blocks in the query cache. db.selectFullJoinPerSecond Number of joins that perform table scans because they do not use indexes, per second. db.selectFullJoinRangePerSecond Number of joins per second that used a range search on a reference table. db.selectRangeCheckPerSecond Number of joins per second without keys that check for key usage after each row. db.selectRangePerSecond Number of joins per second that used ranges on the first table. db.sortMergePassesPerSecond Number of merge passes that the sort algorithm has had to do, per second. db.sortRangePerSecond Number of sorts per second that were done using ranges. db.sortRowsPerSecond Number of sorted rows per second. db.sortScanPerSecond Number of sorts that were done by scanning the table, per second. db.tableOpenCacheHitsPerSecond Number of hits per second for open tables cache lookups. db.tableOpenCacheMissesPerSecond Number of misses per second for open tables cache lookups. db.tableOpenCacheOverflowsPerSecond Number of overflows per second for the open tables cache. db.threadCacheMissRate Percent of threads that need to be created to handle new connections because there are not enough threads available in the cache. db.threadsCached Number of threads in the thread cache. db.threadsCreatedPerSecond Number of threads per second created to handle connections. Extended innodb metrics Additional metrics captured when extended_innodb_metrics is enabled (set to 1 in the configuration file): Name Description db.innodb.bufferPoolPagesDirty Current number of dirty pages in the InnoDB buffer pool. db.innodb.bufferPoolPagesFlushedPerSecond Number of requests per second to flush pages from the InnoDB buffer pool. db.innodb.bufferPoolReadAheadEvictedPerSecond Number of pages per second read into the InnoDB buffer pool by the read-ahead background thread that were subsequently evicted without having been accessed by queries. db.innodb.bufferPoolReadAheadPerSecond Number of pages per second read into the InnoDB buffer pool by the read-ahead background thread. db.innodb.bufferPoolReadAheadRndPerSecond Number of “random” read-aheads per second initiated by InnoDB. This happens when a query scans a large portion of a table but in random order. db.innodb.bufferPoolReadRequestsPerSecond Number of logical read requests per second. db.innodb.bufferPoolReadsPerSecond Number of logical reads that InnoDB could not satisfy from the buffer pool, and had to read directly from disk, per second. db.innodb.bufferPoolWaitFreePerSecond Number of times per second a read or write to InnoDB had to wait because there were not clean pages available in the buffer pool. db.innodb.bufferPoolWriteRequestsPerSecond Number of writes per second done to the InnoDB buffer pool. db.innodb.dataFsyncsPerSecond Number of fsync() operations per second. db.innodb.dataPendingFsyncs Current number of pending fsync() operations. db.innodb.dataPendingReads Current number of pending reads. db.innodb.dataPendingWrites Current number of pending writes. db.innodb.dataReadsPerSecond Number of data reads (OS file reads) per second. db.innodb.dataWritesPerSecond Number of data writes per second. db.innodb.logWriteRequestsPerSecond Number of write requests for the InnoDB redo log per second. db.innodb.logWritesPerSecond Number of physical writes per second to the InnoDB redo log file. db.innodb.numOpenFiles Number of files InnoDB currently holds open. db.innodb.osLogFsyncsPerSecond Number of fsync() writes per second done to the InnoDB redo log files. db.innodb.osLogPendingFsyncs Number of pending fsync() operations for the InnoDB redo log files. db.innodb.osLogPendingWrites Number of pending writes per second to the InnoDB redo log files. db.innodb.osLogWrittenBytesPerSecond rate Number of bytes written per second to the InnoDB redo log files. db.innodb.pagesCreatedPerSecond The number of pages created per second by operations on InnoDB tables. db.innodb.pagesReadPerSecond Number of pages read per second from the InnoDB buffer pool by operations on InnoDB tables. db.innodb.pagesWrittenPerSecond Number of pages written per second by operations on InnoDB tables. db.innodb.rowsDeletedPerSecond Number of rows deleted per second from InnoDB tables. db.innodb.rowsInsertedPerSecond Number of rows per second inserted into InnoDB tables. db.innodb.rowsReadPerSecond Number of rows per second read from InnoDB tables. db.innodb.rowsUpdatedPerSecond Number of rows per second updated in InnoDB tables. Extended myisam metrics Additional metrics captured when extended_myisam_metrics is enabled in the configuration file: Name Description db.myisam.keyBlocksNotFlushed Number of key blocks in the MyISAM key cache that have changed but have not yet been flushed to disk. db.myisam.keyCacheUtilization Percentage of the key cache that is being used. db.myisam.keyReadRequestsPerSecond Number of requests to read a key block from the MyISAM key cache, per second. db.myisam.keyReadsPerSecond Number of physical reads of a key block from disk into the MyISAM key cache, per second. db.myisam.keyWriteRequestsPerSecond Number of requests per second to write a key block to the MyISAM key cache. db.myisam.keyWritesPerSecond Number of physical writes of a key block from the MyISAM key cache to disk, per second. Extended slave cluster metrics Additional metrics captured when the extended metrics flag is enabled in the configuration file and the cluster.slaveRunning metric is returning a value of 1. Check the MySQL Documentation for more details. Name Description db.relayLogSpace Total combined number of bytes for all existing relay log files. cluster.lastIOErrno Error number of the most recent error that caused the I/O thread to stop. cluster.lastIOError Error message of the most recent error that caused the I/O thread to stop. cluster.lastSQLErrno Error number of the most recent error that caused the SQL thread to stop. cluster.lastSQLError Error message of the most recent error that caused the SQL thread to stop. cluster.slaveIORunning Status of whether the I/O thread is started and has connected successfully to the master. The values can be Yes, No, or Connecting. cluster.slaveSQLRunning Status of whether the SQL thread is started. The values can be Yes or No. cluster.secondsBehindMaster Difference in seconds between the slave’s clock time and the timestamp of the query when it was recorded in the master’s binary log. When the slave is not correctly connected to the master, this metric won’t be reported. cluster.masterLogFile Name of the master binary log file from which the I/O thread is currently reading. cluster.readMasterLogPos Position in the current master binary log file up to which the I/O thread has read. cluster.relayMasterLogFile Name of the master binary log file containing the most recent event executed by the SQL thread. cluster.execMasterLogPos Position in the current master binary log file to which the SQL thread has read and executed, marking the start of the next transaction or event to be processed. Inventory The MySQL integration captures the configuration parameters of the MySQL node returned by SHOW GLOBAL VARIABLES. The data is available on the Inventory page, under the config/mysql source. System metadata The MySQL integration collects the following metadata attributes about your MySQL system: Name Description software.edition software.edition takes the value of the MySQL version_comment variable. software.version The MySQL server version. cluster.nodeType Either master or slave, depending on the role of the MySQL node being monitored. Source code The MySQL integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.53429,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " pool. db.innodb.bufferPoolPagesTotal Total number of pages of the InnoDB buffer pool. db.innodb.dataReadBytesPerSecond Rate at which data is read from InnoDB <em>tables</em> in bytes per second. db.innodb.dataWrittenBytesPerSecond Rate at which data is written to InnoDB <em>tables</em> in bytes per second"
      },
      "id": "6043a211e7b9d294bc5799d1"
    },
    {
      "sections": [
        "Use your charts",
        "Change the appearance of your chart",
        "Customize your charts",
        "Tip",
        "Format date and time",
        "Customize the Y axis",
        "Enable or disable the legend",
        "Remove the other groups facet",
        "More chart-specific features",
        "Chart share and view options"
      ],
      "title": "Use  your charts ",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Use charts"
      ],
      "external_id": "947a92d0243924f412fedb47bcb95dc40ec953fb",
      "image": "https://docs.newrelic.com/static/9bd74f30a31df0cb0ab112a325296b92/59415/crop-cb-chart-menu-tooltip_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/use-your-charts/",
      "published_at": "2021-07-27T22:25:48Z",
      "updated_at": "2021-07-21T13:02:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Once you've created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using the data explorer to specify data, the query builder analyzes your data and applies a chart type that fits your data. For some queries, you'll have several options of chart types to choose from. To change chart type, use the Chart type menu to the right of the current chart. Each type in the list has a tooltip with information about using that type. Example of the chart type menu, showing a tooltip. Customize your charts While we try our best to optimize how we display your data, sometimes you may have other needs. To this end, you can customize charts to display information at your convenience. Tip Customizations are available depending on the chart type. Format date and time Tip For table and billboard charts. Customize the date and time format for tables and billboards: for each type of data, you can select if you want to leave it as it is, or modify the format as Numeric or Date. If data is a timestamp, you can choose how to represent the date and time: For numbers, select if you want us to auto-format them, or chose the number of decimals you want to see. Customize the Y axis Tip For line and area charts. On line charts and area charts you can adjust the Y axis to display the data within certain values by setting a minimum and maximum value for the axis. If no customization option is selected, dashboards automatically displays the full Y axis from 0 to the top value plus a margin. Enable or disable the legend Tip For line and area charts, and histograms. For line charts, area charts, and histograms, you can disable or enable the legend. Remove the other groups facet Tip For bar and pie charts, and tables. When faceting on bar charts, pie charts, or tables, and if the number of faceting on queries is larger than 2,000, the Other groups facet aggregates the rest of facets. With this customization you can select whether to see Other groups, or remove it. More chart-specific features For more chart type-specific features, see Chart types. Chart share and view options Most charts have various options, including a chart-embed option, getting a chart as an image, and adding a chart to a dashboard. To read about general chart options, see Basic UI features.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.61018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Once you&#x27;ve created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and <em>add</em> a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using"
      },
      "id": "603ec29a196a67ef5da83d82"
    }
  ],
  "/build-apps/ab-test/publish": [
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 823.72565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "sections": "Subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "info": "Subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Publish</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "6091fb4464441f42962f3737"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Describe your app for the catalog",
      "updated_at": "2021-05-05T01:53:28Z",
      "type": "developer",
      "external_id": "afe457b61d3ba06f63401c3e10b925e5362330dc",
      "document_type": "page",
      "popularity": 1,
      "info": "Describe your app for the catalog",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 696.9609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Describe <em>your</em> app for the catalog",
        "sections": "Describe <em>your</em> app for the catalog",
        "info": "Describe <em>your</em> app for the catalog",
        "body": " nerdlet, before starting this <em>one</em>. In the last lesson, you finished the A&#x2F;B test <em>application</em> you&#x27;ve been building throughout this course. Now, it&#x27;s time to prepare it for publication. When you <em>publish</em> <em>your</em> app to the <em>New</em> <em>Relic</em> <em>One</em> catalog, users can view it and subscribe to it. You can help <em>your</em> users"
      },
      "id": "6091fa9864441fdae82f3726"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.6312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and storage. A browser <em>application</em> and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here&#x27;s a workload: <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in <em>your</em> workload"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 350.77142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in <em>your</em> solution, its alert status, and how the entities are connected, at a glance. See all <em>your</em> workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how <em>your</em> system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.3457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to build <em>New</em> <em>Relic</em> <em>One</em>, you can build custom applications that align with <em>your</em> unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an <em>application</em> will take you only a few minutes. Check out these guides for help building"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/ab-test/subscribe": [
    {
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/",
      "sections": [
        "Publish your New Relic One application",
        "Course",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Publish your New Relic One application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "f17b8d1fc30a296e6c4f0b4ef06c28e36672b87b",
      "document_type": "page",
      "popularity": 1,
      "info": "Publish your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Describe your app for the catalog, before starting this one. In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the Nerdpack's root-level package.json file. Every time you modify code in your Nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 7 Change to the publish/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 7 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 7 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 7 Replace all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively. Step 6 of 7 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 7 of 7 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Subscribe to your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 499.31787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Publish <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "sections": "Publish <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "info": "Publish <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": " accounts unless those apps are added to the public <em>New</em> <em>Relic</em> <em>One</em> catalog. Now that <em>your</em> app is published and its metadata is submitted, you can <em>subscribe</em> <em>your</em> account to the app from the catalog. In the next lesson, you&#x27;ll learn the ways to <em>subscribe</em> and unsubscribe to <em>your</em> <em>new</em> <em>application</em>. Course"
      },
      "id": "6091fb45e7b9d2820a5068b9"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 386.2379,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add navigation <em>to</em> <em>your</em> Nerdlet",
        "sections": "Add navigation <em>to</em> <em>your</em> Nerdlet",
        "info": "Add navigation <em>to</em> <em>your</em> Nerdlet",
        "body": " and <em>subscribe</em> to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> so that it can run on our platform instead of <em>your</em> own local server. Second, is to learn how to deal with some common issues you might see in <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> development. Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. Continue on to the next lesson: Describe <em>your</em> app for the catalog."
      },
      "id": "6091faf128ccbcb641a268f9"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.9782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and storage. A browser <em>application</em> and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here&#x27;s a workload: <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in <em>your</em> workload"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 336.71564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in <em>your</em> solution, its alert status, and how the entities are connected, at a glance. See all <em>your</em> workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how <em>your</em> system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 328.6463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to build <em>New</em> <em>Relic</em> <em>One</em>, you can build custom applications that align with <em>your</em> unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an <em>application</em> will take you only a few minutes. Check out these guides for help building"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/ab-test/serve-app": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1116.8438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a&#x2F;an Nerdlet Nerdpack item inside <em>your</em> Nerdpack. launcher catalog visualization In the next lesson, you&#x27;ll learn how to <em>serve</em> <em>your</em> Nerdpack locally and see <em>your</em> app in action! Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. Continue on to the next lesson: <em>Serve</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>."
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/",
      "sections": [
        "Add chart components to your A/B test application",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add chart components to your A/B test application",
      "updated_at": "2021-05-05T01:53:29Z",
      "type": "developer",
      "external_id": "02161afd9e7762a927a1e95b6119f5b5fa6f7b9a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart components to your A/B test application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Serve your New Relic One application, before starting this one. The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add your first chart.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 943.4743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add chart components to <em>your</em> A&#x2F;B test <em>application</em>",
        "sections": "Add chart components to <em>your</em> A&#x2F;B test <em>application</em>",
        "info": "Add chart components to <em>your</em> A&#x2F;B test <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Serve</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "6091fa99e7b9d20804506901"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.6312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and storage. A browser <em>application</em> and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here&#x27;s a workload: <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in <em>your</em> workload"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-07-28T06:53:27Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 350.77142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, <em>services</em>, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, <em>services</em>, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in <em>your</em> solution, its alert status, and how the entities are connected, at a glance. See all <em>your</em> workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how <em>your</em> system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.3457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to build <em>New</em> <em>Relic</em> <em>One</em>, you can build custom applications that align with <em>your</em> unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an <em>application</em> will take you only a few minutes. Check out these guides for help building"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/ab-test/create-nerdpack": [
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1203.3931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to present that data, you might need to <em>create</em> something entirely unique. With the New Relic One SDK, we&#x27;ve provided you all the tools you&#x27;ll need to <em>create</em> your own visualizations. Build your custom visualization With the New Relic One SDK, you can <em>create</em> a <em>Nerdpack</em>, which houses your visualization code"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 583.74646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>advanced</em> configurations for your <em>Nerdpack</em>",
        "sections": "Enable <em>advanced</em> configurations for your <em>Nerdpack</em>",
        "info": "Enable <em>advanced</em> configurations for your <em>Nerdpack</em>",
        "body": ", and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 <em>create</em> --type <em>nerdpack</em> --name new-<em>nerdpack</em> RequestError: Error: self signed certificate in certificate chain Node uses its own"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    },
    {
      "image": "https://developer.newrelic.com/static/a618501b792e17a063fb841a8dcaa2bb/0086b/nerdlet-attached-to-app.png",
      "url": "https://developer.newrelic.com/build-apps/attach-nerdlet-to-entities/",
      "sections": [
        "Attach your Nerdlet to entities",
        "Before you begin",
        "Create a Nerdpack",
        "Configure your entities context",
        "Specify an entity domain",
        "Specify an entity type",
        "Specify entity tags",
        "Combine filters"
      ],
      "published_at": "2021-07-30T01:45:27Z",
      "title": "Attach your Nerdlet to entities",
      "updated_at": "2021-05-21T01:41:19Z",
      "type": "developer",
      "external_id": "36b82245d4253dfcef63961f0e01669eac041be8",
      "document_type": "page",
      "popularity": 1,
      "info": "Attach your Nerdlet to entities",
      "body": "One way for users to access your Nerdlet is by creating a launcher. The launcher opens a Nerdlet from the Apps page in New Relic. You can also provide access to your Nerdlet from an entity in your account. In this guide, you'll learn how to attach your Nerdlet to your entities. Before you begin If you haven't already: Sign up for a New Relic account Install and configure the New Relic One CLI Create a Nerdpack Step 1 of 5 Update your CLI: bash Copy $ nr1 update Step 2 of 5 Create a Nerdpack with the CLI: bash Copy $ nr1 create --type nerdpack --name entity-nerdlet This results in a Nerdpack, called entity-nerdlet, which consists of a launcher, called entity-nerdlet-launcher, and a Nerdlet, called entity-nerdlet-nerdlet. Step 3 of 5 Serve your Nerdpack: bash Copy $ cd entity-nerdlet $ nr1 nerdpack:serve Step 4 of 5 Go to https://one.newrelic.com/?nerdpacks=local, and navigate to Apps: ?nerdpacks=local is required to enable your locally served Nerdpacks to load in New Relic. Step 5 of 5 Under Your apps, click your launcher to view your New Relic One application: Attach your Nerdlet to entities You've seen how you can access your Nerdlet from a launcher. Now, access your Nerdlet from your entities. Step 1 of 6 From inside your Nerdpack's root directory, open nerdlets/entity-nerdlet-nerdlet/nr1.json. This is your Nerdlet's metadata file. You'll use this file to attach your Nerdlet to entities. Step 2 of 6 Add a context object with an entities array: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [] 8 } 9 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy This tells New Relic that you want to surface your Nerdlet in an array of entity contexts. Step 3 of 6 Add an entity context: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [ 8 { 9 \"domain\": \"APM\", 10 \"type\": \"APPLICATION\" 11 } 12 ] 13 } 14 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy Here, you've attached your Nerdlet to all application entities in the APM domain. Step 4 of 6 Go to APM: Because you're serving your Nerdpack locally, remember that you must still specify the ?nerdpacks=local query string. Step 5 of 6 Choose any of your applications: Step 6 of 6 Scroll down to see your Nerdlet attached to the application: Click this menu option and see your Nerdlet the same way you did with the launcher. Configure your entities context The context.entities key in your Nerdlet's nr1.json file specifies which entities your Nerdlet should be attached to. Specify an entity domain Attach your Nerdlet to a certain entity domain by specifying the domain as one of the following values: APM: Application Performance Monitoring BROWSER: Browser INFRA: Infrastructure monitoring MOBILE: Mobile monitoring SYNTH: Synthetic monitoring For example, attach your Nerdlet to all entities in the APM domain: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }] } } Copy Attach your Nerdlet to all entities except those in a domain: { \"context\": { \"entities\": [{ \"domain\": \"!APM\" }] } } Copy Attach your Nerdlet to all entities in multiple domains: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }, { \"domain\": \"BROWSER\" }] } } Copy Specify an entity type Attach your Nerdlet to a certain entity type by specifying the type as one of the following values: APPLICATION HOST MONITOR For example, attach your Nerdlet to all entities of the APPLICATION type: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }] } } Copy Attach your Nerdlet to all entities except those of a specified type: { \"context\": { \"entities\": [{ \"type\": \"!APPLICATION\" }] } } Copy Attach your Nerdlet to every entity whose type matches one of an array of types: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }, { \"type\": \"MONITOR\" }] } } Copy Specify entity tags Attach your Nerdlet to entities that have a given tag. For example, attach your Nerdlet to the entity which has a particular GUID: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"guid\", \"values\": [\"<SOME ENTITY GUID>\"] } ] } ] } } Copy Attach your Nerdlet to every entity which has particular accountId and uses the Python programming language: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"accountId\", \"values\": [\"<SOME ACCOUNT ID>\"] }, { \"key\": \"language\", \"values\": [\"python\"] } ] } ] } } Copy Combine filters When you filter the entities to which your Nerdlet will be added, you can combine domain, type, and tags: { \"context\": { \"entities\": [ { \"domain\": \"APM\", \"type\": \"APPLICATION\", \"tags\": [ { \"key\": \"language\", \"values\": [\"python\"] } ] }, { \"domain\": \"SYNTH\", \"type\": \"MONITOR\" }, { \"domain\": \"BROWSER\" } ] } } Copy In this example, you've attached your Nerdlet to: All APM applications whose metadata tags specify the python language AND all Synthetic monitors AND all Browser entities",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 572.0021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Attach</em> your Nerdlet to entities",
        "sections": "<em>Create</em> <em>a</em> <em>Nerdpack</em>",
        "info": "<em>Attach</em> your Nerdlet to entities",
        "body": " If you haven&#x27;t already: Sign up for a New Relic account Install and configure the New Relic One CLI <em>Create</em> a <em>Nerdpack</em> Step 1 of 5 Update your CLI: bash Copy $ nr1 update Step 2 of 5 <em>Create</em> a <em>Nerdpack</em> with the CLI: bash Copy $ nr1 <em>create</em> --type <em>nerdpack</em> --name entity-nerdlet This results in a <em>Nerdpack</em>"
      },
      "id": "609c84b7e7b9d237155068d3"
    },
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 541.65564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>and</em> configure the New Relic One CLI",
        "sections": "Install <em>and</em> configure the New Relic One CLI",
        "info": "Install <em>and</em> configure the New Relic One CLI",
        "body": ", before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To <em>create</em> a <em>Nerdpack</em> , you&#x27;ll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its <em>create</em> command. Install and configure the CLI Step 1"
      },
      "id": "6091faf1196a6714b4d52a39"
    },
    {
      "image": "https://developer.newrelic.com/static/fcc5c48e25ec18cb8ddf8518059586bb/0086b/new-message.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Serve your New Relic One application",
      "updated_at": "2021-05-13T01:54:25Z",
      "type": "developer",
      "external_id": "79f6532d0c9e836788ebd0958c1158f062f0fd95",
      "document_type": "page",
      "popularity": 1,
      "info": "Locally serve your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Tip Here, you've seen how to access your Nerdlet from a launcher. If you want your Nerdlet closer to your data, you can also attach your Nerdlet to New Relic entities. Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 454.98004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve your New Relic One <em>application</em>",
        "sections": "Serve your New Relic One <em>application</em>",
        "info": "Locally serve your New Relic One <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Create</em> a <em>Nerdpack</em>, before"
      },
      "id": "6091fb4428ccbcfe3fa268f1"
    }
  ],
  "/build-apps/ab-test/navigation": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Describe your app for the catalog",
      "updated_at": "2021-05-05T01:53:28Z",
      "type": "developer",
      "external_id": "afe457b61d3ba06f63401c3e10b925e5362330dc",
      "document_type": "page",
      "popularity": 1,
      "info": "Describe your app for the catalog",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 918.4441,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Describe <em>your</em> app for the catalog",
        "sections": "Describe <em>your</em> app for the catalog",
        "info": "Describe <em>your</em> app for the catalog",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>navigation</em> to <em>your</em>"
      },
      "id": "6091fa9864441fdae82f3726"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 650.6685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>navigation</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.25082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a time picker <em>to</em> <em>your</em> app",
        "body": " 20 min <em>Add</em> a time picker to a sample application <em>Add</em> <em>your</em> custom visualization to a dashboard 10 min <em>Add</em> <em>your</em> custom visualization to a New Relic dashboard Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack Attach <em>your</em> <em>Nerdlet</em> to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.00772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdlets</em>",
        "body": " launcher for <em>your</em> Nerdpack and called it &quot;ab-test-launcher&quot;. Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher&#x27;s metadata file Use &quot;A&#x2F;B Test Launcher&quot; for the launcher&#x27;s displayName and &quot;Open the A&#x2F;B test <em>Nerdlet</em>"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.8482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> details <em>to</em> describe <em>your</em> project",
        "info": "Build a &quot;Hello, World!&quot; app and publish it <em>to</em> New Relic One",
        "body": " default class MyAwesomeNerdpack<em>NerdletNerdlet</em> extends React.Component { render() { return &lt;h1&gt;&quot;Hello, World!&quot;&lt;&#x2F;h1&gt;; } } Copy Step 4 of 9 As an optional step, you can <em>add</em> a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in <em>your</em> new"
      },
      "id": "6091f9c864441f70d82f36c4"
    }
  ],
  "/build-apps/ab-test/add-charts": [
    {
      "image": "https://developer.newrelic.com/static/fcc5c48e25ec18cb8ddf8518059586bb/0086b/new-message.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Serve your New Relic One application",
      "updated_at": "2021-05-13T01:54:25Z",
      "type": "developer",
      "external_id": "79f6532d0c9e836788ebd0958c1158f062f0fd95",
      "document_type": "page",
      "popularity": 1,
      "info": "Locally serve your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Tip Here, you've seen how to access your Nerdlet from a launcher. If you want your Nerdlet closer to your data, you can also attach your Nerdlet to New Relic entities. Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2784.23,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve <em>your</em> New Relic One <em>application</em>",
        "sections": "Serve <em>your</em> New Relic One <em>application</em>",
        "info": "Locally serve <em>your</em> New Relic One <em>application</em>",
        "body": "&gt;; } } nerdlets&#x2F;ab-<em>test</em>-nerdlet&#x2F;index.js Copy <em>Your</em> app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. Continue on to the next lesson: <em>Add</em> <em>chart</em> <em>components</em> to <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>."
      },
      "id": "6091fb4428ccbcfe3fa268f1"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/",
      "sections": [
        "Add your first chart",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:41Z",
      "title": "Add your first chart",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "292725b4d7883e56c1178913f21337d18b92133c",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your first chart",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart components to your A/B test application, before starting this one. In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add pie charts.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1695.2313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>your</em> first <em>chart</em>",
        "sections": "<em>Add</em> <em>your</em> first <em>chart</em>",
        "info": "<em>Add</em> <em>your</em> first <em>chart</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>chart</em> <em>components</em> to <em>your</em>"
      },
      "id": "6091faf164441f0f032f3727"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.21753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>a</em> Nerdpack",
        "sections": "Create <em>a</em> Nerdpack",
        "info": "Create <em>a</em> Nerdpack",
        "body": "&#x27;s displayName to &quot;A&#x2F;<em>B</em> <em>Test</em>&quot; and set the description to &quot;A&#x2F;<em>B</em> <em>test</em> <em>your</em> <em>application</em> using New Relic One&quot;: { &quot;schemaType&quot;: &quot;NERDPACK&quot;, &quot;id&quot;: &quot;311bcd0c-f7eb-4285-afed-4219179bf91d&quot;, &quot;displayName&quot;: &quot;A&#x2F;<em>B</em> <em>Test</em>&quot;, &quot;description&quot;: &quot;A&#x2F;<em>B</em> <em>test</em> <em>your</em> <em>application</em> using New Relic One.&quot; } nr1.json Copy It&#x27;s good to describe"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.64297,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Build</em> <em>apps</em>",
        "sections": "<em>Add</em> the NerdGraphQuery <em>component</em> <em>to</em> <em>an</em> <em>application</em>",
        "body": " building apps, and dive into our library of <em>components</em>. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps <em>Add</em> the NerdGraphQuery component to an <em>application</em> 20 minutes The NerdGraphQuery component allows you to query data"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Install the Kubernetes integration using Helm",
        "Compatibility and requirements",
        "Install Kubernetes integration with Helm",
        "Helm 3 using nri-bundle (recommended)",
        "Installing and configuring nri-bundle with Helm",
        "Configuring nri-bundle with Helm",
        "Enabling and disabling subcharts",
        "Configuring subcharts",
        "Helm 2 using newrelic-infrastructure",
        "Important",
        "Tip",
        "Helm configuration options",
        "Update via Helm"
      ],
      "title": "Install the Kubernetes integration using Helm",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Installation"
      ],
      "external_id": "a3e4c960777df00f17ce0e4b0d1083612bdca527",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/install-kubernetes-integration-using-helm/",
      "published_at": "2021-07-27T13:05:07Z",
      "updated_at": "2021-07-27T13:05:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Helm is a package manager on top of Kubernetes. It facilitates installation, upgrades, or revision tracking, and it manages dependencies for the services that you install in Kubernetes. To install the integration using Helm, we recommend our Kubernetes automated installer, or follow the instructions in this document to complete a basic Kubernetes installation with Helm. To install the integration using manifests, see Kubernetes integration: install and configure. Start the installer Compatibility and requirements Our Helm chart is compatible with both Helm 2 and 3. Make sure Helm is installed on your machine. To install the Kubernetes integration using Helm, you will need your New Relic account license key and your Kubernetes cluster's name: Find and copy your New Relic license key. Find the name of your cluster with this command: kubectl config current-context Copy Install Kubernetes integration with Helm Follow the instructions for your version of Helm: Helm 3 using nri-bundle (recommended) New Relic has several charts for the different components which offer different features for the platform: newrelic-infrastructure: Contains the main Kubernetes integration and the infrastructure agent. This is the core component for the New Relic Kubernetes experience. newrelic-logging: Provides a DaemonSet with New Relic's Fluent Bit output plugin to easily forward your logs to Logs. nri-kube-events: Collects and reports cluster events (such as kubectl get events) to New Relic. nri-metadata-injection: Automatically injects metadata in applications deployed to the cluster to correlate APM monitoring with Infrastructure monitoring. nri-prometheus: New Relic's Prometheus OpenMetrics Integration, allows to scrape Prometheus endpoints and report metrics to New Relic. nri-statsd: New Relic StatsD integration. Additionally, New Relic provides nri-bundle, a chart which pulls a selectable set of the charts mentioned above. nri-bundle can also install Kube State Metrics for you if needed. We recommend using the nri-bundle chart for Kubernetes deployments, as it provides the easiest way to select, install, and upgrade individual components at your will. Installing and configuring nri-bundle with Helm Set the cluster where you want to install the agent: kubectl config set-cluster DESIRED_CLUSTER Copy To see the available clusters, run kubectl config get-clusters. Add the New Relic Helm charts repo: helm repo add newrelic https://helm-charts.newrelic.com Copy Make sure everything is configured properly in the chart by running the following command. This step uses the --dry-run and --debug switches and therefore the agent isn't installed. helm upgrade --install newrelic newrelic/nri-bundle \\ --dry-run \\ --debug \\ --set global.licenseKey=YOUR_NEW_RELIC_LICENSE_KEY \\ --set global.cluster=K8S_CLUSTER_NAME \\ --set infrastructure.enabled=true \\ --set prometheus.enabled=true \\ --set webhook.enabled=true \\ --set ksm.enabled=false \\ --set kubeEvents.enabled=true \\ --set logging.enabled=true Copy You can flip the ksm.enabled flag to true if KSM isn't already present in your cluster. Install the Kubernetes integration: helm upgrade --install newrelic newrelic/nri-bundle \\ --set global.licenseKey=YOUR_NEW_RELIC_LICENSE_KEY \\ --set global.cluster=K8S_CLUSTER_NAME \\ --set infrastructure.enabled=true \\ --set prometheus.enabled=true \\ --set webhook.enabled=true \\ --set ksm.enabled=false \\ --set kubeEvents.enabled=true \\ --set logging.enabled=true Copy Wait a few seconds, then check that the DaemonSet and pods have been created: kubectl get daemonsets,pods Copy Make sure you see a DaemonSet, and one pod per node for newrelic-infrastructure, as well as one Deployment and one pod for any other component that you have enabled. Configuring nri-bundle with Helm Enabling and disabling subcharts The nri-bundle chart pulls the following dependencies, if the corresponding flags are enabled: Subchart Flag newrelic-infrastructure infrastructure.enabled nri-prometheus prometheus.enabled nri-metadata-injection webhook.enabled kube-state-metrics ksm.enabled nri-kube-events kubeEvents.enabled newrelic-logging logging.enabled Configuring subcharts The nri-bundle chart leverages Helm's subchart configuration mechanism to configure its components. This means that you can supply the configuration values to the individual components of the chart, as listed at the beginning of this section, by prefixing them with the name of the chart. For example, to run the agent in unprivileged mode, you can add --set newrelic-infrastructure.privileged=false to the command above, where newrelic-infrastructure is the name of the sub-chart (as listed at the beginning of the section), and privileged is the configuration value for said chart. Please refer to each of the chart's README and their values.yml to see all available configuration options and their defaults. Helm 2 using newrelic-infrastructure Important Helm 2 has been deprecated and New Relic does not recommend using it for deployments. Instructions in this section are provided for legacy purposes only. To install using Helm 2: Ensure that Helm 2, including their cluster-side components (i.e. Tiller) are properly installed and configured. Please check the official documentation for more details. Set the cluster where you want to install the agent: kubectl config set-cluster DESIRED_CLUSTER Copy To see the available clusters, run kubectl config get-clusters Make sure that kube-state-metrics is installed on your machine: kubectl get deployment --all-namespaces | grep kube-state-metrics Copy If it's not installed, follow the instructions in the kube-state-metrics GitHub repo to install it. Add the New Relic Helm charts repo: helm repo add newrelic https://helm-charts.newrelic.com Copy Make sure everything is configured properly in the chart by running the following command. This step uses the --dry-run and --debug switches and therefore the agent is not installed. helm install newrelic/newrelic-infrastructure \\ --dry-run \\ --debug \\ --set licenseKey=YOUR_NEW_RELIC_LICENSE_KEY \\ --set cluster=K8S_CLUSTER_NAME \\ --set config.custom_attributes.cluster=K8S_CLUSTER_NAME Copy Install the New Relic Kubernetes integration: helm install newrelic/newrelic-infrastructure \\ --set licenseKey=your_new_relic_license_key \\ --set cluster=K8S_CLUSTER_NAME \\ --set config.custom_attributes.cluster=K8S_CLUSTER_NAME Copy Tip Note that the --dry-run and --debug switches have been removed. Wait a few seconds, then check that the DaemonSet and pods have been created: kubectl get daemonsets,pods Copy Make sure you see a DaemonSet, and one pod per node. Helm configuration options When you install or upgrade the Kubernetes integration with Helm using the command line, you can pass your configuration variables with the --set flag. helm install newrelic/newrelic-infrastructure \\ --set licenseKey=YOUR_NEW_RELIC_LICENSE_KEY \\ --set cluster=YOUR_CLUSTER_NAME Copy A full list of the configuration parameters can be found in the newrelic-infrastructure chart README Update via Helm To update your Kubernetes integration installed via Helm: Update the local chart repository: helm repo update Copy Get the release name of the newrelic-infrastructure chart: helm list Copy Update the release rerunning the appropriate helm upgrade --install command for your preferred installation method.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.24388,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Installing <em>and</em> configuring nri-<em>bundle</em> with Helm",
        "body": " way to select, install, and upgrade individual <em>components</em> at <em>your</em> will. Installing and configuring nri-bundle with Helm Set the cluster where you want to install the agent: kubectl config set-cluster DESIRED_CLUSTER Copy To see the available clusters, run kubectl config get-clusters. <em>Add</em> the New"
      },
      "id": "603eb326e7b9d2d5f82a080a"
    }
  ],
  "/build-apps/ab-test/first-chart": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/",
      "sections": [
        "Add chart components to your A/B test application",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add chart components to your A/B test application",
      "updated_at": "2021-05-05T01:53:29Z",
      "type": "developer",
      "external_id": "02161afd9e7762a927a1e95b6119f5b5fa6f7b9a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart components to your A/B test application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Serve your New Relic One application, before starting this one. The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add your first chart.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 742.8689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>chart</em> components to <em>your</em> A&#x2F;B test application",
        "sections": "<em>Add</em> <em>chart</em> components to <em>your</em> A&#x2F;B test application",
        "info": "<em>Add</em> <em>chart</em> components to <em>your</em> A&#x2F;B test application",
        "body": " to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>your</em> <em>first</em> <em>chart</em>."
      },
      "id": "6091fa99e7b9d20804506901"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add pie charts",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "cd10196320620683a525a97cc3770662466e5134",
      "document_type": "page",
      "popularity": 1,
      "info": "Add pie charts",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 547.96045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> pie <em>charts</em>",
        "sections": "<em>Add</em> pie <em>charts</em>",
        "info": "<em>Add</em> pie <em>charts</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>your</em> <em>first</em> <em>chart</em>, before"
      },
      "id": "6091fb44e7b9d280165068d6"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.74509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Your</em> <em>first</em> visualization",
        "body": "When you create a dashboard, you <em>add</em> a variety of charts to visualize <em>your</em> New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in <em>your</em> dashboard Update their names, display options, and underlying data queries"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-27T22:22:22Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.25168,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> dashboard",
        "sections": "<em>Add</em> new content to <em>your</em> dashboard",
        "tags": "Query <em>your</em> data",
        "body": ". Create new content by clicking the <em>Add</em> widget button. <em>Add</em> a new <em>chart</em> using the query builder, or <em>add</em> text, images, or links using our markdown editor. Resize and rearrange charts. You can move any <em>chart</em> and put it anywhere in the dashboard so the layout you set fits <em>your</em> preferences: place <em>your</em> more"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-07-27T21:12:16Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.77852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query <em>your</em> data",
        "tags": "Query <em>your</em> data",
        "body": ", it is applied as a filter. The table stays visible so you can easily select another facet to continue <em>your</em> exploration. Share and export You can get the <em>chart</em> as an image, share it as a link, or <em>add</em> it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share <em>your</em> whole"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    }
  ],
  "/build-apps/ab-test/add-ui": [
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Add a chart group",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6ad93629eaf632d87125194995d2b7caa432f548",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a chart group",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1205.5634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a chart group",
        "sections": "<em>Add</em> a chart group",
        "info": "<em>Add</em> a chart group",
        "body": " that teaches you how to build a New Relic One <em>application</em> from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>user</em> <em>interface</em> <em>components</em> to <em>your</em> <em>application</em>."
      },
      "id": "6091faf1196a6726c2d52a20"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add a grid",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "fab1a23ddf5003cd0fb8189b903f3707a97d66e5",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a grid",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1184.4856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a grid",
        "sections": "<em>Add</em> a grid",
        "info": "<em>Add</em> a grid",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>user</em> <em>interface</em>"
      },
      "id": "6091faf228ccbcbfe2a268f2"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.63948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> the NerdGraphQuery <em>component</em> <em>to</em> an <em>application</em>",
        "body": " building apps, and dive into our library of <em>components</em>. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps <em>Add</em> the NerdGraphQuery component to an <em>application</em> 20 minutes The NerdGraphQuery component allows you to query data"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-07-30T01:44:15Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.93161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Original <em>user</em> model",
        "info": "Learn about permissions for using and subscribing accounts <em>to</em> Nerdpacks",
        "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance <em>Your</em> ability to manage and use Nerdpacks depends on <em>your</em> <em>user</em>&#x27;s: Model (original or New Relic One model) Type Role Whether you&#x27;re on the original <em>user</em> model or the New Relic One <em>user</em> model"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "sections": [
        "Introduction to the C SDK",
        "Monitor app performance",
        "Architecture: C library and daemon",
        "Get started with the C SDK",
        "Check the source code"
      ],
      "title": "Introduction to the C SDK",
      "type": "docs",
      "tags": [
        "Agents",
        "C SDK",
        "Get started"
      ],
      "external_id": "2d78c020e6e048a9e2fca7eb1f27e0041f8a5112",
      "image": "https://docs.newrelic.com/static/5e14d39d4bf4ef8132f32a5beb5b8970/8c557/c-sdk-daemon-architecture0430.png",
      "url": "https://docs.newrelic.com/docs/agents/c-sdk/get-started/introduction-c-sdk/",
      "published_at": "2021-07-27T10:37:00Z",
      "updated_at": "2021-07-27T10:37:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The C SDK is designed to support the often complex, multi-threaded nature of C/C++ applications. You can gain a new level of visibility to help you identify and solve performance issues. You can also collect and analyze data to help you improve the customer experience and make data-driven business decisions. The C SDK can be used to instrument a wide range of applications beyond C or C++. If your application does not use other languages supported by New Relic and can import C libraries, then you can use the New Relic C SDK to take advantage of our monitoring capabilities and features. Monitor app performance one.newrelic.com > APM > (select an app): Here is an example of some of the data you can view in New Relic after you deploy the C SDK for your app. If your app meets the C SDK's compatibility and requirements in Linux environments, you can customize the generic library to communicate with New Relic, then start with APM to monitor your app's performance. What you can do How to do it See the big picture Start with the APM Summary page to monitor the throughput, response times, errors, memory and CPU usage transactions in your applications and services, then explore other details with additional APM dashboards. With deployment markers, see how code changes impact application performance and health. Use infrastructure monitoring to view detailed host and server data. When you install the infrastructure agent and APM on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by app in the Infrastructure UI. Identify and fix errors Use error analytics tools to find bottlenecks by seeing time spent on database calls, external system calls, and key blocks of code. Get alert notifications for problems or errors before they affect users. Create custom dashboards for important metrics. Analyze business data Query user-related data and improve business processes. Send your own custom data to New Relic. Create custom queries of your application data. Create and share visual, interactive displays of your data. And more! Monitor and troubleshoot your application users' desktop experience with your application, including page load timing problems, JavaScript errors, session trace timelines, etc., by using browser monitoring. Use automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints with synthetic monitoring. Analyze and fine-tune your Android and iOS application performance, troubleshoot crashes, compare multiple versions, and examine the performance of HTTP and other network components with mobile monitoring. Architecture: C library and daemon The C SDK relies on two components to send data from your application to New Relic: The lC SDK calls: You download this library, then add the calls and instrumentation to your application's code. This allows you to identify and customize the kinds of data that matters the most to you. The C SDK daemon: This is a separate binary that accumulates data from the C SDK calls, and sends it to New Relic. This acts as a proxy between the SDK and New Relic. C SDK architecture: To send data from your application to New Relic, the daemon must be invoked before making calls to your application's C SDK instrumentation library. Working together, the C SDK instrumentation and the daemon forward data on to New Relic where you can view and query data about transactions. The workflow between your application and New Relic must occur in this order: An HTTPS link is established between the daemon and New Relic. The daemon must be invoked first, before your instrumented application is invoked. Next, socket communication is established between your instrumented application and the daemon. This occurs after successful calls to newrelic_new_app_config() and newrelic_create_app(). The call to newrelic_create_app() is non-blocking. Its second parameter allows you to specify an amount of time for your instrumented application to wait so that the socket communication is adequately established. For example: newrelic_app_t* app = newrelic_create_app(config, 10000); Copy If your instrumented application sends transactions before both the daemon connection and your application's socket communication are established, data reported from your application will be lost. Get started with the C SDK To use our C SDK agent: Make sure your application meets the compatibility and requirements for the C SDK. If you do not already have one, sign up for a free New Relic account. Use our launcher, or follow the installation and instrumentation procedures to install the agent. Within a few minutes, you will be able to view data from your application in your New Relic account's UI. Read the install docs Add C data Check the source code The C SDK is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.94696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the C SDK",
        "sections": "Introduction <em>to</em> the C SDK",
        "body": " library and daemon The C SDK relies on two <em>components</em> to send data from <em>your</em> <em>application</em> to New Relic: The lC SDK calls: You download this library, then <em>add</em> the calls and instrumentation to <em>your</em> <em>application</em>&#x27;s code. This allows you to identify and customize the kinds of data that matters the most to you"
      },
      "id": "6043f78fe7b9d2ae4e5799fc"
    }
  ],
  "/build-apps/ab-test/nrql": [
    {
      "image": "https://developer.newrelic.com/static/39196df35b3f160bf0ac9eeab116b112/ba3ac/real-table-chart-data.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:50:30Z",
      "title": "Customize NRQL data",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "52491e06cfe78faf65a628e3a553720f3ce4d318",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize NRQL data",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 520.6523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize <em>NRQL</em> data",
        "sections": "Customize <em>NRQL</em> data",
        "info": "Customize <em>NRQL</em> data",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>NrqlQuery</em> <em>components</em>"
      },
      "id": "6091faf228ccbcbadfa268f9"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-07-30T01:54:32Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 391.64868,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure <em>your</em> custom visualization",
        "sections": "Configure <em>your</em> custom visualization",
        "info": "Configure <em>your</em> custom visualization",
        "body": "} data={data} &gt; &lt;RadialBar background dataKey=&#x27;val&#x27; &#x2F;&gt; &lt;Legend layout=&#x27;vertical&#x27; verticalAlign=&#x27;middle&#x27; align=&quot;right&quot; iconType={iconType} &#x2F;&gt; &lt;&#x2F;RadialBarChart&gt; ) } } index.js Copy <em>nrql</em> A <em>nrql</em> property is rendered in the UI as a text box and represents a <em>NRQL</em> <em>query</em>. You can use the <em>NrqlQuery</em> component"
      },
      "id": "6091fa3a64441fa2172f3714"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-07-30T01:51:41Z",
      "title": "Present an end test confirmation modal",
      "updated_at": "2021-05-05T01:54:59Z",
      "type": "developer",
      "external_id": "d304e6d4f2b5f3ca8465df20913b58f4360652d7",
      "document_type": "page",
      "popularity": 1,
      "info": "Present an end test confirmation modal",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. The modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.28482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Show and hide <em>your</em> confirmation modal",
        "body": " lesson, you&#x27;ll replace the mocked data in <em>your</em> charts with real data from <em>your</em> backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>NrqlQuery</em> <em>components</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091faf428ccbcbe03a268f3"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:08Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.28442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " }) =&gt; { return &lt;LineChart data={data} fullWidth &#x2F;&gt;; } } &lt;&#x2F;<em>NrqlQuery</em>&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js Copy Important Make sure you replace &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; with <em>your</em> actual New Relic account ID. Notice that <em>NrqlQuery</em> uses"
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.65765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": "} &gt; { ({ data }) =&gt; { return &lt;LineChart data={data} fullWidth &#x2F;&gt;; } } &lt;&#x2F;<em>NrqlQuery</em>&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js Copy Important Make sure you replace &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; and &lt;<em>YOUR</em> NEW RELIC ENTITY GUID&gt; with <em>your</em> actual New Relic"
      },
      "id": "6091faf128ccbcb641a268f9"
    }
  ],
  "/build-apps/add-visualizations-to-dashboard": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 606.11865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 413.19638,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build your first custom <em>visualization</em>",
        "sections": "Build your first custom <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>One</em> <em>catalog</em> Add your visualization to a dashboard Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create a new visualization Use <em>nr1</em> to generate the boilerplate for a new visualization"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with configuration options",
        "Course",
        "Tip",
        "Add a new configuration option",
        "Replace your SegmentedControl with the configurable property",
        "Summary"
      ],
      "title": "Customize your visualization with configuration options",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9028e58f383ea362d2c9d3a7ecd6404dbfeac87c",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/customize-visualizations-with-configuration/",
      "published_at": "2021-07-30T01:48:12Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization using configuration",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Custom visualizations and the New Relic One SDK, before starting this one. In the previous lesson, you built a custom visualization that shows queried data in one of two chart types: RadarChart Treemap You used a SegmentedControl to switch between the two chart types in the visualization UI. This implementation takes up space in the visualization, but it offers your users the choice to switch between two chart types even after you've created an instance of your chart. But what if you only need to be able to select an option once, when initializing the visualization? In this lesson you'll learn how to add a configuration option to your visualization which replaces the SegmentedControl. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Add a new configuration option Step 1 of 8 In your visualization's nr1.json file, add an enum configuration object for selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve If you're still serving your Nerdpack from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to nr1.json. Step 4 of 8 Go to https://one.newrelic.com/?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from the local server. Step 5 of 8 Open the Apps page: Step 6 of 8 Go to Custom Visualizations, which is favorited by default: Step 7 of 8 In Custom Visualizations, find and click your visualization: Step 8 of 8 Notice the new Select chart configuration option: Selecting a chart type doesn't effect your visualization. This is because you first need to introduce the selectedChart property to the visualization component. Then, you use selectedChart to determine the chart type to render. Replace your SegmentedControl with the configurable property Step 1 of 5 Open your visualization's index.js file. You'll be working here for the rest of the guide. Step 2 of 5 In render(), include selectedChart as a constant you get from destructuring props, and remove your component's state: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now that you're using selectedChart from the configuration options instead of component state, you can select a chart in the configuration panel and watch the visualization change. Unfortunately, there's a bug. The default chart option is Radar, but the initial render shows a Treemap. Step 3 of 5 Update your ternary expression to account for the case where there is no selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now, your data is rendered in a RadarChart if you haven't yet configured the option. Step 4 of 5 Remove SegmentedControl from render(): index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 Spinner, 18 } from 'nr1'; 19 20 const CHART_TYPES = { 21 'Radar': 'radar', 22 'Treemap': 'treemap' 23 } 24 25 export default class RadarOrTreemapVisualization extends React.Component { 26 // Custom props you wish to be configurable in the UI must also be defined in 27 // the nr1.json file for the visualization. See docs for more details. 28 static propTypes = { 29 /** 30 * A fill color to override the default fill color. This is an example of 31 * a custom chart configuration. 32 */ 33 fill: PropTypes.string, 34 35 /** 36 * A stroke color to override the default stroke color. This is an example of 37 * a custom chart configuration. 38 */ 39 stroke: PropTypes.string, 40 /** 41 * An array of objects consisting of a nrql `query` and `accountId`. 42 * This should be a standard prop for any NRQL based visualizations. 43 */ 44 nrqlQueries: PropTypes.arrayOf( 45 PropTypes.shape({ 46 accountId: PropTypes.number, 47 query: PropTypes.string, 48 }) 49 ), 50 }; 51 52 /** 53 * Restructure the data for a non-time-series, facet-based NRQL query into a 54 * form accepted by the Recharts library's RadarChart. 55 * (https://recharts.org/api/RadarChart). 56 */ 57 transformData = (rawData) => { 58 return rawData.map((entry) => ({ 59 name: entry.metadata.name, 60 // Only grabbing the first data value because this is not time-series data. 61 value: entry.data[0].y, 62 })); 63 }; 64 65 /** 66 * Format the given axis tick's numeric value into a string for display. 67 */ 68 formatTick = (value) => { 69 return value.toLocaleString(); 70 }; 71 72 render() { 73 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 74 75 const nrqlQueryPropsAvailable = 76 nrqlQueries && 77 nrqlQueries[0] && 78 nrqlQueries[0].accountId && 79 nrqlQueries[0].query; 80 81 if (!nrqlQueryPropsAvailable) { 82 return <EmptyState />; 83 } 84 85 return ( 86 <AutoSizer> 87 {({width, height}) => ( 88 <NrqlQuery 89 query={nrqlQueries[0].query} 90 accountId={parseInt(nrqlQueries[0].accountId)} 91 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 92 > 93 {({data, loading, error}) => { 94 if (loading) { 95 return <Spinner />; 96 } 97 98 if (error) { 99 return <ErrorState />; 100 } 101 102 const transformedData = this.transformData(data); 103 104 return ( 105 <React.Fragment> 106 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 107 <RadarChart 108 width={width} 109 height={height} 110 data={transformedData} 111 > 112 <PolarGrid /> 113 <PolarAngleAxis dataKey=\"name\" /> 114 <PolarRadiusAxis tickFormatter={this.formatTick} /> 115 <Radar 116 dataKey=\"value\" 117 stroke={stroke || '#51C9B7'} 118 fill={fill || '#51C9B7'} 119 fillOpacity={0.6} 120 /> 121 </RadarChart> 122 ) : ( 123 <Treemap 124 width={width} 125 height={height} 126 data={transformedData} 127 dataKey=\"value\" 128 ratio={4 / 3} 129 stroke={stroke || '#000000'} 130 fill={fill || '#51C9B7'} 131 /> 132 )} 133 </React.Fragment> 134 ); 135 }} 136 </NrqlQuery> 137 )} 138 </AutoSizer> 139 ); 140 } 141 } 142 143 const EmptyState = () => ( 144 <Card className=\"EmptyState\"> 145 <CardBody className=\"EmptyState-cardBody\"> 146 <HeadingText 147 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 148 type={HeadingText.TYPE.HEADING_3} 149 > 150 Please provide at least one NRQL query & account ID pair 151 </HeadingText> 152 <HeadingText 153 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 154 type={HeadingText.TYPE.HEADING_4} 155 > 156 An example NRQL query you can try is: 157 </HeadingText> 158 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 159 </CardBody> 160 </Card> 161 ); 162 163 const ErrorState = () => ( 164 <Card className=\"ErrorState\"> 165 <CardBody className=\"ErrorState-cardBody\"> 166 <HeadingText 167 className=\"ErrorState-headingText\" 168 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 169 type={HeadingText.TYPE.HEADING_3} 170 > 171 Oops! Something went wrong. 172 </HeadingText> 173 </CardBody> 174 </Card> 175 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 5 of 5 Serve your Nerdpack locally, and view it in the Custom Visualizations app in New Relic. Select a chart type from the dropdown in the configuration sidebar, and see your visualization update to show the matching chart type: Summary Congratulations on completing this lesson! You've learned how to customize your visualization using nr1.json configuration. Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Add custom visualizations to your dashboards.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 411.1544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with configuration options",
        "sections": "Customize your <em>visualization</em> with configuration options",
        "info": "Customize your <em>visualization</em> using configuration",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": "&quot;: &quot;Stroke color&quot;, 51 &quot;description&quot;: &quot;A stroke color to override the default stroke color&quot;, 52 &quot;type&quot;: &quot;string&quot; 53 } 54 ] 55 } <em>visualizations</em>&#x2F;radar-or-treemap&#x2F;<em>nr1</em>.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ <em>nr1</em>"
      },
      "id": "6091fa3ae7b9d2df595068c1"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-07-30T01:48:13Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.5924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with SDK components",
        "sections": "Customize your <em>visualization</em> with SDK components",
        "info": "Customize your <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create your visualization Step <em>1</em> of 2 Ensure you&#x27;re working with the latest version of the New Relic <em>One</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.25946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Most of the time, the <em>nr1</em> <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, Nerdlets, launchers, and <em>visualizations</em> without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    }
  ],
  "/explore-docs/custom-viz": [
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-07-30T01:54:32Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 315.14453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure your <em>custom</em> <em>visualization</em>",
        "sections": "Configure your <em>custom</em> <em>visualization</em>",
        "info": "Configure your <em>custom</em> <em>visualization</em>",
        "body": ": <em>Nerdpack</em> items all have <em>nr1</em>.json metadata files. The schemaType describes the item&#x27;s schema. For all <em>visualizations</em>, schemaType is VISUALIZATION. id: Your visualization&#x27;s string identifier. This must be unique within a given <em>Nerdpack</em>, but it doesn&#x27;t need to be unique across all Nerdpacks. displayName"
      },
      "id": "6091fa3a64441fa2172f3714"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.21976,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " the New Relic One CLI, before starting this one. A <em>Nerdpack</em> is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a <em>Nerdpack</em>, use the New Relic One CLI: bash Copy $ <em>nr1</em> create --type"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nr1</em> cli",
        "body": " is up-to-date: bash Copy $ <em>nr1</em> update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your <em>Nerdpack</em>. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.92294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your <em>custom</em> <em>visualization</em> to a dashboard",
        "sections": "Add your <em>custom</em> <em>visualization</em> to a dashboard",
        "info": "Add your <em>custom</em> <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>nr1</em> cli",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your <em>custom</em> visualization to a dashboard Step <em>1</em> of 7 From the root directory of your <em>Nerdpack</em>, publish and subscribe to your visualization: bash Copy $ <em>nr1</em> <em>nerdpack</em>:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-07-30T01:44:15Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.27786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " use a Nerdlet in a <em>Nerdpack</em>, you&#x27;re never able to use <em>custom</em> <em>visualizations</em>. For this, you must be upgraded to a full user. Full users If you&#x27;re a full user in the original user model, you either: Have the <em>Nerdpack</em> Manager add-on role Don&#x27;t have the <em>Nerdpack</em> Manager add-on role The <em>Nerdpack</em> Manager"
      },
      "id": "6091fa39196a67a39ed52a4f"
    }
  ],
  "/explore-docs/custom-viz/configuration-options": [
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 441.76715,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>your</em> first <em>custom</em> <em>visualization</em>",
        "sections": "Build <em>your</em> first <em>custom</em> <em>visualization</em>",
        "info": "Create a <em>custom</em> data view and add it to a dashboard",
        "tags": "Subscribe <em>visualizations</em>",
        "body": " for <em>your</em> <em>visualization</em>. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the <em>Configure</em> <em>your</em> <em>custom</em> <em>visualization</em> article. index.js defines the React component that receives"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "image": "https://developer.newrelic.com/static/3ed141add1fead9eec2fce6cc5dec70e/0086b/nerdgraph-create-dashboard-with-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/add-to-dashboard-nerdgraph/",
      "sections": [
        "Add your custom visualization to a dashboard with NerdGraph",
        "Before you begin",
        "Create and publish your Nerdpack",
        "Further reading",
        "Describe your visualization options with JSON",
        "Tip",
        "Create a new dashboard with your visualization",
        "Important",
        "Add your visualization to an existing dashboard",
        "Send your request to NerdGraph",
        "NerdGraph API explorer",
        "Explore",
        "cURL",
        "New Relic CLI",
        "View your new dashboard",
        "Summary"
      ],
      "published_at": "2021-07-30T01:59:44Z",
      "title": "Add your custom visualization to a dashboard with NerdGraph",
      "updated_at": "2021-05-14T01:52:47Z",
      "type": "developer",
      "external_id": "c1743c0bb9cb85cc6802bc32616495fddb281e8b",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a dashboard with NerdGraph",
      "body": "Add your custom visualization to a new or existing dashboard, programmatically, with New Relic's GraphQL API, NerdGraph. Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the first four steps in the nr1 quick start to install and configure the CLI Create and publish your Nerdpack Create a Nerdpack with a visualization. You'll add this visualization to a dashboard using NerdGraph. Further reading Because this guide is about using visualizations, not creating and publishing them, it breezes over these topics. If you're unfamiliar with visualizations or would like a thorough explanation of dealing with visualization Nerdpacks, check out the following resources: Introduction to custom visualizations Build your first custom visualization If you already have a visualization you'd like to add to a dashboard, you can skip this section. But don't forget to make the necessary code adjustments to reference your visualization instead of the one this guide uses, called my-awesome-visualization. Step 1 of 4 Update your nr1 CLI: bash Copy $ nr1 update Now, you have the latest version. Step 2 of 4 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create -t visualization -n my-awesome-visualization ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" When you build a visualization with nr1 create, you get a default visualization. You'll use this default visualization throughout this course. Step 3 of 4 Navigate to your new Nerdpack: bash Copy $ cd my-awesome-nerdpack From here, you can run nr1 nerdpack commands. Step 4 of 4 Publish and subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Now, that your account is subscribed to your visualization, you can describe your app configurations with JSON and add it to a dashboard with NerdGraph. Describe your visualization options with JSON Whether you're adding your visualization to a new dashboard or an existing one, you need to send your configuration to NerdGraph. Your custom visualization JSON object represents a dashboard widget and consists of the following fields: Field Type Description title String Title for your dashboard widget visualization JSON The metadata for your visualization visualization.id String Your visualization's ID rawConfiguration JSON A full configuration of your widget Tip You can also add other types of widgets to dashboards with the steps in this guide, but the fields described here are specific to custom visualization widgets. For other widget types, you need to supply different data. Explore the API on your own with our NerdGraph explorer! Step 1 of 5 Start with a JSON template based on the fields you need to describe your custom visualization: { \"title\": \"\", \"visualization\": { \"id\": \"\" }, \"rawConfiguration\": {} } Copy Step 2 of 5 Give your visualization widget a title: { \"title\": \"My Awesome Visualization\", \"visualization\": { \"id\": \"\" }, \"rawConfiguration\": {} } Copy Step 3 of 5 Look up your Nerdpack ID from my-awesome-nerdpack/nr1.json: { \"schemaType\": \"NERDPACK\", \"id\": \"ab123c45-678d-9012-efg3-45hi6jkl7890\", \"displayName\": \"MyAwesomeNerdpack\", \"description\": \"Nerdpack my-awesome-nerdpack\" } my-awesome-nerdpack/nr1.json Copy Then, look up your visualization ID from my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json: { \"schemaType\": \"VISUALIZATION\", \"id\": \"my-awesome-visualization\", \"displayName\": \"MyAwesomeVisualization\", \"description\": \"\", \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"account-id\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] } my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json Copy Set your visualization widget's visualization.id to the form {NERDPACK-ID}.{VISUALIZATION-ID}: { \"title\": \"My Awesome Visualization\", \"visualization\": { \"id\": \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, \"rawConfiguration\": {} } Copy Step 4 of 5 In my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json, review your configuration options: { \"schemaType\": \"VISUALIZATION\", \"id\": \"my-awesome-visualization\", \"displayName\": \"MyAwesomeVisualization\", \"description\": \"\", \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"account-id\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] } my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json Copy The name fields in configuration are important for describing your visualization widget. Step 5 of 5 Using the name field for every configuration object in your visualization's nr1.json file, build a rawConfiguration for your widget: { \"title\": \"My Awesome Visualization\", \"visualization\": { \"id\": \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, \"rawConfiguration\": { \"nrqlQueries\": [ { \"accountId\": 1234567, \"query\": \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], \"fill\": \"pink\", \"stroke\": \"green\" } } Copy Here, you've created a rawConfiguration by supplying values for each configuration option in nr1.json. Note that nrqlQueries is an array because its type is collection. The other values are strings. Learn more about these configuration options in Configure your custom visualization. Now that you've described your visualization widget in JSON, you can add your configured visualization to a dashboard. In the next section, you'll learn how to create a new dashboard with your visualization. If you already have one ready, skip ahead to add your visualization to your existing dashboard. Create a new dashboard with your visualization If you want to create a new dashboard for your visualization widget, use NerdGraph's dashboardCreate() mutation. The NerdGraph dashboardCreate() mutation takes the following fields: Field Type Description accountId Integer The ID for the account for which you want to create your dashboard dashboard JSON The details of the dashboard you're creating dashboard.name String The name of your dashboard dashboard.permissions Enum: PRIVATE, PUBLIC_READ_ONLY, PUBLIC_READ_WRITE The access control of your dashboard dashboard.pages Array: JSON The details of your dashboard's pages dashboard.pages[].name String The name of the dashboard page dashboard.pages[].widgets Array: JSON The widgets to add to the dashboard page Tip You can also pass more fields to dashboardCreate() to add details, widgets, and more. Explore the API on your own with our NerdGraph explorer! In this guide, you create a dashboard with a single page that contains a single widget—the visualization widget you described in the last section. Step 1 of 5 Build out a GraphQL mutation template based on the fields you need to describe your dashboard in dashboardCreate(): mutation { dashboardCreate( accountId: 0, dashboard: { name: \"\", pages: [ { name: \"\", widgets: [] }, ], permissions: PRIVATE } ) } Copy Here, you've defined the template for a private dashboard. Now, it's time to fill in the details. Step 2 of 5 Look up your account ID and enter it for your accountId: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"\", pages: [ { name: \"\", widgets: [] }, ], permissions: PRIVATE } ) } Copy Step 3 of 5 Select a name for your dashboard and its page: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"My Awesome Dashboard\", pages: [ { name: \"One Page to Rule Them All\", widgets: [] }, ], permissions: PRIVATE } ) } Copy Step 4 of 5 In widgets, place the widget object you created in the last section: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"My Awesome Dashboard\", pages: [ { name: \"One Page to Rule Them All\", widgets: [ { title: \"My Awesome Visualization\", visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } } ] }, ], permissions: PRIVATE } ) } Copy Step 5 of 5 Finally, add the return fields to your mutation: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"My Awesome Dashboard\", pages: [ { name: \"One Page to Rule Them All\", widgets: [ { title: \"My Awesome Visualization\", visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } } ] }, ], permissions: PRIVATE } ) { entityResult { guid } } } Copy Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. Now, you have a mutation ready to send to NerdGraph to create single-page dashboard with a widget for your custom visualization. As a result, you'll see the new dashboard's entity GUID. In the next section, you'll learn how to add your visualization to an existing dashboard. If that's not relevant to your goals, skip ahead to send your request to NerdGraph. Add your visualization to an existing dashboard To add your visualization widget to an existing dashboard, use NerdGraph's dashboardAddWidgetsToPage() mutation. The NerdGraph dashboardAddWidgetsToPage() mutation takes the following fields: Field Type Description guid String The entity GUID for the dashboard to which you're adding your widgets widgets Array: JSON The widgets to add to the dashboard page Tip You can also pass more fields to dashboardAddWidgetsToPage() to add details, widgets, and more. Explore the API on your own with our NerdGraph explorer! Step 1 of 4 Build out a GraphQL mutation template based on the fields you need to describe your dashboard in dashboardAddWidgetsToPage(): mutation { dashboardAddWidgetsToPage( guid: \"\" widgets: [] ) { errors { description } } } Copy Step 2 of 4 Look up your dashboard's GUID and enter it for guid: mutation { dashboardAddWidgetsToPage( guid: \"AbCdEFghIJkLMNo1PQRSTUVWXYZAbCD2Ef34GHI\" widgets: [] ) { errors { description } } } Copy Step 3 of 4 In widgets, place the widget object you created in Describe your visualization options with JSON: mutation { dashboardAddWidgetsToPage( guid: \"AbCdEFghIJkLMNo1PQRSTUVWXYZAbCD2Ef34GHI\" widgets: [ { visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } }, ] ) } Copy Step 4 of 4 Finally, add the return fields to your mutation: mutation { dashboardAddWidgetsToPage( guid: \"AbCdEFghIJkLMNo1PQRSTUVWXYZAbCD2Ef34GHI\" widgets: [ { visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } }, ] ) { errors { description } } } Copy Now, you have a mutation ready to send to NerdGraph to add your custom visualization to an existing dashboard. As a result, you'll see descriptions of any thrown errors to help you debug issues. The last thing you need to do is actually send your request to NerdGraph. Send your request to NerdGraph Send an HTTP request to NerdGraph with the payload you built in previous sections for the mutation that best suits your needs. There are many tools you can use to send an HTTP request, but in this guide, you learn how to communicate with NerdGraph using three specific tools: NerdGraph API explorer cURL New Relic CLI If you use another, you can adapt these methods for your favorite development tool. NerdGraph API explorer The NerdGraph API explorer is an implementation of GraphiQL that lets you explore the NerdGraph APIs. Step 1 of 4 Go to the NerdGraph API explorer. Step 2 of 4 Select or create a new API key: Step 3 of 4 In the center console, paste your mutation query: Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. Step 4 of 4 Press Execute Query and see the results in the right pane: If you successfully created a new dashboard, your response has an entity GUID. If you don't have an entity GUID, the response contains error messages to help you debug your query. If you added your visualization to an existing dashboard, you won't see errors in the response. If you do see error messages, use them to debug your query. Explore The NerdGraph API explorer lets you see other fields and change your query without typing everything manually. Use the left pane to explore NerdGraph. cURL cURL is a command line utility for making HTTP requests. Step 1 of 2 Select or create a New Relic user key. Copy this key, because you use it in the next step. Step 2 of 2 Make a request to NerdGraph, using cURL: bash Copy $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: <YOUR-USER-KEY>' \\ > --data-binary '{\"query\": \"mutation {dashboardCreate(dashboard: {name: \\\"My Awesome Dashboard\\\", pages: [{name: \\\"One Page to Rule Them All\\\", widgets: [{title: \\\"My Awesome Visualization\\\", visualization: {id: \\\"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\\\"}, rawConfiguration: {nrqlQueries: [{accountId: 3014918, query: \\\"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\\\"}], fill: \\\"pink\\\", stroke: \\\"green\\\"}}]}], permissions: PRIVATE}, accountId: <YOUR-ACCOUNT-ID>) { entityResult { guid }}}\", \"variables\": \"\"}' Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. Here, you send a request to NerdGraph that has two headers, Content-Type and API-Key, and a binary message body containing one of the mutation queries you built in previous sections. If you prefer to use a UI-based client, like Postman, you can adapt this method to a format that your client supports. New Relic CLI The newrelic is a command line interface for reading and writing New Relic data. Step 1 of 2 If you haven't already, install newrelic by following the first two steps of our Get started with the New Relic CLI guide. Once you've done that, you will have newrelic installed and configured for making NerdGraph requests. Step 2 of 2 Make a NerdGraph request using newrelic nerdgraph query: bash Copy $ newrelic nerdgraph query 'mutation { $ dashboardCreate( $ accountId: 1234567, $ dashboard: { $ name: \"My Awesome Dashboard\", $ pages: [ $ { $ name: \"One Page to Rule Them All\", $ widgets: [ $ { $ title: \"My Awesome Visualization\", $ visualization: { $ id: \"de0b4768-1504-4818-a898-da7cd14f0bfb.my-awesome-visualization\" $ }, $ rawConfiguration: { $ nrqlQueries: [ $ { $ accountId: <YOUR-ACCOUNT-ID>, $ query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" $ } $ ], $ fill: \"pink\", $ stroke: \"green\" $ } $ } $ ] $ }, $ ], $ permissions: PRIVATE $ } $ ) { $ entityResult { $ guid $ } $ } $ }' Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. View your new dashboard Now that you've built a dashboard with NerdGraph, it's time to check your work! Step 1 of 4 Go to New Relic. Step 2 of 4 Navigate to Dashboards: Step 3 of 4 Select your new dashboard: Step 4 of 4 View your dashboard: The dashboard you created has the name you passed in your mutation, \"My Awesome Dashboard\". It also has the configuration you sent in rawConfiguration, from the NRQL data query to the fill and stroke colors. Summary Congratulations! In this guide, you used NerdGraph, New Relic's GraphQL API, to add your custom visualization to a dashboard.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 349.51846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard with NerdGraph",
        "sections": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard with NerdGraph",
        "info": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard with NerdGraph",
        "body": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a new or existing dashboard, programmatically, with New Relic&#x27;s GraphQL API, NerdGraph. Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the first four steps in the nr1 quick start to install and <em>configure</em> the CLI"
      },
      "id": "609dd7f0e7b9d2ae61c3eb13"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.02156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>custom</em> <em>visualizations</em>",
        "sections": "Build <em>your</em> <em>custom</em> <em>visualization</em>",
        "info": "Introduction to <em>custom</em> <em>visualizations</em>",
        "tags": "<em>custom</em> <em>visualizations</em>",
        "body": " (Documentation) Customize visualizations with configuration (Guide) Configuring <em>custom</em> visualizations for dashboards (Video) Use <em>your</em> <em>custom</em> <em>visualization</em> During development, you can serve <em>your</em> <em>visualization</em> locally. Under Apps &gt; <em>Custom</em> Visualizations, you can view and <em>configure</em> <em>your</em> <em>visualization</em>"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.18771,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> <em>your</em> <em>visualization</em> with <em>configuration</em> options",
        "body": " 20 min Add a time picker to a sample application Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard 10 min Add <em>your</em> <em>custom</em> <em>visualization</em> to a New Relic dashboard Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack Attach <em>your</em> Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.25679,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a <em>custom</em> New Relic One application ",
        "sections": "Build a <em>custom</em> New Relic One application",
        "body": " a highly detailed analysis of a website, using the PageView events reported from New Relic&#x27;s browser monitoring. Tip If <em>your</em> <em>visualization</em> needs are relatively simple, consider using <em>custom</em> charts and <em>custom</em> dashboards. Now, visit our developer site and start building!"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/advanced-config": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 6237.5425,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Enable</em> <em>advanced</em> <em>configurations</em> <em>for</em> <em>your</em> <em>Nerdpack</em>",
        "body": " 20 min Add a time picker to a sample application Add <em>your</em> custom visualization to a dashboard 10 min Add <em>your</em> custom visualization to a New Relic dashboard <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>   <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em> Attach <em>your</em> Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 4167.1953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Advanced</em> <em>configurations</em>",
        "tags": "<em>Nerdpack</em> file structure",
        "body": " is up-to-date: bash Copy $ nr1 update For additional details about setting up <em>your</em> environment, see Set up <em>your</em> development environment and <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build <em>your</em> apps. Create"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1070.5575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>your</em> first custom visualization",
        "sections": "Build <em>your</em> first custom visualization",
        "body": " <em>configurations</em> in <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>. As a result, you have a new visualizations&#x2F;my-awesome-visualization directory in my-awesome-<em>nerdpack</em>: bash Copy $ ls my-awesome-<em>nerdpack</em>&#x2F;visualizations&#x2F;my-awesome-visualization index.js nr1.json styles.scss The top-level"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-07-30T01:48:13Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.2217,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize <em>your</em> visualization with SDK components",
        "sections": "Customize <em>your</em> visualization with SDK components",
        "info": "Customize <em>your</em> visualization",
        "body": " this and other <em>advanced</em> <em>configurations</em> in <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>. As a result, you have a new visualizations&#x2F;radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations&#x2F;radar-or-treemap index.js nr1.json styles.scss Set up <em>your</em> component"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-07-27T11:20:18Z",
      "updated_at": "2021-07-27T11:20:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.3779,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install New Relic Java agent <em>for</em> Docker",
        "sections": "Set agent <em>configurations</em>",
        "body": " where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and <em>enable</em> it in others Although we don&#x27;t discuss <em>advanced</em> options here, you can install the Java agent"
      },
      "id": "603ea3dc28ccbc8889eba765"
    }
  ],
  "/build-apps/publish-deploy/serve": [
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-07-30T01:44:15Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.37042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user <em>Serve</em> Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Subscribe to a Nerdpack",
        "Tag your Nerdpack's release version"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-07-27T01:40:22Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Subscribe to a Nerdpack   Subscribe to a Nerdpack Tag your Nerdpack's release version   Tag your Nerdpack's release version",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.9858,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Serve</em>, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "<em>Serve</em>, publish, and subscribe to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to <em>serve</em>, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to <em>serve</em>, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.84236,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " contains a default component to help you get started. <em>Serve</em> your visualization locally: bash Copy $ cd my-first-viz $ nr1 <em>nerdpack:serve</em> Open the link to your visualization that&#x27;s shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https:&#x2F;&#x2F;one.nr&#x2F;012ab3cd4Ef"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.82672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " arrow-keys. Return to submit. <em>nerdpack</em> ❯ nerdlet - create a&#x2F;an Nerdlet <em>Nerdpack</em> item inside your <em>Nerdpack</em>. launcher catalog visualization In the next lesson, you&#x27;ll learn how to <em>serve</em> your <em>Nerdpack</em> locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Serve</em> your New Relic One application."
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-07-30T01:54:32Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.45973,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", but unlike index.js your locally served visualization requires a restart to see its changes. So, if you&#x27;re serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 <em>nerdpack:serve</em> If your visualization is already published, you need to update your <em>Nerdpack</em>&#x27;s version in package.json and publish and subscribe to the new version: bash Copy $ nr1 <em>nerdpack</em>:publish $ nr1 <em>nerdpack</em>:subscribe"
      },
      "id": "6091fa3a64441fa2172f3714"
    }
  ],
  "/ab-test": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.35762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>a</em> Nerdpack",
        "sections": "Create <em>a</em> Nerdpack",
        "info": "Create <em>a</em> Nerdpack",
        "body": "&#x27;s displayName to &quot;A&#x2F;<em>B</em> <em>Test</em>&quot; and set the description to &quot;A&#x2F;<em>B</em> <em>test</em> your <em>application</em> using New Relic One&quot;: { &quot;schemaType&quot;: &quot;NERDPACK&quot;, &quot;id&quot;: &quot;311bcd0c-f7eb-4285-afed-4219179bf91d&quot;, &quot;displayName&quot;: &quot;A&#x2F;<em>B</em> <em>Test</em>&quot;, &quot;description&quot;: &quot;A&#x2F;<em>B</em> <em>test</em> your <em>application</em> using New Relic One.&quot; } nr1.json Copy It&#x27;s good to describe"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-07-27T13:37:35Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.72472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Build</em> <em>a</em> custom New Relic One <em>application</em> ",
        "sections": "<em>Build</em> <em>a</em> custom New Relic One <em>application</em>",
        "tags": "<em>Build</em> on New Relic One",
        "body": " to <em>build</em> New Relic One, you can <em>build</em> custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an <em>application</em> will take you only a few minutes. Check out these guides for help building"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Automated user management: SCIM API",
        "Requirements",
        "SCIM service provider",
        "Authentication",
        "Supported resources",
        "Schemas",
        "Supported actions",
        "Create group",
        "Get group",
        "Get group by query",
        "Update group with PUT",
        "Update group with PATCH (Non-member fields)",
        "Update group with PATCH (Add members)",
        "Update group with PATCH (Remove members)",
        "Delete group",
        "Create user",
        "Get user",
        "Get user by query",
        "Update user with PUT",
        "Update user with PATCH",
        "Delete user",
        "Deviations from the RFC",
        "Next steps when you're done",
        "Downgrade users",
        "Assign access grants"
      ],
      "title": "Automated user management: SCIM API",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "Automated user management"
      ],
      "external_id": "9e7992bec73759ba6c820721101618de28859b33",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/automated-user-management/scim-support-automated-user-management/",
      "published_at": "2021-07-27T06:21:55Z",
      "updated_at": "2021-07-27T06:21:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to implement New Relic's automated user management (AUM) and import your users from an identity provider, first read Introduction to AUM to learn about supported identity providers and when you'd want to use our SCIM API, documented below. Requirements Before using our SCIM API, you must first enable SCIM for an authentication domain. Note that after you enable SCIM, there are necessary next steps to do, including downgrading some users to basic users, and granting user groups access to New Relic accounts. SCIM service provider New Relic’s SCIM service provider follows the SCIM 2.0 API as described in RFCs 7643 and 7644. You do not need to implement all aspects of the SCIM 2.0 specification to integrate your user information with New Relic. In fact, the New Relic service provider itself does not implement all aspects of the specification. This document describes the features from the specification available for an integration with New Relic. Authentication Authentication is done using a bearer token. This bearer token is specific to your New Relic authentication domain. Supported resources The New Relic service provider supports the following SCIM resources: Group , User , Service provider config , Resource type and Schema. Bulk and Search are not supported. For more information on how the RFC describes the resource endpoints, see RFC 7644 SCIM Protocol Specification. Schemas New Relic uses a subset of the available fields in the SCIM core schema. Other SCIM fields are ignored if they are included in incoming requests. The fields used by New Relic are: Group: SCIM Field Name Description displayName Required. Name of the group. members List of users in the group. User: SCIM Field Name Description externalId Unique identifier for the user used by your system. userName Required. Unique identifier for the user within New Relic’s system. Use the user’s email address. name.familyName Last name of the user. name.givenName First name of the user. emails or emails.value Required. Email address of the user. timezone Time zone of the user in IANA Time Zone database format, also known as the \"Olson\" time zone database format (e.g., \"America/Los_Angeles\"). active Required. Boolean indicating whether or not the user should be active or inactive within New Relic. groups List of groups to which the user belongs. Supported actions SCIM provides several options for manipulating groups and users. The New Relic service provider supports the following options. When configuring, be aware that: Only simple filtering is supported. The eq operator may be used with a basic filter expression. For example, “displayName eq \"Example Group 1”. Other operators are not supported. PUT updates do not require that all fields be included. Fields that are not included will not be changed. When doing a PUT, if a required field already has the appropriate value, it is not necessary to include the field. Supported actions are: Create group Example request: POST /Groups { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"displayName\": \"Example Group 1\", \"members\": [] } Copy Example response: 201 Created { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T21:33:13.055Z\" }, \"members\": [] } Copy Get group Example request: GET /Groups/YOUR_GROUP_ID Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T21:33:13.055Z\" }, \"members\": [] } Copy Get group by query Example request: GET /Groups?filter=displayName eq \"Example Group 1\" Copy Example response: 200 OK { \"totalResults\": 1, \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:ListResponse\" ], \"Resources\": [{ \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T21:33:13.055Z\" }, \"members\": [] }] } Copy Update group with PUT In the request, include the fields that you want to change. If you include the members field, the group’s users will be adjusted to match the contents of the members field. Example request: PUT /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"displayName\": \"Example Group 1a\" } Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:Group\" ], \"id\": \"d0652232-b14f-434d-9c6f-36de7e1ab010\", \"displayName\": \"Example Group 1a\", \"meta\": { \"resourceType\": \"Group\", \"created\": \"2019-11-08T21:33:13.055Z\", \"lastModified\": \"2019-11-08T22:47:14.019Z\" }, \"members\": [] } Copy Update group with PATCH (Non-member fields) Example request: PATCH /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Replace\", \"path\": \"displayName\", \"value\": \"Example Group 1b\" }] } Copy Example response: 204 No Content Copy Update group with PATCH (Add members) Example request: PATCH /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Add\", \"path\": \"members\", \"value\": [{ \"value\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\" }] }] } Copy Example response: 204 No Content Copy Update group with PATCH (Remove members) Example request: PATCH /Groups/YOUR_GROUP_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Remove\", \"path\": \"members\", \"value\": [{ \"value\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\" }] }] } Copy Example response: 204 No Content Copy Delete group Example request: DELETE /Groups/YOUR_GROUP_ID Copy Example response: 204 No Content Copy Create user Example request: POST /Users { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"groups\": [] } Copy Example response: 201 Created { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:07:12.477Z\" }, \"groups\": [] } Copy Get user Example request: GET /Users/YOUR_USER_ID Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:07:12.477Z\" }, \"groups\": [] } Copy Get user by query Example request: GET /Users?filter=externalId eq \"external-id-1\" Copy Example response: 200 OK { \"totalResults\": 1, \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:ListResponse\" ], \"Resources\": [{ \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:07:12.477Z\" }, \"groups\": [] }] } Copy Update user with PUT In the request, include the fields that you want to change. If you include the groups field, the user’s groups will be adjusted to match the contents of the groups field. Example request: PUT /Users/YOUR_USER_ID { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"name\": { \"familyName\": \"User 1A\", \"givenName\": \"Example\" } } Copy Example response: 200 OK { \"schemas\": [ \"urn:ietf:params:scim:schemas:core:2.0:User\" ], \"id\": \"f0cbc276-16c9-4d1a-abc0-1856b0c74224\", \"externalId\": \"external-id-1\", \"userName\": \"example-user-1@test.com\", \"name\": { \"familyName\": \"User 1A\", \"givenName\": \"Example\" }, \"emails\": [{ \"value\": \"example-user-1@test.com\", \"primary\": true }], \"timezone\": \"America/Los_Angeles\", \"active\": true, \"meta\": { \"resourceType\": \"User\", \"created\": \"2019-11-08T22:07:12.477Z\", \"lastModified\": \"2019-11-08T22:28:33.552Z\" }, \"groups\": [] } Copy Update user with PATCH Example request: PATCH /Users/YOUR_USER_ID { \"schemas\": [ \"urn:ietf:params:scim:api:messages:2.0:PatchOp\" ], \"Operations\": [{ \"op\": \"Replace\", \"path\": \"active\", \"value\": \"false\" }] } Copy Example response: 204 No Content Copy Delete user Example request: DELETE /Users/YOUR_USER_ID Copy Example response: 204 No Content Copy Deviations from the RFC This section describes areas where the New Relic SCIM service provider deviates from the SCIM protocol RFC 7644. Section numbers refer to RFC section numbers. Items in this section could change as we work to bring our service provider into full compliance with the RFC. RFC section name RFC section number Deviation description Creating Resources 3.3. The meta.location field is not set. Filtering 3.4.2.2. The only currently supported operator is eq. Field names are case sensitive. String attributes are compared in a case sensitive manner. Prefixing the field name with the schema is not supported. For example, filter=urn:ietf:params:scim:schemas:core:2.0:User:userName eq \"johnsmith\" will not work. /Me Authenticated Subject Alias 3.11. GET with the /Me resource returns a 404 Not Found. Service Provider Configuration Endpoints 4. The service provider feature discovery endpoints do not support filtering. Bearer Token and Cookie Considerations 7.4. Bearer tokens do not have a set expiration date. Next steps when you're done Downgrade users When your users are provisioned in New Relic, you should be able to see them in the User management UI. Users provisioned via your identity provider start out as full users. If your organization is on New Relic One pricing, these users are billable. To convert users to free basic users, use the User management UI. Assign access grants Once your users are in New Relic, you need to grant them access to specific New Relic accounts, specific groups, and specific roles. Without doing this, your users have no access to New Relic accounts. To learn how to do this, see: How access grants work The user management tutorial",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.21982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automated</em> user management: SCIM <em>API</em>",
        "sections": "<em>Automated</em> user management: SCIM <em>API</em>",
        "tags": "<em>Accounts</em> <em>and</em> <em>billing</em>",
        "body": "&#x2F;Los_Angeles&quot;, &quot;active&quot;: true, &quot;groups&quot;: [] } Copy Example response: 201 Created { &quot;schemas&quot;: [ &quot;urn:ietf:params:scim:schemas:core:2.0:User&quot; ], &quot;id&quot;: &quot;f0cbc276-16c9-4d1a-abc0-1856<em>b</em>0c74224&quot;, &quot;externalId&quot;: &quot;external-id-1&quot;, &quot;userName&quot;: &quot;example-user-1@<em>test</em>.com&quot;, &quot;name&quot;: { &quot;familyName&quot;: &quot;User 1"
      },
      "id": "6043f38a64441f7d39378f0b"
    },
    {
      "sections": [
        "Troubleshoot cross application tracing",
        "Agent versions and protocols",
        "Config file requirements",
        "High throughput apps",
        "Proxies",
        "Multi-threaded processing (Java)",
        "Multiple accounts"
      ],
      "title": "Troubleshoot cross application tracing",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Cross application traces"
      ],
      "external_id": "fa4ecccd4906018947e6e36fbe96b78d6c005893",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/cross-application-traces/troubleshoot-cross-application-tracing/",
      "published_at": "2021-07-27T10:03:20Z",
      "updated_at": "2021-07-16T00:57:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are troubleshooting tips when using cross application traces. Note that this feature is not the same as distributed tracing, which is preferred over cross application tracing. Agent versions and protocols Make sure you meet these requirements for your agent's version, protocols, interfaces, or message queue libraries. If you are using a protocol that is not listed here, you will not see a connection between your applications. Agent version Notes C SDK Use distributed tracing. Go 1.11 or higher HTTP, HTTPS Java 3.9.0 or higher HTTP, HTTPs, JMS 1.1, RabbitMQ The Java agent also supports several message queue libraries, including those that use the JMS 1.1 interface. .NET 4.2 or higher HTTP, and supported .NET messaging systems Node.js 2.0.0 or higher HTTP, HTTPS, RabbitMQ PHP 4.19.0 or higher HTTP, HTTPS, and supported PHP message queuing systems Python 2.38.0.31 or higher HTTP, HTTPS, and supported Python message queuing systems Ruby 4.3.0 or higher HTTP, HTTPS, RabbitMQ Config file requirements In general, New Relic's cross application tracing feature is enabled by default. Requirements to change your configuration file vary, depending on your New Relic agent: C SDK (not supported) Go (not supported) Java .NET Node.js (no specific config file settings needed for Node.js) PHP Python Ruby High throughput apps Cross application traces rely on transaction events to associate related transactions. If you have a high throughput application, your agent may reach the maximum number of events that it can record in a minute and will fall back to sampling events. If a transaction’s events are sampled, you may see an incomplete cross application trace, including sometimes only the transactions that you are focused on. If your application has high throughput, some cross application traces will appear incomplete, sometimes with no links. Try viewing a different transaction trace. To reduce or eliminate sampling, you can also adjust the number of transaction events stored in your agent configuration. High throughput apps Troubleshooting tips Java From the transaction_events stanza, adjust the setting for max_samples_stored. Ruby Adjust the setting for analytics_events.max_samples_stored. Proxies If you expect to see a cross application trace link but it consistently does not appear, there may be a proxy or broker between your application’s communication. Cross application tracing relies on HTTP headers and JMS properties being passed from one application to other. HTTP proxies and message brokers sometimes strip those headers. Multi-threaded processing (Java) If one or more of your Java applications uses an async or \"reactive\" programming model, a transaction's activity may span across multiple threads. New Relic supports the Play framework and Servlet Async but not all async frameworks. For unsupported frameworks, activity on other threads is not reported as part of the transaction. Calls to other applications will not be traced. Multiple accounts Currently cross application traces do not cross New Relic accounts. If you have multiple New Relic accounts (including child accounts), you will only see traces for applications within one account. Our distributed tracing feature does cross account boundaries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.892975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot cross <em>application</em> tracing",
        "sections": "Troubleshoot cross <em>application</em> tracing",
        "tags": "Cross <em>application</em> traces",
        "body": "Here are troubleshooting tips when using cross <em>application</em> traces. Note that this feature is not the same as distributed tracing, which is preferred over cross <em>application</em> tracing. Agent versions and protocols Make sure you meet these requirements for your agent&#x27;s version, protocols, interfaces"
      },
      "id": "603ec3cfe7b9d22f912a07af"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-07-30T01:50:29Z",
      "title": "Add a section to end your test",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "b6a72d3fa08cce5a0edcacd34e8fa438dcfeaede",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a section to end your test",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.480286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>a</em> section to end your <em>test</em>",
        "sections": "<em>Add</em> <em>a</em> section to end your <em>test</em>",
        "info": "<em>Add</em> <em>a</em> section to end your <em>test</em>",
        "body": ", before starting this one. In this course, you’re building an A&#x2F;<em>B</em> <em>test</em> <em>application</em> in New Relic. The <em>application</em> presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which"
      },
      "id": "6091faf228ccbcbf1fa268ea"
    }
  ],
  "/explore-docs/custom-viz/build-visualization": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 669.21814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-07-30T01:48:11Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.45737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your custom <em>visualization</em> to a dashboard",
        "sections": "Add your custom <em>visualization</em> to a dashboard",
        "info": "Add your custom <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your Nerdpack, publish and <em>subscribe</em> to your visualization: bash Copy $ <em>nr1</em> nerdpack:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-07-30T01:53:09Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.39996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "info": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " serving it locally! Tip If you don&#x27;t see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application"
      },
      "id": "6091fb4464441f42962f3737"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.50766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Most of the time, the <em>nr1</em> <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, Nerdlets, launchers, and <em>visualizations</em> without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    },
    {
      "sections": [
        "Subscribe to a Nerdpack",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Tip",
        "Subscribe from the command line",
        "Technical detail",
        "Unsubscribe from a Nerdpack",
        "Unsubscribe using the command line",
        "Resolve issues with accessing your published Nerdpack",
        "Tag your Nerdpack version",
        "Subscribe with the web UI"
      ],
      "title": "Subscribe to a Nerdpack",
      "type": "developer",
      "tags": [
        "nerdpack",
        "subscribe"
      ],
      "external_id": "1e44b2ed6ab9788b17cd19ca10ae4b4cfd4c2fe1",
      "image": "https://developer.newrelic.com/static/157cec05491eea35b82fe9066d24f004/0086b/subscribe-to-account-maturity-app.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/subscribe/",
      "published_at": "2021-07-30T01:51:40Z",
      "updated_at": "2021-05-21T01:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to subscribe to a Nerdpack",
      "body": "Subscribe to a Nerdpack to use it in the New Relic platform. Unsubscribe from Nerdpacks you no longer use. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To subscribe to a Nerdpack, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can subscribe to them: Publish your Nerdpack Tag your Nerdpack if it's published and doesn't yet have a tag Subscribe to a Nerdpack Subscribe to a published Nerdpack, with either the web UI or the nr1 CLI, to use it in your account. Subscribing allows you to select the tagged version you want to use as well as the account you want to subscribe with. This lets you control what Nerdpacks you use in your account. Tip When the tag you've subscribed to gets an update, New Relic updates your Nerdpack automatically. Step 1 of 7 Go to New Relic: Step 2 of 7 Navigate to Apps: Step 3 of 7 Find your published Nerdpack under New Relic One catalog: All published Nerdpacks are shown in the New Relic One catalog. However, the one you're looking for maybe filtered out. Adjust the filter to find the Nerdpack you're looking for: Step 4 of 7 Select the Nerdpack you want to add to your New Relic account: Step 5 of 7 Click Add this app: This button says Manage access if you're already subscribed to the Nerdpack. Step 6 of 7 Select the account to subscribe with and the tagged version to subscribe to. Then, update your account(s): Tip In the web UI, and some places in the CLI, we refer to tags as channels. This is a relic of a past implementation of Nerdpack versioning. Ignoring historical and implementation details, consider them to be synonyms. Now you, and members of the accounts you've subscribed with, can launch the Nerdpack from New Relic. Step 7 of 7 If you subscribed to an app, find it under Your apps: If you subscribed to a visualization, find it under Custom visualizations: Subscribe from the command line If you've published your own Nerdpack, it may be quicker to subscribe to your Nerdpack with the nr1 CLI. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack For simplicity, this guide refers to your Nerdpack as my-awesome-nerdpack. Step 2 of 3 Ensure that your Nerdpack was published and tagged: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------------- ------ 1.0.0 a few seconds ago STABLE You should see at least one published version with a tag. It doesn't have to be STABLE. You can subscribe to any tagged version. Step 3 of 3 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe --channel=STABLE Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the STABLE channel Here, you've subscribed to the STABLE tag. You can also subscribe to DEV and BETA tags from the CLI, but the subscription command doesn't allow for arbitrary tags. To subscribe to any other tagged version, you need to use the web UI. Similar to the web UI, the term channel nr1 nerdpack:subscribe is a reference to an older implementation of Nerdpack versions. Technical detail nr1 nerdpack:subscribe is an alias for nr1 subscription:set. Read the nr1 subscription:set documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:set --help Unsubscribe from a Nerdpack Unsubscribe from a Nerdpack to remove it from your account. Step 1 of 5 Go to New Relic: Step 2 of 5 Navigate to Apps: Step 3 of 5 Click the \"i\" icon next to the Nerdpack you're subscribed to: This opens the detail page. Step 4 of 5 Click Manage access: Step 5 of 5 Deselect the accounts you want to unsubscribe with. Then, update those accounts: Unsubscribe using the command line Quickly unsubscribe your CLI profile from Nerdpacks. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack Step 2 of 3 View your profile's subscriptions: bash Copy $ nr1 subscription:list Listing subscribed deployed nerdpacks on your account: Version UUID Name Date User ------- ------------------------------------ ---------------- ----------- ------- 0.6.4 384de6e5-8e57-4d56-9d13-299ee7ae8641 Account Maturity a month ago 2774472 Step 3 of 3 Unsubscribe from the Nerdpack with the UUID: bash Copy $ nr1 nerdpack:unsubscribe --nerdpack-id=384de6e5-8e57-4d56-9d13-299ee7ae8641 Unsubscribed account 1234567 from the nerdpack 384de6e5-8e57-4d56-9d13-299ee7ae8641 on the STABLE channel. Tip nr1 nerdpack:unsubscribe is an alias for nr1 subscription:unset. Read the nr1 subscription:unset documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:unset --help Resolve issues with accessing your published Nerdpack Sometimes, when you subscribe to a Nerdpack, you may run into issues. Whether you can't subscribe or see duplicate subscriptions in your account, consider some common solutions for resolving these issues. Tag your Nerdpack version When you subscribe to an Nerdpack, you choose a specific tag. So, if the Nerdpack you're trying to subscribe to isn't tagged, or doesn't have the tag you're targeting, tag your release version: bash Copy $ nr1 nerdpack:subscribe --channel=DEV › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel DEV. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED $ nr1 nerdpack:tag --tag=DEV ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as DEV. $ nr1 nerdpack:subscribe --channel=DEV Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the DEV channel. If you subscribe without a --channel argument, the default channel is STABLE, so make sure you have a STABLE version in this case: bash Copy $ nr1 nerdpack:subscribe › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel STABLE. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED Subscribe with the web UI When you subscribe with the CLI, you pass a --channel argument to select a tag. A channel is, for all intents and purposes, a tag. This term is a relic of a past implementation of Nerdpack versioning. However, while the terms are synonymous, using --channel is limited in the CLI. When you subscribe with a --channel, you can only choose between DEV, BETA, and STABLE. So, to subscribe to a different tag, use the web UI: bash Copy $ nr1 nerdpack:subscribe --channel=QA › Error: Expected --channel=QA to be one of: DEV, BETA, STABLE › See more help with --help › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.24486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Subscribe</em> to a Nerdpack",
        "sections": "<em>Subscribe</em> to a Nerdpack",
        "info": "Learn to <em>subscribe</em> to a Nerdpack",
        "tags": "<em>subscribe</em>",
        "body": " of a past implementation of Nerdpack versioning. However, while the terms are synonymous, using --channel is limited in the <em>CLI</em>. When you <em>subscribe</em> with a --channel, you can only choose between DEV, BETA, and STABLE. So, to <em>subscribe</em> to a different tag, use the web UI: bash Copy $ <em>nr1</em> nerdpack:<em>subscribe</em> --channel=QA › Error: Expected --channel=QA to be <em>one</em> of: DEV, BETA, STABLE › See more help with --help › Code: UNKNOWN"
      },
      "id": "609c8686196a67beaed52a2c"
    }
  ],
  "/explore-docs/custom-viz/add-to-dashboard-nerdgraph": [
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-29T01:40:31Z",
      "updated_at": "2021-07-27T11:27:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 551.49347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "sections": "Introduction <em>to</em> New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "tags": "<em>NerdGraph</em>",
        "body": " <em>Add</em> and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights <em>Dashboard</em> API to <em>NerdGraph</em> Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-30T01:43:08Z",
      "title": "Collect data",
      "updated_at": "2021-07-30T01:43:08Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source 15 min APIs, agents, OS emitters - get any data Add custom attributes   Use custom attributes for deeper analysis Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 531.61615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>custom</em> <em>attributes</em>",
        "body": " data - any source 15 min APIs, agents, OS emitters - get any data <em>Add</em> <em>custom</em> attributes   Use <em>custom</em> attributes for deeper analysis Create <em>custom</em> events 5 min Define, visualize, and get alerts on the data you want using <em>custom</em> events Build queries with <em>NerdGraph</em> 25 min Try <em>NerdGraph</em> and build the queries you need Query data with NRQL 10 min Query default data, <em>custom</em> events, and attributes"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 524.7548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> <em>custom</em> <em>visualizations</em>",
        "sections": "Build <em>your</em> <em>custom</em> <em>visualization</em>",
        "info": "Introduction <em>to</em> <em>custom</em> <em>visualizations</em>",
        "tags": "<em>custom</em> <em>visualizations</em>",
        "body": ". This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make <em>NerdGraph</em> requests, access platform state context, and more. <em>Your</em> first <em>visualization</em> To build <em>your</em> first <em>custom</em> <em>visualization</em>, install the New"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Tip",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-07-29T01:42:55Z",
      "updated_at": "2021-07-27T05:55:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve mobile monitoring data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, child accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 516.5905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> New Relic <em>APIs</em>",
        "sections": "<em>NerdGraph</em> (<em>GraphQL</em>)",
        "tags": "Intro <em>to</em> <em>APIs</em>",
        "body": " to infrastructure monitoring, use the Integrations SDK. <em>NerdGraph</em> You can use <em>NerdGraph</em> (our <em>Graph</em>QL API) to query <em>your</em> cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you <em>custom</em> instrument"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 472.8144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Add</em> <em>your</em> <em>custom</em> <em>visualization</em> <em>to</em> <em>a</em> <em>dashboard</em>",
        "body": " 20 min <em>Add</em> a time picker to a sample application <em>Add</em> <em>your</em> <em>custom</em> <em>visualization</em> to a <em>dashboard</em> 10 min <em>Add</em> <em>your</em> <em>custom</em> <em>visualization</em> to a New Relic <em>dashboard</em> Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack Attach <em>your</em> Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    }
  ],
  "/build-apps/publish-deploy/tag": [
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-07-30T01:44:15Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.03503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes <em>Tag</em> Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Subscribe to a Nerdpack",
        "Tag your Nerdpack's release version"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-07-27T01:40:22Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Subscribe to a Nerdpack   Subscribe to a Nerdpack Tag your Nerdpack's release version   Tag your Nerdpack's release version",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.68398,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "<em>Tag</em> your <em>Nerdpack&#x27;s</em> release version",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, <em>tag</em>, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.10448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " the New Relic One CLI, before starting this one. A <em>Nerdpack</em> is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a <em>Nerdpack</em>, use the New Relic One CLI: bash Copy $ nr1 create --type"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.98872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to present that data, you might need to create something entirely unique. With the New Relic One SDK, we&#x27;ve provided you all the tools you&#x27;ll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a <em>Nerdpack</em>, which houses your visualization code"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.84294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Nerdpack</em> file structure",
        "body": " is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your <em>Nerdpack</em>. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create"
      },
      "id": "6091f9c864441f70d82f36c4"
    }
  ],
  "/build-apps/publish-deploy/publish": [
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-07-30T01:44:15Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.99771,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user Serve Nerdpacks yes yes yes yes <em>Publish</em> Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Subscribe to a Nerdpack",
        "Tag your Nerdpack's release version"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-07-27T01:40:22Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Subscribe to a Nerdpack   Subscribe to a Nerdpack Tag your Nerdpack's release version   Tag your Nerdpack's release version",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.25693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, <em>publish</em>, and subscribe to your <em>Nerdpack</em>",
        "sections": "Serve, <em>publish</em>, and subscribe to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, <em>publish</em>, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, <em>publish</em>, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.88641,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Publish</em> your application to New Relic",
        "info": "Build a &quot;Hello, World!&quot; app and <em>publish</em> it to New Relic One",
        "tags": "<em>Nerdpack</em> file structure",
        "body": " organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 <em>nerdpack:publish</em> Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.55753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to see how your data looks, but you can&#x27;t instantiate that chart and use it in your account: To do that, you need to <em>publish</em> it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are <em>Nerdpack</em> items, you <em>publish</em> and subscribe to them the same way you"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.0795,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enable advanced configurations for your <em>Nerdpack</em>",
        "body": " 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your <em>Nerdpack</em>   Enable advanced configurations for your <em>Nerdpack</em> Attach your Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    }
  ],
  "/build-apps/attach-nerdlet-to-entities": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 4992.92,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Attach</em> <em>your</em> <em>Nerdlet</em> <em>to</em> <em>entities</em>",
        "body": " 20 min Add a time picker to a sample application Add <em>your</em> custom visualization to a dashboard 10 min Add <em>your</em> custom visualization to a New Relic dashboard Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack <em>Attach</em> <em>your</em> <em>Nerdlet</em> to <em>entities</em>   <em>Attach</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "https://developer.newrelic.com/static/fcc5c48e25ec18cb8ddf8518059586bb/0086b/new-message.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Serve your New Relic One application",
      "updated_at": "2021-05-13T01:54:25Z",
      "type": "developer",
      "external_id": "79f6532d0c9e836788ebd0958c1158f062f0fd95",
      "document_type": "page",
      "popularity": 1,
      "info": "Locally serve your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Tip Here, you've seen how to access your Nerdlet from a launcher. If you want your Nerdlet closer to your data, you can also attach your Nerdlet to New Relic entities. Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 922.0885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve <em>your</em> New Relic One application",
        "sections": "Serve <em>your</em> New Relic One application",
        "info": "Locally serve <em>your</em> New Relic One application",
        "body": " to see <em>your</em> root <em>Nerdlet</em> and its default welcome message: Tip Here, you&#x27;ve seen how to access <em>your</em> <em>Nerdlet</em> from a launcher. If you want <em>your</em> <em>Nerdlet</em> closer to <em>your</em> data, you can also <em>attach</em> <em>your</em> <em>Nerdlet</em> to New Relic <em>entities</em>. Congratulations, you&#x27;ve served <em>your</em> first New Relic One application! Notice"
      },
      "id": "6091fb4428ccbcfe3fa268f1"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.00772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdlets</em>",
        "body": " launcher for <em>your</em> Nerdpack and called it &quot;ab-test-launcher&quot;. Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher&#x27;s metadata file Use &quot;A&#x2F;B Test Launcher&quot; for the launcher&#x27;s displayName and &quot;Open the A&#x2F;B test <em>Nerdlet</em>"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-07-30T01:57:44Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.40525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Our workloads feature gives you the ability to group and monitor <em>entities</em> based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across <em>your</em> entire stack. Workloads help you understand the status of complex systems, detect"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.85251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish <em>your</em> application <em>to</em> New Relic",
        "info": "Build a &quot;Hello, World!&quot; app and publish it <em>to</em> New Relic One",
        "body": " default class MyAwesomeNerdpack<em>NerdletNerdlet</em> extends React.Component { render() { return &lt;h1&gt;&quot;Hello, World!&quot;&lt;&#x2F;h1&gt;; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in <em>your</em> new"
      },
      "id": "6091f9c864441f70d82f36c4"
    }
  ],
  "/build-apps/publish-deploy/subscribe": [
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-07-30T01:44:15Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.45209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and <em>subscribing</em> accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes <em>Subscribe</em> to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.41708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "tags": "<em>Subscribe</em> applications",
        "body": " to <em>subscribe</em> accounts to the application. Any user with the <em>NerdPack</em> manager or admin role can <em>subscribe</em> to an application from accounts that they have permission to manage. Step 1 of 3 If you&#x27;re not already displaying your application&#x27;s description page in the browser, click the launcher"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Subscribe to a Nerdpack",
        "Tag your Nerdpack's release version"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-07-27T01:40:22Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Subscribe to a Nerdpack   Subscribe to a Nerdpack Tag your Nerdpack's release version   Tag your Nerdpack's release version",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.88852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and <em>subscribe</em> to your <em>Nerdpack</em>",
        "sections": "Serve, publish, and <em>subscribe</em> to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, tag, and <em>subscribe</em> to it on the New Relic platform. Guides to serve, publish, and <em>subscribe</em> to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to see how your data looks, but you can&#x27;t instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and <em>subscribe</em> to it from your account. Because custom visualizations are <em>Nerdpack</em> items, you publish and <em>subscribe</em> to them the same way you"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.987076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " the New Relic One CLI, before starting this one. A <em>Nerdpack</em> is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a <em>Nerdpack</em>, use the New Relic One CLI: bash Copy $ nr1 create --type"
      },
      "id": "6091faf2196a672632d52a22"
    }
  ],
  "/build-apps/publish-deploy/catalog": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-07-30T01:43:06Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.2218,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Nerdpack</em> file structure",
        "body": " organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 <em>nerdpack</em>:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One <em>catalog</em>, click the launcher for your new application"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Subscribe to a Nerdpack",
        "Tag your Nerdpack's release version"
      ],
      "published_at": "2021-07-30T01:44:15Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-07-27T01:40:22Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Subscribe to a Nerdpack   Subscribe to a Nerdpack Tag your Nerdpack's release version   Tag your Nerdpack's release version",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.93799,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "Update your <em>Nerdpack&#x27;s</em> <em>catalog</em> information",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s <em>catalog</em>"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-07-30T01:50:29Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.28343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to see how your data looks, but you can&#x27;t instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One <em>catalog</em> and subscribe to it from your account. Because custom visualizations are <em>Nerdpack</em> items, you publish and subscribe to them the same way you"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-07-30T01:51:40Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.04993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " arrow-keys. Return to submit. <em>nerdpack</em> ❯ nerdlet - create a&#x2F;an Nerdlet <em>Nerdpack</em> item inside your <em>Nerdpack</em>. launcher <em>catalog</em> visualization In the next lesson, you&#x27;ll learn how to serve your <em>Nerdpack</em> locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application."
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-07-30T01:46:49Z",
      "updated_at": "2021-05-05T01:53:28Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.94555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up your <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> commands",
        "body": " <em>Nerdpack</em>&#x2F;Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the <em>catalog</em> Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One <em>catalog</em> area, click the Build your own application"
      },
      "id": "6091fa9864441feb412f36d4"
    }
  ],
  "/build-apps/customize-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with SDK components",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-07-30T01:43:06Z",
      "title": "Build apps",
      "updated_at": "2021-07-30T01:43:06Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with SDK components 25 min Customize your visualization Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1914.0778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> <em>open</em>-<em>source</em> <em>Nerdpacks</em>",
        "body": " your Nerdlet to entities Create a &quot;Hello, World!&quot; application 15 min Build a &quot;Hello, World!&quot; app and publish it to New Relic One <em>Customize</em> <em>open</em>-<em>source</em> <em>Nerdpacks</em>   <em>Customize</em> <em>open</em>-<em>source</em> <em>Nerdpacks</em> <em>Customize</em> your visualization with SDK components 25 min <em>Customize</em> your visualization <em>Customize</em> your"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic APM agents",
        "How OpenTelemetry works with New Relic",
        "Important"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-07-27T16:03:37Z",
      "updated_at": "2021-07-27T16:03:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects (initially, traces and metrics are supported, followed by logs) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetry’s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss it directly with us at New Relic to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic APM agents In general, New Relic APM agents will collect more telemetry data for your services, and they offer a wide range configuration options and an extensive set of auto-instrumentation capabilities. APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemtry community to export your data to New Relic. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.07379,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> telemetry integrations",
        "body": ", contributors can build integrations into <em>Open</em>Telemetry or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other <em>open</em> standards"
      },
      "id": "603e81ba196a67304da83dab"
    },
    {
      "sections": [
        "Introduction to New Relic's open source telemetry integrations",
        "Types of integrations",
        "How they work"
      ],
      "title": "Introduction to New Relic's open source telemetry integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "Get started"
      ],
      "external_id": "239889ec292525fcfd6b417d243943ea7b3e0529",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/get-started/introduction-new-relics-open-source-telemetry-integrations/",
      "published_at": "2021-07-27T16:01:31Z",
      "updated_at": "2021-07-27T16:01:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic provides open source integrations that report telemetry data from telemetry tools to your New Relic account. Types of integrations We have open source integrations that report data from OpenCensus, OpenTelemetry, DropWizard, Prometheus, and more. With these solutions, you can aggregate all your telemetry data in one place: the New Relic platform. See our list of open source telemetry integrations (to browse all New Relic solutions, see our integrations page). How they work These integrations were built using our Telemetry SDKs, which are open-source language-specific libraries for reporting metrics, trace data, and other telemetry data to New Relic. If our pre-built integrations don't meet your needs, you can use the Telemetry SDKs to build your own telemetry tools. Under the hood, data reported by these solutions are ingested via our data ingest APIs. For example, metrics reported by the DropWizard exporter are ingested via the Metric API, so to understand how to query and chart that type of data, you could read Query metric data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.28442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>open</em> <em>source</em> telemetry integrations",
        "sections": "Introduction to New Relic&#x27;s <em>open</em> <em>source</em> telemetry integrations",
        "tags": "<em>Open</em> <em>source</em> telemetry integrations",
        "body": "New Relic provides <em>open</em> <em>source</em> integrations that report telemetry data from telemetry tools to your New Relic account. Types of integrations We have <em>open</em> <em>source</em> integrations that report data from <em>Open</em>Census, <em>Open</em>Telemetry, DropWizard, Prometheus, and more. With these solutions, you can aggregate"
      },
      "id": "603e95ab28ccbc036aeba789"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Important",
        "Tip",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "1b846417a2958b61b047c838db49aea06f09a2a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-07-27T16:04:43Z",
      "updated_at": "2021-07-22T00:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your Account License Key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. Important Our support of OTLP ingest is currently in pre-release. To particiapte in the pre-release program, please complete this form, and we'll send you details. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic: Tip If you prefer to export your data to an OpenTelemetry collector, see our instructions below. To complete this step, you'll follow the OTLP exporter documenentation for your language. Before you go to this external documentation, keep in mind you'll need to configure the OTLP exporter to send data to New Relic. This includes setting the header and configuring the endpoint: Configure the OTLP exporter to add a header ( api-key ) whose value is your Account License Key. Configure the endpoint for the exporter to point to New Relic. You'll receive the endpoint URL when you sign up for the pre-release program. Now, follow the instructions for your language: Important Make sure you are following the instructions for the OTLP gRPC exporter for your language. New Relic doesn't currently support OTLP HTTP exporters. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. The difference in this case is that instead of exporting data directly to New Relic, you export it to a collector that you set up. Then, in the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the endpoint you received when signing up for the pre-release and replace YOUR_KEY_HERE with your Account License Key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options, see View your OpenTelemetry data in New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.81134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> telemetry integrations",
        "body": "<em>Open</em>Telemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>Open</em>Telemetry with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>Open</em>Telemetry Export"
      },
      "id": "6044e5dfe7b9d2aadc5799d4"
    },
    {
      "sections": [
        "Legacy New Relic OpenTelemetry Exporters",
        "Important",
        "New Relic Language Exporters",
        "New Relic Exporter for the OpenTelemetry Collector",
        "Endpoint Configuraion for New Relic exporters",
        "US endpoints",
        "EU region endpoints",
        "Tip"
      ],
      "title": "Legacy New Relic OpenTelemetry Exporters",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "0bcf5013d05814a9a0c8017b8c91a1770c7b8394",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-legacy-new-relic-exporters/",
      "published_at": "2021-07-27T16:03:38Z",
      "updated_at": "2021-07-20T11:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic published a number of exporters that are used to send OpenTelemetry data over New Relic's proprietary protocol. These exporters are being deprecated in favor of sending data to New Relic using the OpenTelemetry protocol. Important The exporters are listed here for reference. To migrate off these exporters, follow our quick start guide. New Relic Language Exporters As mentioned above, our language-specific exporters are being deprecated. These exporters allowed applications to export OpenTelemetry data directly to New Relic. The New Relic OTLP endpoint makes this strategy obsolete since it allows applications to export data to New Relic's proprietary endpoints. The exporters and their maintenance status are as follows: Go: To be archived soon Java: Archived Python: Archived .NET: To be archived soon New Relic Exporter for the OpenTelemetry Collector If you deployed your own collector with a New Relic exporter, we'll continue to support this exporter at least until the native OTLP ingest is beyond pre-release. We encourage you to migrate to the OTLP exporter in your collector. If you need help with that see our quick start guide. If you still need information about the New Relic Exporter, see the opentelemetry-collector-contrib repository. The OpenTelemetry Collector with New Relic Exporter example demonstrates what such a setup might look like. Endpoint Configuraion for New Relic exporters You can change the New Relic endpoints where you send your data. US endpoints By default, New Relic OpenTelemetry exporters send data to these US data centers: Spans: https://trace-api.newrelic.com/trace/v1 Metrics: https://metric-api.newrelic.com/metric/v1 Logs: https://log-api.newrelic.com/log/v1 You may need to override these default endpoints to send data to the EU region or to use Infinite Tracing. EU region endpoints To send telemetry data to New Relic’s endpoints in the EU region, use the following: Tip These URLs don't apply to Infinite Tracing. Spans: https://trace-api.eu.newrelic.com/trace/v1 Metrics: https://metric-api.eu.newrelic.com/metric/v1 Logs: https://log-api.eu.newrelic.com/log/v1",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.56812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Legacy New Relic <em>OpenTelemetry</em> Exporters",
        "sections": "Legacy New Relic <em>OpenTelemetry</em> Exporters",
        "tags": "<em>Open</em> <em>source</em> telemetry integrations",
        "body": "New Relic published a number of exporters that are used to send <em>Open</em>Telemetry data over New Relic&#x27;s proprietary protocol. These exporters are being deprecated in favor of sending data to New Relic using the <em>Open</em>Telemetry protocol. Important The exporters are listed here for reference. To migrate"
      },
      "id": "60f6b9b928ccbc930b4b111c"
    }
  ]
}