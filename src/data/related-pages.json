{
  "/build-apps/add-time-picker-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.09717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a <em>time</em> <em>picker</em> to your <em>app</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-08-02T13:08:44Z",
      "updated_at": "2021-07-09T12:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: New Relic APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.82243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Android <em>app</em> UI",
        "sections": "Android <em>app</em> UI",
        "tags": "Mobile <em>apps</em>",
        "body": " <em>picker</em> to choose a <em>time</em> range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android <em>app</em> to view your New Relic Synthetics data, including charts of your monitor&#x27;s availability, load times, and load sizes. Select the caret icon to view more detailed charts. You"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.52373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "sections": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "info": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "body": " NewsletterSignups component&#x27;s render() <em>method</em>: import React from &#x27;react&#x27;; import { HeadingText, LineChart, NrqlQuery, <em>PlatformStateContext</em>, } from &#x27;nr1&#x27;; const ACCOUNT_ID = 123456 &#x2F;&#x2F; &lt;YOUR NEW RELIC ACCOUNT ID&gt; export default class NewsletterSignups extends React.Component { render() { return &lt;div&gt; &lt;HeadingText"
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.42699,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": ": <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access"
      },
      "id": "6091fa39196a67a4ead52a4b"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-08-02T13:11:34Z",
      "updated_at": "2021-07-09T11:42:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: New Relic APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.0935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS mobile <em>app</em>",
        "sections": "Introduction to iOS mobile <em>app</em>",
        "tags": "Mobile <em>apps</em>",
        "body": "The user interface for New Relic&#x27;s iPhone and iPad <em>app</em> provides functionality similar to New Relic&#x27;s standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-<em>time</em> information about your apps, hosts, and more. Features New Relic&#x27;s iOS <em>app</em> includes"
      },
      "id": "6044161628ccbc96b62c6092"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Automate workflows",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.45455,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " Toolkit. Guides to automate workflows Quickly <em>tag</em> resources 5 min Add <em>tags</em> to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up <em>New</em> <em>Relic</em> using the Kubernetes operator 20"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.11311,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find your data",
        "sections": "Automate <em>tags</em> with our <em>CLI</em>",
        "tags": "<em>New</em> <em>Relic</em> One",
        "body": "In the software industry, a <em>tag</em> typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our <em>tags</em> are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/python-release-notes/python-agent-228026/",
      "sections": [
        "Python agent v2.28.0.26",
        "Important",
        "Notes",
        "New Features"
      ],
      "published_at": "2021-08-02T17:40:14Z",
      "title": "Python agent v2.28.0.26",
      "updated_at": "2021-08-02T17:40:13Z",
      "type": "docs",
      "external_id": "5939ea369bf0e1728bf83f949cd66a7524a1b6d0",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Important The end-of-life date for this agent version is July 29, 2019. To update to the latest agent version, see Update the agent. For more information, see End-of-life policy. Notes This release of the Python agent improves data collection with the Django web framework. These improvements include better-targeted web transaction naming with the Django REST framework, better coverage of Django template inclusion tags, and better background task monitoring for Django management commands. The agent can be installed using easy_install/pip/distribute via the Python Package Index or can be downloaded directly from our download site. For a list of known issues with the Python agent see Status of the Python agent. New Features Improved Django REST Framework naming Previously, when using the Django REST framework, web transactions were being named after the class based view that implemented the Django REST framework resources. Now, where such a view provides custom handler methods for different HTTP request method types or actions, the web transaction will be named after that custom handler method rather than the class as a whole. A new function breakdown metric will also be added for the custom handler method. This change will allow web requests using different HTTP request method types to be viewed separately. Django inclusion tag monitoring Usage of inclusion tags in Django templates can now be monitored and will appear in the transaction breakdown table, charts and sample transaction traces. Due to the possibility that a large range of custom inclusion tags might be used and that they may be invoked a large number of times in tight loops, tracking of all inclusion tags may not be practical or may not produce worthwhile results in the transaction breakdown or sample transaction traces. As a result, monitoring of inclusion tags is off by default, with the preferred approach being that specific inclusion tags of interest be individually enabled through the agent configuration file. To enable monitoring of specific inclusion tags, a new section called import-hook:django should be added to the agent configuration: [import-hook:django] instrumentation.templates.inclusion_tag = prepopulated_fields_js date_hierarchy Copy The instrumentation.templates.inclusion_tag setting within that section should then be set to a space separated list of the names of the inclusion tags to monitor. If there is any confusion over the identity of the inclusion tag, the full name of the inclusion tag function, with module name, can instead be listed. For example, data_hierarchy can also be identified using django.contrib.admin.templatetags.admin_list:date_hierarchy. In addition to specifying the names of the specific inclusion tags, it is also possible to specify * for instrumentation.templates.inclusion_tag in order to have usage of all inclusion tags be monitored: [import-hook:django] instrumentation.templates.inclusion_tag = * Copy Enabling monitoring of all inclusion tags in this way is only recommended in development or test environments so as to get an initial idea of what inclusion tags are worth tracking. Once identified, the specific inclusion tags of interest should thereafter be listed individually in a production environment. Better monitoring of Django management commands Previously, the Python agent required you to manually set up the instrumentation for each specific Django management command in the agent configuration file. We have now made that easier by integrating the functionality as part of the agent itself. Due to the limitations on what Django management commands can be monitored, you will still need to list explicitly the commands you want monitored, but it can now be done in a single location as a space separated list under the setting instrumentation.scripts.django_admin of the import-hook:django section: [import-hook:django] instrumentation.scripts.django_admin = syncdb sqlflush Copy By default, we automatically specify the startup timeout to be 10.0 seconds when monitoring the Django management commands. If you need to override the startup timeout, you can set the instrumentation.background_task.startup_timeout setting within the same import-hook:django configuration section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.32402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> Features",
        "body": " for the custom handler method. This change will allow web requests using different HTTP request method types to be viewed separately. Django inclusion <em>tag</em> monitoring Usage of inclusion <em>tags</em> in Django templates can now be monitored and will appear in the transaction breakdown table, charts and sample"
      },
      "id": "603ec5b9196a67efb4a83dce"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.48912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " application. You should copy it or write it down. Step 6 of 10 Add a simple <em>tag</em> to your application. Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using"
      },
      "id": "6091f7ca196a67b841d52a33"
    },
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-08-02T02:02:10Z",
      "updated_at": "2021-07-30T01:44:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.92832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tags</em> (attributes)",
        "body": "Our StatsD integration lets you easily get StatsD-format data into <em>New</em> <em>Relic</em>. You can also add any arbitrary <em>tags</em> (key-value pairs) to your data. Once your metrics are in <em>New</em> <em>Relic</em>, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a <em>New</em>"
      },
      "id": "6043a32364441fa554378eee"
    }
  ],
  "/terms": [
    {
      "sections": [
        "Developer Program Resources"
      ],
      "title": "Developer Program Resources",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "New Relic Developer edition"
      ],
      "external_id": "8a2f08905c7dcd10e50e975783ca3cf0071324c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources/",
      "published_at": "2021-08-02T10:46:20Z",
      "updated_at": "2021-03-13T03:24:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer, you are eligible to participate in New Relic’s Developer Program. Additional information and resources are available at New Relic’s Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.05234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you."
      },
      "id": "6044e7bb196a676d20960f4d"
    },
    {
      "sections": [
        "Preview access for New Relic One"
      ],
      "title": "Preview access for New Relic One",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "New Relic One"
      ],
      "external_id": "5a11f3d0ff23ad22ec459a0115a70ddbb2964d1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one/",
      "published_at": "2021-08-02T10:48:27Z",
      "updated_at": "2021-03-16T04:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 314.1695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "603e891464441f2af14e883b"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions."
      ],
      "published_at": "2021-08-03T01:46:38Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2021-03-20T01:55:45Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "External Projects Highlighted Projects New Relic Projects Standards Menu External Projects Highlighted Projects New Relic Projects Standards NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (“New Relic”). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.0231,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "sections": [
        "New Relic One pricing: Definitions",
        "Account",
        "Commitment Term",
        "Customer Data",
        "Customer Properties",
        "Documentation",
        "GB Ingested",
        "Incident event",
        "Login Credentials",
        "Monthly Provisioned User",
        "Order",
        "Paid Terms of Service",
        "Product(s)",
        "Software",
        "Terms",
        "Third-Party Services",
        "Unpaid Terms of Service",
        "Usage Plan"
      ],
      "title": "New Relic One pricing: Definitions",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Product definitions"
      ],
      "external_id": "609575acd671fecf7899378157eabc57bc8d68e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions/",
      "published_at": "2021-08-02T12:00:02Z",
      "updated_at": "2021-05-22T17:25:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a glossary of terms that appear in contracts for our New Relic One pricing plan (for a glossary for our original pricing, see Original pricing definitions. Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer’s websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‘Documentation’ page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Incident event An incident event is an alerting event (open, closed, etc.) created by an alerting engine that is sent into the New Relic Applied Intelligence platform (non-unique) for de-duplication, flapping detection, smart suppression, enrichment, and correlation. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer’s Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. In our public docs, this is referred to as a full user. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic’s customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. To learn more about this pricing plan, see New Relic One pricing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.12308,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Paid <em>Terms</em> of Service",
        "body": " into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid <em>Terms</em> of Service Paid <em>Terms</em> of Service means the legal <em>terms</em> and <em>conditions</em> located at: https:&#x2F;&#x2F;newrelic.com&#x2F;termsandconditions&#x2F;paid. Product(s) Product(s) mean the purchase"
      },
      "id": "6044e6e528ccbc26f22c6084"
    },
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.1777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>and</em> configure the New Relic One CLI",
        "sections": "Install <em>and</em> configure the New Relic One CLI",
        "info": "Install <em>and</em> configure the New Relic One CLI",
        "body": " developer <em>terms</em> and <em>conditions</em>: Even if you install the CLI, you won&#x27;t be able to use it without first accepting these <em>terms</em> and <em>conditions</em>. Step 4 of 5 Choose your operating system and click Download installer: Once you&#x27;ve installed the SDK, you&#x27;ll have access to the nr1 CLI. Verify this by checking your"
      },
      "id": "6091faf1196a6714b4d52a39"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Collect data",
      "updated_at": "2021-07-31T01:40:29Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.039345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " <em>custom</em> <em>attributes</em>   Use <em>custom</em> <em>attributes</em> for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create <em>custom</em> events 5 min Define, visualize, and get alerts on the data you want using <em>custom</em> events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with <em>NRQL</em> 10 min Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-08-02T20:37:24Z",
      "updated_at": "2021-08-02T20:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.20292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Customer</em> experience improvement: Track experience indicators",
        "sections": "1. Use <em>custom</em> <em>attributes</em> to associate performance data",
        "body": " with <em>custom</em> <em>attributes</em>. If you plan to collect this information in both the frontend and backend, be sure to forward <em>custom</em> <em>attributes</em> from APM to browser. Here are some common <em>attributes</em> to collect: User ID Organization or customer ID A&#x2F;B testing cohort value High-value customer indicator Purchase"
      },
      "id": "603ebeb964441f6e314e88a1"
    },
    {
      "sections": [
        "Customer experience improvement: track experience indicators",
        "Prerequisites",
        "1. Use custom attributes to associate performance data",
        "Tip",
        "2. Create dashboards with performance and business metrics",
        "3. Share dashboards across departments",
        "4. Utilize data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d21df3a402de56277f7b5e01aa95d65b32e515c6",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-08-02T13:43:31Z",
      "updated_at": "2021-08-02T13:43:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effect of application performance on your business. A clear understanding of what creates successful customer experience helps DevOps teams drive greater efficiencies in work efforts and deliver greater productivity. An efficient, well-functioning DevOps culture enables organizations to make rapid, frequent releases and product changes. A strong DevOps culture also democratizes data beyond the typical backend users, and makes it available to groups like customer service, support, sales, and marketing. However, this data information enablement is only useful if its purpose is to improve and optimize customer experience. Prerequisites This tutorial assumes you’ve reviewed the Establish team dashboards tutorial. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the front- and back-end transactions that are responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. Tip If you plan to collect this information in both frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Iterate and measure impact or Establish objectives and baselines tutorials, consider what service level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the above to measure the impact of your changes and optimizations at a customer level—not only a performance level. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. Additionally, to drive visibility across your teams, add dedicated widgets to the team dashboards you built in the Establish team dashboards . insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could product make more informed roadmap decisions? Customer success: Can this data be used to make our customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Utilize data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.050766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Customer</em> experience improvement: track experience indicators",
        "sections": "1. Use <em>custom</em> <em>attributes</em> to associate performance data",
        "body": ", sales, and marketing. However, this data information enablement is only useful if its purpose is to improve and optimize customer experience. Prerequisites This tutorial assumes you’ve reviewed the Establish team dashboards tutorial. 1. Use <em>custom</em> <em>attributes</em> to associate performance data In order"
      },
      "id": "60440f5f28ccbcf7dc2c60b2"
    },
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-08-02T20:37:23Z",
      "updated_at": "2021-08-02T20:37:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.874405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "6. Annotate and tag traces with <em>custom</em> <em>attributes</em>",
        "body": ", like User ID. You can do this in New Relic using <em>custom</em> <em>attributes</em>. one.newrelic.com &gt; APM &gt; Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Mobile monitoring best practices guide",
        "1. Start collecting data",
        "How to do it",
        "Add your mobile app to New Relic",
        "Install and configure our mobile SDK",
        "2. Explore your data",
        "Analyze, resolve, and prevent crashes",
        "Monitor your key workflows",
        "Get actionable session data",
        "3. Take preventive steps",
        "Metric-based alerts",
        "Event-based alerts",
        "4. Dig deeper into crashes",
        "Crash analysis",
        "Breadcrumbs",
        "Custom attributes",
        "5. Focus on KPIs",
        "Track and query feature use",
        "Measure page load times",
        "Examine data about webpage interactions"
      ],
      "title": "Mobile monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "32f5d3919c54c90173721a2cda556d8fd57744f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/mobile-monitoring-best-practices-guide/",
      "published_at": "2021-08-02T10:17:23Z",
      "updated_at": "2021-08-02T10:17:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By eliminating crashes and increasing speed across the stack, you can build better performance into every mobile app release. Here are some best practices to take full advantage of mobile monitoring with New Relic. 1. Start collecting data Start collecting data in production. You'll see immediate value by adding our mobile monitoring SDK to your app for its next release to the app store. We recommend installing the iOS or Android agent to your production release even if you're simply testing New Relic's capabilities. This will ensure you'll get an adequate amount of data to really understand all of our mobile monitoring capabilities and your end users' experience. How to do it Add your mobile app to New Relic First, add a new app in New Relic's user interface (full steps): Go to one.newrelic.com and click Mobile. From the list of monitored apps, select Add more. Select the relevant platform. Type a name for your mobile app, and select Continue. Use one app and the associated app token for the development releases of your iOS app, another app and its associated app token for the production releases of that iOS app, and another pair of app tokens for development and production releases of your Android app. You'll be able to compare data from across the four app tokens using our query builder. Install and configure our mobile SDK Next, install and configure the mobile agent: Download the latest version of New Relic's SDK for iOS or Android, and add it to your mobile app. (Full steps for iOS and Android) Configure your installation as needed. For example: Enable the feature flag to capture MobileRequest events to use our full network analysis capabilities for iOS or Android. Automate dSYM uploads for your production builds. To avoid surprises, follow the standard pattern of where you start our mobile agent. In addition, start our agent before you initiate any other SDKs. For more information, see our documentation for Android installation and configuration and for iOS installation and configuration. Deploy a new release of your application. 2. Explore your data Immediately be able to explore your data. As soon as New Relic starts reporting data, take the time to explore the wealth of information about your mobile apps. To get started, go to one.newrelic.com and select Mobile. How to do it Analyze, resolve, and prevent crashes Find the cause of crashes so you can fix them. Then, uncover trends behind crashes so you can prevent them: From the summary UI page for a monitored mobile app, click Crash analysis. Analyze crash data so you can see and fix the most impactful crashes. Follow the breadcrumbs in the crash event trail to fix crashes and resolve critical errors more easily: From your mobile app's Crash analysis page in the UI, select a Crash type. From the crash type's Summary page, select the Crash trail tab. Monitor your key workflows Create custom breadcrumbs to monitor key workflows (such as your app's login or checkout process), track user clicks, optimize timing, and identify crash locations for faster MTTR. Get actionable session data Borrow from our example queries to: See how much of your user base has upgraded to your latest app version. Track adoption over time. Get a count of new installs as compared to upgrades from an earlier version. See the distribution of usage across geographical locations, carriers, ASN owners (wi-fi providers), devices, connection types, and more. 3. Take preventive steps Use alert notifications to help uncover the causes behind crashes and errors. Once you are running our mobile monitoring capabilities in production and have explored some of the key features, you can use New Relic to uncover critical issues with your mobile application. In particular, focus on crashes and errors. Use metric-based alerts as a starting point to gain high-level visibility into problems. Then, as new services or functionalities are added, use New Relic’s more targeted, event-based (NRQL) alerts to make sure that the most critical issues are handled swiftly. Use these alerts to determine whether a crash is impacting a large number of users. If it is, the relevant people (for example, both the mobile app team’s on-call member and the owner of the related back-end service) will be alerted. Make sure that your team knows how to respond to changes in crash rate (crashes per sessions) and the percentage of users impacted by crashes of your mobile app. How to do it Metric-based alerts Use our metric-based alerts and mobile monitoring UI: Ensure that key members of your mobile team have opted in to receive emails for new crashes. These emails will take you to the crash type in the UI page for your mobile app. Create an alert for your crash rate threshold that key members of your team can view in Slack or any other Alerts notification channel you choose. Your alert notification will include a link to our UI, where you can examine a chart with the exceeded threshold. From there, a link will take you to the relevant mobile monitoring page, where you can get additional details. Event-based alerts Combine the metric-based workflow with event-based alerts and dashboards specific to your mobile app and system. Create your NRQL alert that focuses on crashes of your most recently released production version. Create an additional NRQL alert that focuses on the percentage of users impacted by crashes in your latest app version (to check the overall impact on your user base). 4. Dig deeper into crashes Take your crash reporting to the next level. Now it’s time to tackle some of those harder-to-reproduce crashes by: Applying additional instrumentation to your application. Leveraging crash event trails, NRQL queries, and dashboards to visualize your data. How to do it Crash analysis Crashes are an inevitable part of running mobile applications at scale. We provide tools to help you understand your highest-impact crashes. Use the Crash analysis UI to see which crashes are occurring most often, the percentage of crash-free users, which files and methods are associated with perhaps 80 percent of your crashes, which crashes a particular user just experienced, and more. Go after high-impact crashes with crash analysis: Add custom attributes to categorize the highest-value customers, and then use them to segment crashes according to your most valuable audiences. Add breadcrumbs and custom events to produce a detailed trail of events leading up to every crash occurrence (over the last 90 days). Then, view this crash event trail in our mobile monitoring UI. Use our mobile monitoring's Versions trends page to make sure you’re improving the crash rate over subsequent releases and avoiding regressions. Breadcrumbs Use breadcrumbs and custom attributes to better reproduce and debug crashes. For example, use our recordBreadrumb API for Android or iOS to track mid-session changes in state that can help debug crashes, such as: Change of connection type Change of orientation CPU and memory state at key points in the app code Custom attributes Add custom attributes to existing events, so you can ask even more precise questions of your mobile app. Add dimensions such as: User ID: Use to react to specific user concerns and to better understand which customers and segments are most impacted. Store ID: Use to address problems with out-of-date devices, bad wi-fi, and so on. User segments: Use to better understand which customers and segments are most impacted; for example, logged in vs. non-logged in. Money in the cart at session end Origin or attribution of entry into the app Standardize custom attribute names across your mobile apps, and align with your website (if you're using our browser monitoring), so that you can compare and contrast performance across end-user channels. The mobile agents track the last interaction of crashed and non-crashed sessions to provide visibility into what the user viewed before exiting your app (either intentionally or due to a crash). 5. Focus on KPIs Bring your key performance indicators to life. Create custom interactions and events to hone in on the most important signals, including user activity for the business-critical aspects of your app. Using these powerful APIs, you can add custom instrumentation to just about anything. The following are some example use cases. How to do it Track and query feature use Use custom events to track feature use. For example: Use custom events to track user flow between app and website. Use custom events or mobile breadcrumbs to optimize the performance of key user flows (log in, shopping cart, etc.). use custom events to provide faster, contextualized support experiences for your digital customers. Use the recordCustomEvent API. Then compare the use of different features using: SELECT count(*) FROM MyNewMobileEventType FACET name Copy Measure page load times Use custom events to measure page load time: Create an app-launch timer to measure the time that elapses between a user-tap to launch your app and the point in your app code where the first screen is available. Record the timer value in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <appLaunch>, {attributes}) Copy Define start and stop timers to measure spinner durations, and then record this time in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <spinnerOnScreenA>, {attributes}) Copy Track specific user actions or funnel steps in the app (like \"add to cart\"), and include the price as an attribute on that event. Measure flows through the application by viewing the related funnel steps with custom events in Insights. For example, create a timer to track the start and end times of a subflow or an entire flow across multiple funnel steps to understand how long it took users to get through the process. Examine data about webpage interactions Use custom interactions to see traces associated with the same webpages. Use the agent API to disable default interactions, and focus on custom interactions so that you can review the page loads that are most crucial to your primary funnel. Define the start and stop times of these custom interactions to trace activities associated with individual steps of that funnel (for example, a specific user action or a page load). Track the last interactions of crashed and non-crashed sessions so that you can see what the user viewed before exiting your app (either intentionally or from a crash). Example query for non-crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is null FACET lastInteraction SINCE 90 days ago Copy Example query for crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is true FACET lastInteraction SINCE 90 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.67585,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Custom</em> <em>attributes</em>",
        "body": ", the percentage of crash-free users, which files and methods are associated with perhaps 80 percent of your crashes, which crashes a particular user just experienced, and more. Go after high-impact crashes with crash analysis: Add <em>custom</em> <em>attributes</em> to categorize the highest-value customers"
      },
      "id": "6044151e28ccbc19ab2c60d8"
    }
  ],
  "/terraform/terraform-modules": [
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-08-03T01:44:08Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.4988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "6091fa9964441fe25f2f36f4"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.30005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.5833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091b486196a675dc3d52a6f"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-08-03T01:43:04Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.64099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091fa9928ccbc8a70a268ac"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-08-02T22:59:55Z",
      "updated_at": "2021-07-22T04:34:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more child accounts, the notification channel includes only users for the currently selected parent or child account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.28873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Automate workflows",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.2167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " min Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Getting started with <em>New</em> <em>Relic</em> and Terraform 30 min Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform Set up <em>New</em> <em>Relic</em>"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-08-03T01:39:42Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.68279,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "6091f7c828ccbc8813a268b2"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.09222,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find your data",
        "sections": "Add <em>tags</em> via UI or <em>API</em>",
        "tags": "<em>New</em> <em>Relic</em> One",
        "body": "In the software industry, a <em>tag</em> typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our <em>tags</em> are <em>key</em>:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-08-02T02:02:10Z",
      "updated_at": "2021-07-30T01:44:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.18086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tags</em> (attributes)",
        "body": "&#x27; address = &#x27;https:&#x2F;&#x2F;metric-<em>api</em>.newrelic.com&#x2F;metric&#x2F;v1&#x27; <em>api</em>-<em>key</em> = &#x27;$<em>NEW_RELIC_API_KEY</em>&#x27; Copy To use the configMap, declare a volume on your <em>deployment</em> spec template and then declare a volumeMount on your container spec. Example: <em>api</em>Version: apps&#x2F;v1 kind: <em>Deployment</em> spec: template: spec: containers"
      },
      "id": "6043a32364441fa554378eee"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-fdf7e1be9e4142c700009219a7dfd19b.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-08-03T01:37:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-06-09T01:38:14Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 32 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.96385,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Automate workflows",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.54092,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " Toolkit. Guides to <em>automate</em> workflows Quickly <em>tag</em> resources 5 min Add tags to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> 30 min See how easy it is to leverage automation in <em>your</em> DevOps environment! Set up New Relic using the Kubernetes operator 20"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.32368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "sections": "<em>Automate</em> <em>tags</em> with our CLI",
        "body": " entities that are non-compliant with <em>your</em> <em>tagging</em> standards. <em>Tag</em> examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and add tags",
        "Overview",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity"
      ],
      "title": "NerdGraph tutorial: View and add tags",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b62313b6fa10ab235c031feae23d6fe52163b703",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial/",
      "published_at": "2021-08-03T06:45:40Z",
      "updated_at": "2021-06-09T05:59:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use our NerdGraph API to add tags to your data to help improve data organization and findability. Overview This doc explains how to use our NerdGraph API to add and manage tags. Note that this is only one way to add tags. For other methods, see How tags are added. For how to automate tags using our CLI tool, see our developer site. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } Copy The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Copy Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Copy Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Copy Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace the entity’s entire set of tags with the provided tag set: Go to the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.1902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph tutorial: View and add <em>tags</em>",
        "sections": "NerdGraph tutorial: View and add <em>tags</em>",
        "body": " of deleting an <em>entire</em> <em>tag</em> and all of its values, you can delete a single <em>tag</em> value. Go to the NerdGraph GraphiQL explorer at api.newrelic.com&#x2F;graphiql. Use entitySearch() to locate the GUID for the entity with the <em>tag</em> you want to remove. Use the <em>taggingDeleteTag</em>ValuesFromEntity mutation. The following"
      },
      "id": "603ec1c6196a67eeada83d9a"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.676056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Impact <em>of</em> accounts on the workload permissions and content",
        "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across <em>your</em> <em>entire</em> <em>stack</em>. Workloads help you understand the status of complex systems, detect"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-08-02T02:09:17Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.682014,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query <em>your</em> data more easily",
        "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-<em>Stack</em> Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout <em>your</em> <em>entire</em> system. To access New Relic One: Go to one.newrelic.com"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-08-02T04:05:45Z",
      "updated_at": "2021-07-27T06:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.94093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": " Relic data types Metrics: see the <em>Metric</em> <em>API</em> Logs: see the Log <em>API</em> Traces: see the <em>Trace</em> <em>API</em> Events: see the <em>Event</em> <em>API</em> Write your own <em>Telemetry</em> <em>SDK</em> or contribute to an existing one If you need a <em>Telemetry</em> <em>SDK</em> in a language that does not currently exist or want to contribute to an existing library"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "FedRAMP-compliant endpoints",
        "Customer FedRAMP obligations",
        "Overview of data sources",
        "Agents",
        "APM agents",
        "Mobile monitoring agents",
        "Infrastructure monitoring",
        "Infrastructure agent versions below 1.15.0",
        "Browser agent",
        "Data-ingest APIs",
        "Metric API",
        "Telemetry integrations",
        "Telemetry SDKs",
        "Event API",
        "Log API",
        "Log forwarders",
        "Trace API"
      ],
      "title": "FedRAMP-compliant endpoints",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "ffce8ad6f802717392aca80e0965c9f3fe77ffdf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/fedramp-compliant-endpoints/",
      "published_at": "2021-08-02T19:14:19Z",
      "updated_at": "2021-07-10T03:00:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides information on FedRAMP-compliant endpoints in New Relic. For more information about our security accreditation for the Federal Risk and Authorization Management Program (FedRAMP), see our data encryption documentation. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features (see below). Overview of data sources There are multiple ways to get data into New Relic. This doc has two sections: Agent settings: for our APM agents, infrastructure agent, browser agent, and mobile agent. Data-ingest APIs: for our Metric API, Event API, Trace API, and Log API, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents, and browser agent. Setting these agents to send FedRAMP-compliant data involves setting a configuration setting to use the relevant FedRAMP endpoint. APM agents To ensure FedRAMP compliance, all APM agent configurations must report to gov-collector.newrelic.com rather than the default. Depending on the agent, you can either use code-based configuration or an environment variable. Here are details on enabling this: Language Code or environment variable C SDK In code: strcpy(_newrelic_app_config_t->redirect_collector, \"gov-collector.newrelic.com\"); Copy Environment variable: none Go In code: app, err = newrelic.NewApplication( newrelic.ConfigAppName(\"App Name\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), func(cfg *newrelic.Config) { cfg.Host = \"gov-collector.newrelic.com\" }, ) Copy Environment variable: NEW_RELIC_HOST Java In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Or set a system property of: newrelic.config.host Copy Environment variable: NEW_RELIC_HOST .NET In your XML config next to the license key: <service licenseKey=\"YOUR_LICENSE_KEY\" host=\"gov-collector.newrelic.com\"/> Copy Environment variable: NEW_RELIC_HOST Node.js In newrelic.js: host: 'gov-collector.newrelic.com' Copy Environment variable: NEW_RELIC_HOST PHP In newrelic.ini: newrelic.daemon.collector_host = gov-collector.newrelic.com Copy Environment variable: none Python In newrelic.ini: [newrelic] host = gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Ruby In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Elixir (open source agent) In config.exs: config :new_relic_agent, host: \"gov-collector.newrelic.com\" Copy Environment variable: NEW_RELIC_HOST For more on configuring APM agents, see APM configuration. Mobile monitoring agents To ensure FedRAMP compliance when using our mobile monitoring agents, all agent configurations must report to gov-mobile-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables are not available. Framework-specific configurations: Agent Code or environment variable Android In code: NewRelic.withApplicationToken({APP_TOKEN}) .usingCollectorAddress(\"gov-mobile-collector.newrelic.com\") .usingCrashCollectorAddress(\"gov-mobile-crash.newrelic.com\") .start(this.getApplication()); Copy Environment variable: none iOS In code: [NewRelic startWithApplicationToken:@\"{APP_TOKEN}\" andCollectorAddress:@\"gov-mobile-collector.newrelic.com\" andCrashCollectorAddress:@\"gov-mobile-crash.newrelic.com\"]; Copy Environment variable: none Infrastructure monitoring If you have infrastructure agent version 1.15.0 or higher, simply enable the FedRAMP configuration option. If you have an older agent version, use the following values to edit your YAML configuration: Infrastructure agent versions below 1.15.0 If you have an infrastructure agent version below 1.15.0, you must change three of the endpoints used for reporting. To set these endpoints, you can change your YAML configuration or use environment variables. YAML config field Endpoint URL collector_url https://gov-infra-api.newrelic.com Copy identity_url https://gov-identity-api.newrelic.com Copy command_channel_url https://gov-infrastructure-command-api.newrelic.com Copy To edit environment variables, use these values: Environment variable Endpoint URL NRIA_COLLECTOR_URL https://gov-infra-api.newrelic.com Copy NRIA_IDENTITY_URL https://gov-identity-api.newrelic.com Copy NRIA_COMMAND_CHANNEL_URL https://gov-infrastructure-command-api.newrelic.com Copy Browser agent To configure the browser agent to use a FedRAMP-compliant endpoint, you must use the copy-paste method method (other browser agent install methods are not supported) and edit the browser code’s script element tag so that the domain is gov-bam.nr-data.net for both beacon and errorBeacon, like this: window.NREUM||(NREUM={});NREUM.info={\"beacon\":\"gov-bam.nr-data.net\",\"errorBeacon\":\"gov-bam.nr-data.net\"... Copy Note: You only need to modify the beacon and errorBeacon properties in the NREUM.info object. These values will override the default values found in the NR loader script. Data-ingest APIs Below are details about the FedRAMP endpoint for our ingest APIs: Metric API, the Event API, the Log API, and the Trace API. Metric API To ensure FedRAMP compliance when using the Metric API, instead of sending metric data to the default Metric API endpoint of https://metric-api.newrelic.com/metric/v1, it must be sent to https://gov-metric-api.newrelic.com/metric/v1. The Metric API can be used directly but it's mainly used by various New Relic tools. Below are instructions showing where to edit the configuration for setting the FedRAMP endpoint. Telemetry integrations Here are instructions for our open source telemetry integrations that report metric data: Dropwizard: use the overrideUri configuration. Kamon: use the metric-ingest-url configuration. See Override endpoints. Micrometer: override the public String uri() method on your NewRelicRegistryConfig to return the new endpoint. See an example. Prometheus: Prometheus OpenMetrics: if you are using our nri-prometheus helm chart, you can change the endpoint in your values.yml file, like in this example. If you're using the nri-bundle chart, you need to nest this value under the nri-prometheus key to propagate it to the sub-chart. Remote write integration: not available. Telemetry SDKs Here are instructions for our Telemetry SDKs that report metric data: Go: use the MetricsURLOverride configuration. Java: in the MetricBatchSender section, configure the endpoint. See an example. .NET: use the MetricUrlOverride configuration. Node.js: edit the METRIC_HOST = 'metric-api.newrelic.com' configuration. Python: edit the HOST = \"metric-api.newrelic.com\" configuration. Event API To ensure FedRAMP compliance for the Event API, all traffic reporting to insights-collector.newrelic.com must instead report to gov-insights-collector.newrelic.com. The Event API endpoint is configurable for the following Telemetry SDKs. The Telemetry SDKs are used by our open-source telemetry integrations. Language Solution Java Telemetry SDK In code: SenderConfiguration configuration = SenderConfiguration .builder( \"gov-insights-collector.newrelic.com\", EventBatchSender.EVENTS_PATH) .build(); EventBatchSender eventBatchSender = EventBatchSender.create(configuration); Copy Python Telemetry SDK In code: event_client = EventClient(host=\"gov-insights-collector.newrelic.com\") Copy For more information, see our Telemetry API documentation in GitHub. Log API To ensure FedRAMP compliance for data sent via the Log API, the solution for almost all our logging tools is to replace the https://log-api.newrelic.com/log/v1 endpoint with https://gov-log-api.newrelic.com/log/v1. Here are details for various tools: Log forwarders Here are details on changing the endpoint for our log forwarders: AWS Firelens: Add the endpoint property to the options field of the logConfiguration, similar to to the EU account endpoint change shown in these Firelens endpoint configuration instructions. Fluentbit: Use our Fluentbit endpoint configuration. Fluentd: Use our Fluentd endpoint instructions. Infrastructure agent: See FedRAMP for infrastructure. Kubernetes: Our Kubernetes integration logs are based on fluentbit’s output plugin. Use these endpoint instructions. Logstash: Use our Logstash endpoint configuration. Syslog: For configuring syslog clients, see TCP endpoint configuration. S3: Not available. Vector: Not available. To use the Log API directly, you'd edit the Log API endpoint configuration. Trace API To ensure FedRAMP compliance for data sent via the Trace API (including telemetry integrations that use this API), replace the https://trace-api.newrelic.com/trace/v1 endpoint with https://gov-trace-api.newrelic.com/trace/v1. Notes about FedRAMP compliance for other trace data: Trace data is reported by some of our agents, like our APM agents, browser agent, and mobile agent. To enable FedRAMP compliance for that data, you would enable FedRAMP for the applicable agent. Currently Infinite Tracing is not FedRAMP compliant.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.95654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> <em>API</em>",
        "body": " APM agents, infrastructure <em>agent</em>, browser <em>agent</em>, and mobile <em>agent</em>. Data-ingest APIs: for our <em>Metric</em> <em>API</em>, <em>Event</em> <em>API</em>, <em>Trace</em> <em>API</em>, and Log <em>API</em>, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents"
      },
      "id": "603e945164441f64384e8872"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Tip",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-08-02T03:49:05Z",
      "updated_at": "2021-07-27T05:55:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve mobile monitoring data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, child accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.16466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "<em>Telemetry</em> <em>APIs</em> for core data types",
        "tags": "<em>APIs</em>",
        "body": " synthetics monitors, use the Alerts <em>API</em>. <em>Telemetry</em> APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed <em>agent</em>. Data type Description <em>Trace</em> <em>API</em> Send distributed tracing data to New Relic"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-custom-event-data/",
      "sections": [
        "Report custom events and attributes",
        "Requirements",
        "Avoid rate limits",
        "Example use cases",
        "Using custom attributes",
        "Using custom events",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "published_at": "2021-08-02T06:00:24Z",
      "title": "Report custom events and attributes",
      "updated_at": "2021-07-09T20:06:23Z",
      "type": "docs",
      "external_id": "e50a9be8b3df5859c6307c8642942006f537578d",
      "document_type": "page",
      "popularity": 1,
      "body": "One of the ways to report custom data to New Relic is with custom events and attributes. Have questions about why you'd use custom data? See Introduction to custom data. Requirements For event and attribute formatting requirements and best practices, see Limits and requirements. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Example use cases Two popular custom data solutions are custom events and custom attributes. There are several ways to accomplish this (more on that later in this doc), depending on your New Relic implementation and tools. Here are some common use cases for implementing custom events and attributes. Using custom attributes Custom attributes are often used to add important business and operational context to existing events. Business context might include: Customer token Customer market segment Customer value classification Workflow control values not obvious in the URIStem User/product/account privilege context Operational context might include: Which feature flags were used What datastore was accessed What cache was accessed What errors were detected and ignored (fault partitioning) Using custom events Event data is one of New Relic's four core data types. We recommend reading that definition to understand what we mean by \"event\" and why that data type is most used for reporting specific types of activity. The use cases for custom events varies widely: basically they are used for any type of activity that an organization deems important and that is not already being monitored. A couple examples: An event might represent an activity involving multiple actions, like a customer purchasing a certain combination of products. An event might record backup activity. For example, they might set up reporting of events that represent production backups of their SOLR instances into an event table, with a timestamp of when it occurred, which cluster, and the duration. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the browser API call addCustomAttribute. Send PageAction event and attributes via browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.60343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>events</em> and attributes",
        "sections": "Report custom <em>events</em> and attributes",
        "body": " custom attributes to the SyntheticCheck <em>event</em> via the $util.insights tools. For ways to report other types of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em> <em>API</em> Extend data retention To learn how to extend how long events are retained in your account, see our documentation about <em>event</em> data retention."
      },
      "id": "609fa5fb64441f9ebfd2a1db"
    },
    {
      "sections": [
        "Query system limits",
        "Important",
        "What happens when you reach a limit",
        "Tip",
        "Create a dashboard to view your limit status",
        "Resource Consumption Limits as a %",
        "Max % Consumption in an hour",
        "APM Agent API transaction events request per minute",
        "Trace API With limit line",
        "Impact FACET",
        "NrIntegrationError by limit",
        "Multi-Account limits (on time series charts only)",
        "Limit list and NrIntegrationError",
        "Limit metrics",
        "newrelic.resourceConsumption.limitValue",
        "newrelic.resourceConsumption.currentValue",
        "newrelic.resourceConsumption.impact",
        "Metric attributes",
        "Set alerts on resource metrics",
        "Limits faceted by LimitName and scoped by Timewindow",
        "Alert on a single limit",
        "Alert on limit impact faceted by dataType, impact, resource, and reason",
        "Alert on impact of a single dataType"
      ],
      "title": "Query system limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest data manage data",
        "Manage data",
        "Resource metrics",
        "system limits"
      ],
      "external_id": "f8ca2368c70e4e339cd838d0ad192dd2c40fac0a",
      "image": "https://docs.newrelic.com/static/16cb17d5244a118d794df354f67bab81/c1b63/limits-dashboard.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/query-limits/",
      "published_at": "2021-08-02T03:41:25Z",
      "updated_at": "2021-07-22T06:31:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has resource limits in place to protect your experience, our systems, and our other customers. These limits range from the maximum number of characters you can have in a query, to API request rates, to how many events your queries inspect, and more. This page describes the limit metrics and NrIntegrationError events that enable you to view your limits, your current data usage and overall resource consumption as compared to those limits, and the impact of experiencing a limit event. We also provide a handful of queries that, when compiled into a dashboard, can give you consistent insight into your limits status. Important While NrIntegrationError events cover many limits, resource metrics currently only cover request rate ingestion limits. What happens when you reach a limit Our response to reaching a limit depends on a handful of factors: the type of limit that’s reached, as well as the duration, frequency, and amount at which you exceed the limit. Exceeding a limit doesn’t always mean you experience a limit event, such as dropped data, rejected traffic, or having your data turned off for the rest of the day. We sometimes allow a small buffer before enforcing a limit. That said, any resource consumed above 100% is at risk for limit impact at any time. Many of our rate limits apply proportionally. That means if you’re barely exceeding the limit, we will take less action than if you're exceeding by 200%. Limit metrics are only visible if you're sending data in to a corresponding dataType or limitName API. For example, if you send in data via the Metric API, you’ll see the Metric API resource metrics, but if you don't send any APM data in, you won't see APM resource metrics. Tip Impact metrics will be generated regardless of impact; if there's no impact, you’ll see a 0. An NrIntegrationError is generated when you experience impact and is a good way to quickly see if you’re experiencing any limit events. See View System Limits for more information. Create a dashboard to view your limit status Using three limit metrics together on a dashboard, you can quickly see detailed visuals of your Ingest Resource Request Per Minute limits, and with NrIntegrationError get a view into more limits. Dashboard displaying limits status using a handful of queries. We used the following queries to create this dashboard. To make a dashboard like this in New Relic One, select Dashboards, and then Create a dashboard. Then, add a new chart for each query you want to regularly monitor. The three limits metrics included in these queries are described in a separate section, below. From left to right, top to bottom: Resource Consumption Limits as a % FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) /latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName where limitTimeInterval = '1 minute' timeseries limit max Copy Max % Consumption in an hour SELECT max(`usage`) FROM (FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 as 'usage' facet limitName timeseries ) facet limitName limit max Copy APM Agent API transaction events request per minute FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) where limitName = 'APM Agent API transaction events requests per minute' TIMESERIES Copy Trace API With limit line FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'usage', latest(newrelic.resourceConsumption.limitValue) as 'limit' where limitName = 'Trace API requests per minute' TIMESERIES Copy Impact FACET From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource TIMESERIES 1 minute limit max Copy NrIntegrationError by limit FROM NrIntegrationError select count(*) facet limitName TIMESERIES MAX since 1 day ago limit max Copy Multi-Account limits (on time series charts only) If you want to see limits for multiple accounts on one chart: run this query from one of the accounts: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Click Add another query. Select a different account. Then run this query again: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Finally, save it. Limit list and NrIntegrationError FROM Metric, NrIntegrationError select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'Per Minute Count',latest(newrelic.resourceConsumption.limitValue) as ' limit Value',(rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue)*100)as 'Percent Used', filter (count(*), where NrIntegrationError.limitValue is not null) as 'limit reached count' facet limitName limit 1000 Copy Limit metrics These metrics, used in the dashboard queries above, can hone in on a single limit or resource. Or, with the help of FACET limitName or resource provide a view across all your limits. newrelic.resourceConsumption.limitValue limitValue allows you to see the setting for a limit by limitName and understand more about what resource is linked to this limit. The following examples use the limit value metric in the query: Example for Metric API requests per minute. FROM Metric select latest(newrelic.resourceConsumption.limitValue) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select latest(newrelic.resourceConsumption.limitValue) WHERE limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.currentValue currentValue shows you how much of a given resource you’re currently consuming. To get a better glimpse into how our systems are viewing your consumption, use a rate() function with the time period that aligns with the limitTimeInterval. Limit 200. Example for Metric API request per minute: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.impact impact lets you know for any given resource what impact limit events are having. Zeros mean you are not currently impacted. The most granular we have is dataType. It is possible for multiple instances of limitName to impact a single type, such as Metric RPM and DPM. If we know, we will display limitName. From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, resource, impact, limitName TIMESERIES limit max Copy Metric attributes Attributes on newrelic.resourceConsumption.limitValue and newrelic.resourceConsumption.currentValue: limitName - The Name of the limit for the metric data, i.e RPM Metric API. dataType - What kind of data the metric is tracking, i.e Metric, Log, or APM. Resource - What resource is being consumed, i.e. Requests, or DPM. limitTimeInterval - What time window this resource is evaluated for limiting. consumingAccountId - The New Relic account where the resource is being consumed. Attributes on newrelic.resourceConsumption.impact dataType - The kind of data that is being impacted, i.e Metric, Log, APM. Resource - What resource is being impacted, i.e Request Rate. Impact - A count of what is happening when resource has exceeded set limit, i.e dropped requests. consumingAccountId - The New Relic account where the resource is being consumed. Set alerts on resource metrics While building a dashboard to see all your limits is handy, being able to automate it is even better. You can set alerts on your limit metrics to provide updates on limits changes. Tip Because we currently only have metrics on 1 minute time windows, setting TimeWindow = 1 minute, will cover them all. Eventually, we make more metrics available, you might want to set separate alerts for limits that are enforced by different time windows. You can use the following NRQL queries to create alerts. Learn about creating alerts with NRQL queries here. Limits faceted by LimitName and scoped by Timewindow From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 facet limitName Copy Alert on a single limit From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 where limitName = 'my limit' Copy Alert on limit impact faceted by dataType, impact, resource, and reason From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason Copy Alert on impact of a single dataType From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason WHERE dataType = 'important things' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.15052,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "APM <em>Agent</em> <em>API</em> transaction <em>events</em> request per minute",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": " limitName = &#x27;APM <em>Agent</em> <em>API</em> transaction events requests per minute&#x27; TIMESERIES Copy <em>Trace</em> <em>API</em> With limit line FROM <em>Metric</em> select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as &#x27;usage&#x27;, latest(newrelic.resourceConsumption.limitValue) as &#x27;limit&#x27; where limitName = &#x27;<em>Trace</em> <em>API</em> requests"
      },
      "id": "608abed9196a67a63064a7a6"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add your custom visualization to a dashboard",
        "Enable advanced configurations for your Nerdpack",
        "Create a \"Hello, World!\" application",
        "Customize your visualization with configuration options",
        "Add a table to your app",
        "Customize your visualization with SDK components",
        "Nerdpack permissions",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-05-11T01:42:22Z",
      "title": "Build apps",
      "updated_at": "2021-05-11T01:41:00Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize your visualization with configuration options 10 min Customize your visualization using configuration Add a table to your app 30 min Add a table to your New Relic One app Customize your visualization with SDK components 25 min Customize your visualization Nerdpack permissions   Learn about permissions for using and subscribing accounts to Nerdpacks Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.08965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " Customize your visualization Nerdpack permissions   Learn about permissions for using and subscribing accounts to Nerdpacks Create a custom map view 30 min Build an <em>app</em> to show page view data on a map <em>Publish</em> and <em>deploy</em> <em>apps</em> 30 min Start sharing the <em>apps</em> you build Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure and deploy",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "28df1194ff848b2c26e5c966843d2bf5f0adbf9e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:50:44Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Copy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Copy Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 31.253109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "6043d8da28ccbc08242c60a6"
    },
    {
      "sections": [
        "Install the Go agent in GAE flexible environment",
        "Important",
        "Build a custom runtime using Docker",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure a Dockerfile",
        "4. Build a Docker image",
        "5. Deploy Docker image to initialized GAE flexible environment",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE"
      ],
      "title": "Install the Go agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Installation"
      ],
      "external_id": "9d2ddffb83697c6191c0b6abaed8839516b3aa54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-go-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:50:22Z",
      "updated_at": "2021-03-11T07:58:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our Go agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. Here we explain how to add New Relic to your GAE flex app by configuring a custom runtime, and give an example of deploying a Go app with Docker. Important The Go agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the Go agent, building a custom Go runtime for Docker, and deploying a golang application. For more information about deploying and configuring your Go app in the GAE flexible environment, see: Google App Engine's documentation for Go Google App Engine's tutorials to deploy a Go app 1. Set up the GAE project and install dependencies Follow standard procedures to install the Go agent for your specific app server, including your license key. Follow Google App Engine procedures for Go to create a new Cloud Platform project, create an App Engine application, download and install git, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example code defines the golang version used. FROM golang:1.8-onbuild CMD go run main.go Copy 4. Build a Docker image To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . Copy 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud --project go-app-name app deploy Copy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Copy Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see GAE's documentation for debugging an instance. To redirect New Relic Go agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 23.883669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "2. Configure your <em>app.yaml</em>",
        "body": " the gcloud command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure your <em>app</em>.yaml The <em>app</em>.yaml configuration file is required for a GAE flexible environment <em>app</em> with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy 3. Configure a Dockerfile The Dockerfile"
      },
      "id": "6043cd7164441fc312378efe"
    },
    {
      "sections": [
        "Install the Python agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure a Dockerfile",
        "4. Deploy Docker image to initialized GAE flexible environment",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE"
      ],
      "title": "Install the Python agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Hosting services"
      ],
      "external_id": "263d4c02b1f69a2acfd5949eb949045802324be4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/hosting-services/install-python-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:49:55Z",
      "updated_at": "2021-03-16T05:26:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Python agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding agent data to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic One. This document explains how to add agent data to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. For example, to deploy with native support for a Flask/Django app: Follow standard procedures to install the Python agent, including your license key. Set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to newrelic.ini. Once the agent and configuration file have been installed, the Python agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add agent data to your GAE flex app by building a custom runtime for Docker. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Our GAE flex examples on Github for Python Google App Engine's documentation for Python Google App Engine's tutorials to deploy a Python app 1. Set up the GAE project and install dependencies When building a custom runtime using Docker, set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to the Dockerfile instead of to your Python app's newrelic.ini. Follow standard procedures to install the Python agent, including your license key. Follow Google App Engine procedures Python to create a Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK also provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom Copy 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example shows the Python agent installed for an application served with gunicorn. These procedures are similar to the Python quick start guide. The Dockerfile will contain customer-specific code, including Python version, installation requirements, etc). # [START dockerfile] FROM gcr.io/google_appengine/python # Install the fortunes binary from the debian repositories. RUN apt-get update && apt-get install -y fortunes # Optional: Change the -p argument to use Python 2.7. RUN virtualenv /env -p python3.5 # Set virtualenv environment variables. This is equivalent to running # source /env/bin/activate. ENV VIRTUAL_ENV /env ENV PATH /env/bin:$PATH ADD requirements.txt /app/ RUN pip install -r requirements.txt ADD . /app/ CMD NEW_RELIC_CONFIG_FILE=newrelic.ini newrelic-admin run-program gunicorn -b :$PORT main:app # [END dockerfile] Copy 4. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Copy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse Copy To view your GAE flex app data, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Copy Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect Python agent logs to Stackdriver in the Cloud Platform Console, add the following statement to the newrelic.ini configuration: log_file = stderr Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 19.625206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "body": " explains how to <em>add</em> agent data to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime <em>Deploy</em> using GAE&#x27;s native support When using Google <em>App</em> Engine &quot;native mode&quot; installation, you provide"
      },
      "id": "603e8457196a675796a83dcc"
    },
    {
      "sections": [
        "Install New Relic Ruby agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "Tip",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure a Dockerfile",
        "4. Build a Docker image",
        "5. Deploy Docker image to initialized GAE flexible environment",
        "Recommendation: Handle health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Ruby agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Installation"
      ],
      "external_id": "3b7b7ad122a7ba4b37d5edf892bd462bac8fbe62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/installation/install-new-relic-ruby-agent-gae-flexible-environment/",
      "published_at": "2021-05-09T17:50:23Z",
      "updated_at": "2021-03-13T07:26:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With APM's Ruby agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view using Full-Stack Observability options like APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime The custom runtime method includes an example of deploying a Sinatra app. If you need specific libraries or headers, New Relic recommends using the custom runtime method. Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. To deploy with native support for Sinatra or Rails: Follow New Relic's standard procedures to install the gem, including your license key. Install the Ruby agent configuration file. Once the gem and configuration file have been installed, the Ruby agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker Tip If your Ruby app needs specific libraries or headers, New Relic recommends using the custom runtime method. In addition, New Relic recommends that you allow Google App Engine to handle health checks. See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. The example uses a Sinatra app for Ruby. For more information about deploying and configuring your Ruby app in the GAE flexible environment, see: Google App Engine's documentation for Ruby Google App Engine's tutorials for Ruby 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Ruby agent, including your license key. Follow Google App Engine procedures for Ruby to create a new Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom entrypoint: bundle exec ruby app.rb Copy 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the recommended base image for apps monitored by the New Relic Ruby agent: FROM gcr.io/google-appengine/ruby:latest Copy 4. Build a Docker image Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build -f Dockerfile -t custom_ruby_app_container:latest . Copy After running this command, verify that you have a Docker image named custom_ruby_app_container and tagged latest. 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Copy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse Copy To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Handle health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. New Relic recommends that you allow health checks for Ruby apps so that Google can check that your service is up and balanced properly. However, if excessive health checks cause congested transaction traces, you can set the Ruby agent to ignore the health check requests. To handle health checks, add a route for _ah/health in your app. To ignore health check requests, set the rules.ignore_url_regexes config setting in the application’s Ruby agent config to include '_ah/health'. Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Ruby agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 19.500391,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "body": " like APM and browser monitoring. This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime The custom runtime method includes an example"
      },
      "id": "604404a6196a6738b9960f75"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "46f2be93b0c4daf40da9b93cfe0fbf5f235eecb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-08-02T05:33:04Z",
      "updated_at": "2021-07-16T03:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.56577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": "This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements may apply based on the method you use. You can report <em>custom</em> <em>events</em> to New Relic in several ways, including: APM <em>agent</em> <em>APIs</em> <em>Event</em> <em>API</em>"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-08-02T06:00:24Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.56618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser <em>API</em>&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "30a7ec0f78ddde237cb20265ab9702582f5bc2ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-08-02T06:01:32Z",
      "updated_at": "2021-07-09T22:19:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.50041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " and <em>events</em> You can create <em>custom</em> session-level attributes for default mobile monitoring <em>events</em> using the mobile <em>agent</em> SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute <em>API</em> (Android | iOS). These attributes are session-related"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-08-02T05:33:04Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.9387,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " of <em>events</em> can increase the memory overhead of the <em>agent</em>. New Relic enforces an upper limit of 833 <em>custom</em> <em>events</em> every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the <em>custom</em> <em>event</em> limit. You can also send <em>custom</em> <em>events</em> using the <em>Event</em> <em>API</em>"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-08-02T03:52:39Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.26984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Insights Dashboard <em>API</em>",
        "sections": "Insights Dashboard <em>API</em>",
        "tags": "<em>Event</em> data sources",
        "body": ", watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic <em>APIs</em>. Use <em>API</em> endpoints The <em>API</em> supports the following functions for Insights dashboards only. The <em>API</em> does not support these functions for data apps (collections of linked dashboards). <em>API</em> endpoints"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    }
  ],
  "/try-our-apis": [
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-08-03T01:41:02Z",
      "updated_at": "2021-08-02T22:59:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Add muting rules to suppress notifications Manage notification channels Customize loss of signal and gap filling The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 601.3895,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using Alerts via <em>NerdGraph</em> <em>API</em>",
        "sections": "Intro to using Alerts via <em>NerdGraph</em> <em>API</em>",
        "tags": "<em>New</em> <em>Relic</em> Alerts",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our <em>GraphQL</em> <em>NerdGraph</em> <em>API</em>. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the REST <em>API</em>. Alerts features you can manage with <em>NerdGraph</em> Here&#x27;s what you can do in <em>NerdGraph</em>: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 513.44977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add the <em>NerdGraphQuery</em> component to an application",
        "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and <em>GraphQL</em>, you can create custom views tailored to your business. These guides are designed to help you start"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "28cac5fac1065f4b1756700e7f6c11c325734c35",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/log-management/ui-data/data-partitions/",
      "published_at": "2021-08-03T01:40:03Z",
      "updated_at": "2021-08-02T09:49:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic Logs: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our graphQL API, to do so. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 506.56427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Manage data partitions programatically with <em>NerdGraph</em>",
        "body": " one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with <em>NerdGraph</em> If you want to manage your data partitions programatically, you can use <em>NerdGraph</em>, our <em>graphQL</em> <em>API</em>, to do so. This tutorial shows how to query, create, and delete data partitions using our <em>API</em>."
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-08-03T06:47:30Z",
      "updated_at": "2021-07-27T11:27:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 495.35147,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": "<em>NerdGraph</em> is our <em>GraphQL</em>-format <em>API</em> that lets you query <em>New</em> <em>Relic</em> data and configure some <em>New</em> <em>Relic</em> features. What is <em>NerdGraph</em>? <em>New</em> <em>Relic</em> has several <em>APIs</em>. <em>NerdGraph</em> is our preferred <em>API</em> for querying <em>New</em> <em>Relic</em> data, and for performing some specific configurations (learn more about features"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Introduction to the Trace API",
        "What is the Trace API?",
        "Requirements",
        "Sampling considerations",
        "Start reporting data",
        "Find data",
        "Next steps"
      ],
      "title": "Introduction to the Trace API",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Trace API"
      ],
      "external_id": "119447fbb33c4469c81877ffaa273bd7b1956e9f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/trace-api/introduction-trace-api/",
      "published_at": "2021-08-03T01:40:03Z",
      "updated_at": "2021-08-02T03:18:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Trace API is used to send distributed tracing data to New Relic: either in our own generic format or the Zipkin data format. This API is also how trace data from some of our integrations and exporters is reported to New Relic. Want to try out the Trace API? Make sure you you've created a free New Relic account. No credit card required. To skip some introductory content and get started quickly, go to Start reporting data. What is the Trace API? The Trace API is one way that New Relic collects distributed tracing data. We have some tracing tools that report data via this API (Infinite Tracing, our open source integrations, and our Telemetry SDKs), or you can use the API directly to create your own tracing implementation. Reasons to use the Trace API: You have your own custom distributed tracing tool and want to see that data in New Relic without changing your instrumentation. You have a tool that emits tracing data but that requires a backend for trace storage. You want to report distributed tracing data to New Relic without the use of our installed solutions. You use Zipkin and want to see that trace data in New Relic without changing your instrumentation. Want to understand how trace data relates to other New Relic data? Read about our data types. Requirements For details about what data you can send and how it is handled, see Rules and limits. Sampling considerations When using the Trace API, you have the option to enable Infinite Tracing. Whether you use Infinite Tracing has implications for how you configure sampling: Use your own sampling (no Infinite Tracing): If you don't use Infinite Tracing, it's assumed you want to use your own sampling implementation to sample traces before they're sent to us. (If your trace data exceeds our data limits, we do enact sampling.) Use Infinite Tracing: If you want to use Infinite Tracing, a typical approach is to send us 100% of your trace data and rely on Infinite Tracing sampling. (When you go through the Start reporting data instructions, below, you'll have an option for enabling Infinite Tracing.) Start reporting data The Trace API accepts trace data in these two JSON formats: zipkin: the Zipkin JSON v2 trace data format (learn what Zipkin is). Get started sending Zipkin data. newrelic: our general format. If you don't have Zipkin-format data, use this. Get started sending New Relic-format data. Having problems getting data to report? See Troubleshooting. Find data You can find data sent via the Trace API, or from integrations that use this API, in these locations: In our distributed tracing UI. By querying: For details about how to query and create custom charts, see Query distributed tracing data. Next steps Here are some additional steps to consider: Learn more about how distributed tracing works and the data structure. Decorate span data with custom attributes. Use our GraphQL-based NerdGraph API to programmatically query your trace data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 493.79727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Trace <em>API</em>",
        "sections": "Introduction to the Trace <em>API</em>",
        "tags": "Trace <em>API</em>",
        "body": " steps Here are some additional steps to consider: Learn more about how distributed tracing works and the data structure. Decorate span data with custom attributes. Use our <em>GraphQL</em>-based <em>NerdGraph</em> <em>API</em> to programmatically query your trace data."
      },
      "id": "6071cf7728ccbcf4bc51c16a"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-08-03T01:39:42Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 685.0428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple tags to one"
      },
      "id": "6091f7c828ccbc8813a268b2"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Automate workflows",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 620.43744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Partial or missing logs for RDS, VPC, AWS Lambda",
        "Problem",
        "Solution"
      ],
      "title": "Partial or missing logs for RDS, VPC, AWS Lambda",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "Troubleshooting"
      ],
      "external_id": "66a81a2fa3b8b27bf6172c9bb2c3ecf28bbe13e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/troubleshooting/partial-or-missing-logs-rds-vpc-aws-lambda/",
      "published_at": "2021-08-02T11:28:28Z",
      "updated_at": "2021-03-13T01:15:24Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You are using NewRelic-log-ingestion, the lambda function for pushing logs from AWS to our RDS Enhanced Monitoring, VPC Flow Logs integrations, or early versions (alpha and beta) of monitoring for AWS Lambda. It is not working or it is sending partial data. Solution The NewRelic-log-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the New Relic CLI or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update the function using the New Relic CLI. You can also update the function manually: Avoid false positives in alerting: Follow UI procedures or API procedures to disable all alert conditions associated with monitoring integrations with AWS Lambda, RDS Enhanced Monitoring, and VPC Flow Logs. Remove the outdated lambda version of the lambda: Go to your AWS Lambda Console, and remove newrelic-log-ingestion. Be aware that this stops the RDS Enhanced Monitoring and the VPC Flow Logs integration until the next step is completed. Re-enable the service: Follow the instructions in RDS Enhanced Monitoring or VPC Flow Logs, or follow the step to configure CloudWatch logs to stream to New Relic Lambda. Check that your data is flowing through the new lambda.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.47205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the <em>New</em> <em>Relic</em> <em>CLI</em> or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update"
      },
      "id": "60450c97196a672ffa960f57"
    },
    {
      "sections": [
        "Secrets management",
        "Define secrets",
        "Important",
        "Tip",
        "Using environment variables",
        "Secrets variables",
        "AWS KMS secrets",
        "Vault secrets",
        "tls_config properties",
        "CyberArk command line interface",
        "CyberArk REST API",
        "New Relic CLI Obfuscation"
      ],
      "title": "Secrets management",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "Installation"
      ],
      "external_id": "8e05204a80a9475aee87d85a4be07cff710faa31",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management/",
      "published_at": "2021-08-02T11:45:21Z",
      "updated_at": "2021-03-16T06:02:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and New Relic CLI obfuscation are supported. Define secrets To use secrets in a configuration YAML file: Define a variables section, where each entry is a name for a secret object. In each entry, include the source of the secret and the proper configuration to retrieve those secrets. In the general configuration section, set ${variable.property} placeholders that will be automatically replaced by the properties of the secret object. The secret object can be defined as a simple string or json object. Important If the secrets retrieval fails, the integration won't be executed, as the infrastructure agent does not have all the data it requires to execute. For example, the following configuration will retrieve an object named creds from Vault (you can define the object's name for the secret.) Let's assume that the stored object is a valid JSON with a property named user and another property named password. We want to use them to set the basic HTTP credentials of the status_url property from an Nginx on-host integration: integration_name: com.newrelic.nginx variables: creds: vault: http: url: http://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true labels: env: production role: load_balancer Copy Tip Both simple strings and valid JSON objects can be retrieved from variables. When using JSON objects make sure both keys and values are enclosed with double-quotes. Using environment variables Environment variables can be used into the variables section with the {{MY_ENV_VAR}} notation. When doing so, environment variables are expanded and their value is replaced at runtime. Use this method to avoid having sensitive values such as tokens or obfuscation keys included in the configuration file. When using environment variables in on-host integration configuration files the passthrough_environment setting must be defined. Secrets variables Define secrets in each configuration under a variables section. Each entry is a user-defined secret name that will store the properties of the retrieved secrets. Each variable can contain the following properties: YAML key Description ttl Type: String Amount of time before a secret is refreshed. This can be a number followed by a time unit (s, m or h). Examples: 30s, 10m, 1h Default: 1h aws-kms AWS KMS secret retrieval configuration vault Vault secret retrieval configuration cyberark-cli CyberArk command line interface configuration cyberark-api CyberArk REST API configuration obfuscated New Relic CLI obfuscation AWS KMS secrets To retrieve your secrets from Amazon KMS, you can set the following properties in your aws-kms section. Not all fields are required. For example, you will need either data, file, or http to provide the encoded KMS string. YAML key Description data Type: String Base64 encoded KMS string to decrypt file Type: String Path to file containing Base64 encoded KMS string to decrypt http Type: YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file region Type: String AWS KMS region type Type: String (plain, equal, or json) Secret value format: plain: a raw string to be stored directly into the destination variable. equal: a key=property one-line string to be stored as object properties into the destination variable. json: a JSON object to be stored as properties into the destination variable. Secrets of type plain or json use dot notation; for example, ${mysecret.nestedkey}. The following example will allow retrieving a plain password string from AWS KMS. It must be decrypted from the provided data encoded string. variables: myPassword: aws-kms: data: T0hBSStGTEVY region: ap-southeast-2 credential_file: \"./my-aws-credentials-file\" config_file: \"./my-aws-config-file\" type: plain Copy Vault secrets Vault must enable an http field containing the HTTP configuration used to connect to Vault. The http entry can contain the following entries: YAML key Description url Type: String URL to request data from tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers tls_config properties Important Secrets must use dot notation, for example, ${mysecret.nestedkey}. YAML key Description enable Type: Boolean Enable TLS Default: false insecure_skip_verify Type: Boolean Skip verifying server’s certificate chain and host Default: false min_version Type: UInt16 The minimum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.0) max_version Type: UInt16 The maximum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.3) ca Type: String TLS certificate \"\" The following example will retrieve a secret using a Vault token from a secured server, and skip the server certificates verification: variables: mydata: vault: http: url: https://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token tls_config: insecure_skip_verify: true Copy CyberArk command line interface To retrieve secrets from the CyberArk command line interface (CLI) use the following configuration, all keys are required YAML Key Description cli Type: string Full path to the CyberArk CLI executable Default: \"\" app-id Type: string Application id of the secret holder Default: \"\" safe Type: string Safe containing the secret Default: \"\" folder Type: string Folder containing the secret Default: \"\" object Type: string The object the secret is associated with Default: \"\" The following example will retrieve a CyberArk secret using the command line interface: variables: credentials: cyberark-cli: cli: /full/path/to/clipasswordsdk app-id: my-appid safe: my-safe folder: my-folder object: my-object Copy CyberArk REST API To retrieve secrets using the CyberArk REST API there must be a http key containing the HTTP configuration. The http key contains these sub-keys, only url is required: YAML key Description url Type: String URL to request data from, this key is required Default: none tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers The following example will retrieve a secret using the CyberArk REST API, skipping server certificate verification: variables: credentials: cyberark-api: http: url: https://hostname/AIMWebService/api/Accounts?AppID=myAppID&Query=Safe=mySafe;Object=myObject tls_config: insecure_skip_verify: true Copy New Relic CLI Obfuscation Important We recommend using any of the supported secrets providers instead of the simple obfuscation when possible. See our guidelines below to define environment variables to avoid having the obfuscation key in configuration files. Tip Infrastructure Agent 1.14.0 or above is required You can use the New Relic CLI obfuscate command to obscure sensitive information in the infrastructure agent or any on-host integration configuration file. Steps: Install the New Relic CLI on any host (it can be your development host). Run the CLI obfuscate command in order to generate the obfuscated value: newrelic agent config obfuscate --value '<plain_text_config_value>' --key '<obfuscation_key>' Copy Copy the result of the cli command into the text argument in the obfuscated section as shown in the examples below. YAML key Description key Type: String The string used when obfuscating the clear-text value using New Relic CLI Default: none secret Type: String The output of the newrelic-cli command Default: none Integrations configuration example The following example will allow retrieving the Nginx user and password that has been obfuscated using the New Relic CLI: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy It's recommended to use environment variables for the obfuscation arguments as shown in the example below: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: {{OBFUSCATION_KEY}} secret: {{OBFUSCATION_TEXT}} instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy Agent configuration example This example allows retrieving a string that contains the proxy details (user, password and host): variables: obfuscated_proxy: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' proxy: ${obfuscated_proxy} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 363.51016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Obfuscation",
        "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and <em>New</em> <em>Relic</em> <em>CLI</em> obfuscation are supported. Define secrets"
      },
      "id": "603eaeeae7b9d28cdf2a07dd"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:53:28Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> One app",
        "body": "To build a <em>New</em> <em>Relic</em> One app, you must install the <em>New</em> <em>Relic</em> One <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> One <em>CLI</em> (command line interface). This page explains how to use <em>CLI</em> commands to: Generate"
      },
      "id": "6091fa9864441feb412f36d4"
    }
  ],
  "/terraform/terragrunt-configuration": [
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-08-03T01:43:12Z",
      "updated_at": "2021-06-25T01:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostConditions directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_policy\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your main.tf and provider.tf to the stage for commit: bash Copy $ git add main.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.83969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "6091fa98e7b9d2063e506919"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.30005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.5833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091b486196a675dc3d52a6f"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-08-03T01:43:04Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.64099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091fa9928ccbc8a70a268ac"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-08-02T22:59:55Z",
      "updated_at": "2021-07-22T04:34:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more child accounts, the notification channel includes only users for the currently selected parent or child account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.28873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table/",
      "sections": [
        "Table",
        "Usage",
        "Examples",
        "Props",
        "Type definitions",
        "Cursor",
        "SelectedCallbackArgument"
      ],
      "published_at": "2021-08-03T01:44:08Z",
      "title": "Table",
      "updated_at": "2021-06-25T01:44:11Z",
      "type": "developer",
      "external_id": "878b3ab08dbd0a7df42558a970648013adde957f",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table with a fixed header and rows. The table implements the following features: Flexible layout: table headers accept a variety of sizes to enable fluid and fixed layouts. You can find more information on how to customize your columns checking TableHeaderCell. Sorting: items passed can be internally sorted by the table according to the current sorting state of the table. You can find more information about sorting by checking TableHeaderCell. Row selection: rows can be selected through checkboxes on the right hand side. You can find more information in the selected prop. Row actions: contextual actions can be triggered per row, enabling users to achieve functionality over them. You can find more information on how to add them in TableRow. Custom pre-defined cells: some very common patterns for cells (entity title, metrics, etc.) are already provided by the platform, so that you only need to return it as part of your row. Virtualization: cells are only rendered if they are shown on screen. This enables the table to work with a large dataset with almost no performance penalty. Usage import { Table } from 'nr1' Copy Examples Props ariaLabelstring Provide an accessibility label that describes the purpose of the table, e.g. \"All entities\". children(node|function)[] Contents of the table. Table can only contain as children <TableHeader> and a function returning <TableRow>s. classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. compactboolean DEFAULT false Establishes whether the table should render in compact mode (compact mode has narrower rows). In general, use the standard mode, since compact is reserved for data representation, e.g. in a dashboard. itemsany[] DEFAULT [] The items to be used when rendering. They are required when rendering items with a render callback. Each item can have any structure and type possible, and will the corresponding one will be provided when rendering each element list. mainColumnnumber DEFAULT 0 Column containing the main data identifying the row. Often the first column (index 0) is the relevant one, but actions (like favorites) could be placed before it. onLoadMorefunction Callback fired when more items must be loaded. This happens when you're lazy loading the items and the items that are about to render cannot be found in the items array. This callback should be used to fetch/load the missing items from the backend or other sources. The returned Promise should be resolved once item data has finished loading. It will be used to determine when to refresh the list with the newly-loaded data. This callback may be called multiple times in reaction to a single scroll event. function ( cursor : Cursor // Items to load. ) onSelectfunction Function called when the user clicks over a row checkbox. It is called with the event of the checkbox, as well as with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. When the user selects or unselects the header checkbox (select / unselect all), the callback will be called once for every item, representing individual clicks over each row. The header checkbox state is automatically controlled by the table. function ( event : React.ChangeEvent, selectedItem : SelectedCallbackArgument ) rowCountnumber Number of rows. By default it's equal to length of array passed in the items prop. You should specify the rowCount when you know the total number of items but you want to lazy load them while scrolling. selectedfunction Function that returns whether a row is selected. It needs to return a boolean representing the state of the row. It is called with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. function ( item : SelectedCallbackArgument ) => boolean selectionTypeenum DEFAULT Table . SELECTION_TYPE . BULK Sets the selection mode of the Table. Use it along with onSelect and selected props to determine which row is checked by the user. Table.SELECTION_TYPE.BULK displays checkboxes per each row, along with a checkbox in the header to select all items. When an item is selected, header actions become available. Table.SELECTION_TYPE.SINGLE doesn't display checkboxes, the user picks a row by just clicking on it. Though not enforced in the component, the selected callback should return true only for one item. Check the examples of the component to see how it works. <One of Table.SELECTION_TYPE.BULK , Table.SELECTION_TYPE.SINGLE , > spacingTypeenum[] Spacing property. Spacing is defined as a tuple of zero to four values, which follow the same conventions as CSS properties like margin or padding. To omit a value, use SPACING_TYPE.OMIT. <Array of <One of Table.SPACING_TYPE.EXTRA_LARGE , Table.SPACING_TYPE.LARGE , Table.SPACING_TYPE.MEDIUM , Table.SPACING_TYPE.NONE , Table.SPACING_TYPE.OMIT , Table.SPACING_TYPE.SMALL , > > styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. Type definitions Cursor { startIndex : number, // First index of the range of items to load. stopIndex : number, // Last index of the range of items to load. } SelectedCallbackArgument { item : any, // Item to check. index : number, // Index of the item in the items array. items : any[], // Array of all items passed. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 751.1386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Table</em>",
        "sections": "<em>Table</em>",
        "body": " be internally sorted by the <em>table</em> according to the current sorting state of the <em>table</em>. You can find more information about sorting by checking <em>TableHeaderCell</em>. <em>Row</em> selection: rows can be selected through checkboxes on the right hand side. You can find more information in the selected prop. <em>Row</em>"
      },
      "id": "6091f91ee7b9d24aff506897"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-header-cell/",
      "sections": [
        "TableHeaderCell",
        "Usage",
        "Props"
      ],
      "published_at": "2021-08-03T01:44:07Z",
      "title": "TableHeaderCell",
      "updated_at": "2021-06-25T01:44:11Z",
      "type": "developer",
      "external_id": "2a4be1419d1a6e501a8eed915b8acf7c9798259d",
      "document_type": "page",
      "popularity": 1,
      "body": "Wraps the content of a table cell located in the header of the table, by keeping them at the top and adding additional controls as required, e.g. sorting mechanisms. Usage import { TableHeaderCell } from 'nr1' Copy Props alignmentTypeenum DEFAULT TableHeaderCell . ALIGNMENT_TYPE . LEFT Defines the text alignment inside the cell. <One of TableHeaderCell.ALIGNMENT_TYPE.CENTER , TableHeaderCell.ALIGNMENT_TYPE.LEFT , TableHeaderCell.ALIGNMENT_TYPE.RIGHT , > childrennode Contents of the table cell. If left empty, make sure you pass title so that users get a reference about the data the column shows. classNamestring Appends class names to the component. onClickfunction Callback fired any time the user clicks on the header. When clicked, sorting information (and the next sorting state) will be passed as the second parameter. Use it rather than computing it yourself. function ( event : React.MouseEvent, sortingData : Object ) sortableboolean DEFAULT false Whether the column is sortable. This means that the up and down arrows will be shown, side to the heading text. Sorting is a controlled component interface, you are in charge of listening for the sorting event and applying the sorting to the corresponding column, by changing its sortingOrder prop. sortingFunctionfunction Method for sorting rows. The default method will usually do the right thing (alphabetical ordering for text, numerical ordering for numbers and boolean grouping), but if needed this can be overridden. The function takes two parameters (a and b) and has to return a negative number if a is considered to appear before b, a positive one if it's considered to appear after, and zero if both values are identical. Each of the objects passed to the callback contains the value for the given row (i.e. the result of calling value over the row), the row item (as item), the index of the row (as index) and all the items in the items array (as items). Generally you will compare rows using a.item and b.item. function ( a : object, b : object ) => number sortingOrdernumber DEFAULT Number . MAX_SAFE_INTEGER Establishes the sorting order. A lowest number indicates a highest sorting priority, meaning that 0 will be the first column sorted, and if two items are identical, we will use column 1 and so on. Columns that do not have an explicit sorting order are used after all columns that do have it, and they are applied in order of appearance. sortingTypeenum DEFAULT TableHeaderCell . SORTING_TYPE . NONE Establishes the sorting for the column. Columns are sorted based on the element returned by the value prop. <One of TableHeaderCell.SORTING_TYPE.ASCENDING , TableHeaderCell.SORTING_TYPE.DESCENDING , TableHeaderCell.SORTING_TYPE.NONE , > styleobject Inline style for custom styling. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. titlestring Establishes the title of the cell. This is used for tooltip purposes, when the width of the column is small enough to not show the entire heading. Defaults to the stringified version of the provided children. valuefunction Function that is used to extract the raw value representing a column. The raw value may be a boolean (e.g. if you render a checkbox), a number (if you render a metric) or text for others. It is called with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. This function is used for sorting the table (by the given value) as well as for the heuristics of 'fit-content' widths. widthstring DEFAULT 1fr Represents the width of the column. It is always a string, and it can be of one of the following types: 'fit-content': the column will take the minimum required space to allocate all items in the column. For virtualized lists, a heuristic will be used to avoid rendering all cells. 'YYpx': where YY is a number, represents the width of the column in pixels. 'YY%': where YY is a number, represents the width of the column in percentage, relative to the size of the available space where the table is being rendered. 'YYfr': where YY is a number, it represents a fraction of the available width. Fractions are proportional ones to others; for instance, a table with two columns (1fr and 2fr) will have the second column twice as large as the first one. If, after computing the widths, the overall size of the table does not cover the available space, all columns will be proportionally stretched to fit all available space.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 607.25433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableHeaderCell</em>",
        "sections": "<em>TableHeaderCell</em>",
        "body": "Wraps the content of a <em>table</em> <em>cell</em> located in the <em>header</em> of the <em>table</em>, by keeping them at the top and adding additional controls as required, e.g. sorting mechanisms. Usage import { <em>TableHeaderCell</em> } from &#x27;nr1&#x27; Copy Props alignmentTypeenum DEFAULT <em>TableHeaderCell</em> . ALIGNMENT_TYPE . LEFT Defines"
      },
      "id": "6091f91d196a67fb19d52a35"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-row-cell/",
      "sections": [
        "TableRowCell",
        "Usage",
        "Examples",
        "Props",
        "shape"
      ],
      "published_at": "2021-08-03T01:44:08Z",
      "title": "TableRowCell",
      "updated_at": "2021-06-25T01:44:11Z",
      "type": "developer",
      "external_id": "2a8a8520a7c1bbcba96ca9a96de7918d74adb7f2",
      "document_type": "page",
      "popularity": 1,
      "body": "Wraps the content of a table cell located in the body of the table. This component is only expected to be used as a children of <TableRow>. Cells take care automatically of ellipsifying the content that does not fit and vertically centering it. This component is the base cell. For common cases, the SDK also provides a set of additional cells so that they always painted consistently across the UI (e.g. entity name with a status, or a user). Usage import { TableRowCell } from 'nr1' Copy Examples Props alignmentTypeenum DEFAULT TableRowCell . ALIGNMENT_TYPE . LEFT Defines the text alignment inside the cell. <One of TableRowCell.ALIGNMENT_TYPE.CENTER , TableRowCell.ALIGNMENT_TYPE.LEFT , TableRowCell.ALIGNMENT_TYPE.RIGHT , > childrennode DEFAULT null Contents of the table cell. classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. ellipsisTypeenum DEFAULT TableRowCell . ELLIPSIS_TYPE . RIGHT Defines how values are ellipsified within the cells; i.e. where the ellipsis is placed: RIGHT: at the end of the text, preserving its beginning. LEFT: at the beginning of the text, preserving its end. <One of TableRowCell.ELLIPSIS_TYPE.LEFT , TableRowCell.ELLIPSIS_TYPE.RIGHT , > onClickfunction Callback fired any time the user clicks on the table cell. function ( event : React.MouseEvent ) styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. toshape|string Location object or url string to link to. Linked TableRowCells are unstyled and will not show icons for external links. If the same styling as the Link component is what is desired, then use a Link instead as a child component within the cell. shape pathnamerequiredstring searchstring hashstring",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 478.44473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableRowCell</em>",
        "sections": "<em>TableRowCell</em>",
        "body": "Wraps the content of a <em>table</em> <em>cell</em> located in the body of the <em>table</em>. This <em>component</em> is only expected to be used as a children of &lt;<em>TableRow</em>&gt;. Cells take care automatically of ellipsifying the content that does not fit and vertically centering it. This <em>component</em> is the base <em>cell</em>. For common cases"
      },
      "id": "6091f91de7b9d2307a50690b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.81305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the NerdGraphQuery <em>component</em> to an <em>application</em>",
        "body": " configuration Customize your visualization with SDK components 25 min Customize your visualization Add a <em>table</em> to your <em>app</em> 30 min Add a <em>table</em> to your New Relic One <em>app</em> Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an <em>app</em> to show page view data on a map"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/metric-table-row-cell/",
      "sections": [
        "MetricTableRowCell",
        "Usage",
        "Examples",
        "Props",
        "shape"
      ],
      "published_at": "2021-08-03T01:54:28Z",
      "title": "MetricTableRowCell",
      "updated_at": "2021-06-25T01:54:31Z",
      "type": "developer",
      "external_id": "b3f3bb23254c69af9c2c0f5350018bae35f5506c",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular metric. The metric is formatted according to the unit passed. Units are 1:1 compatible with the ones supported by <NrqlQuery> format type CHART. Unit and prefix formatting is automatically picked for you so that it is consistent with the rest of the platform. Metrics are automatically aligned to the left, and ellipsified from the right, which is the standard way for presenting them. Usage import { MetricTableRowCell } from 'nr1' Copy Examples Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : React.MouseEvent ) styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. toshape|string Location object or url string to link to. Linked TableRowCells are unstyled and will not show icons for external links. If the same styling as the Link component is what is desired, then use a Link instead as a child component within the cell. shape pathnamerequiredstring searchstring hashstring typeenum DEFAULT MetricTableRowCell . TYPE . UNKNOWN Unit of the provided metric. Will be used for auto-formatting the numerical value. <One of MetricTableRowCell.TYPE.APDEX , MetricTableRowCell.TYPE.BITS , MetricTableRowCell.TYPE.BITS_PER_MS , MetricTableRowCell.TYPE.BITS_PER_SECOND , MetricTableRowCell.TYPE.BYTES , MetricTableRowCell.TYPE.BYTES_PER_MS , MetricTableRowCell.TYPE.BYTES_PER_SECOND , MetricTableRowCell.TYPE.COUNT , MetricTableRowCell.TYPE.HERTZ , MetricTableRowCell.TYPE.MS , MetricTableRowCell.TYPE.PAGES_PER_SECOND , MetricTableRowCell.TYPE.PERCENTAGE , MetricTableRowCell.TYPE.REQUESTS_PER_SECOND , MetricTableRowCell.TYPE.SECONDS , MetricTableRowCell.TYPE.TIMESTAMP , MetricTableRowCell.TYPE.UNKNOWN , > valuerequirednumber Metric value, always in the shape of a number.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.59454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " of the platform. Metrics are automatically aligned to the left, and ellipsified from the right, which is the standard way for presenting them. Usage import { Metric<em>TableRowCell</em> } from &#x27;nr1&#x27; Copy Examples Props classNamestring Appends class names to the <em>component</em>. Should be used only for positioning"
      },
      "id": "6091f8ce196a67bff9d52a48"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Automate workflows",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 5598.709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " <em>using</em> <em>Helm</em> <em>charts</em> 20 min Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> <em>Use</em> <em>New</em> <em>Relic</em> to diagnose problems 30 min Learn to diagnose problems <em>using</em> <em>New</em> <em>Relic</em>."
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-08-02T05:06:25Z",
      "updated_at": "2021-07-27T18:06:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.06482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and <em>update</em> CPM versions",
        "body": ". This is necessary for it to report data to <em>New</em> <em>Relic</em> and to receive monitors to execute. Ask your network administration if this is a problem and how to <em>set</em> <em>up</em> exceptions. Communicate with Synthetics via a proxy To <em>set</em> <em>up</em> communication with <em>New</em> <em>Relic</em> by proxy, <em>use</em> the environment variables named"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Verified script execution for private locations",
        "Passphrase security",
        "Important",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)"
      ],
      "title": "Verified script execution for private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "84a4f617447ed6f360feafc8432540025546dde8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations/",
      "published_at": "2021-08-02T05:08:47Z",
      "updated_at": "2021-08-02T05:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. Important This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution Do the following to enable verified script execution for containerized private minions. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, and then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSPHRASE environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.48344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " that verified script execution has been <em>set</em> <em>up</em> for that location. Passphrase security Be sure to safeguard your private minion&#x27;s passphrase. No other users on your account can view it, and it is never stored in <em>New</em> <em>Relic</em>&#x27;s collector. Important This restriction includes <em>New</em> <em>Relic</em> support personnel"
      },
      "id": "60452628e7b9d217695799ee"
    },
    {
      "sections": [
        "Kubernetes integration: compatibility and requirements",
        "Compatibility",
        "Requirements",
        "Install using Helm"
      ],
      "title": "Kubernetes integration: compatibility and requirements",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Get started"
      ],
      "external_id": "e9bbd729904fa01739eb91e4f3c74561b51c2ba1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements/",
      "published_at": "2021-08-02T10:25:43Z",
      "updated_at": "2021-08-02T10:25:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Kubernetes integration can be installed directly on a server or VM, or through several cloud platforms, such as GKE, EKS, AKS, or OpenShift. Each has a different compatibility with our integration. Compatibility Our Kubernetes integration is compatible with the following versions, depending on the installation mode: Install mode or feature Kubernetes versions Kubernetes cluster Currently tested with versions 1.10 to 1.21 Kubernetes cluster GKE Currently tested with versions 1.17 to 1.19 Kubernetes cluster EKS (EC2 nodes or Fargate) Compatible with version 1.11 or higher Kubernetes cluster AKS Compatible with version 1.11 or higher Kubernetes cluster OpenShift Currently tested with versions 3.7, 3.9, 4.2, 4.3, 4.4, 4.5 and 4.6 Kubernetes cluster VMware Tanzu Compatible with VMware Tanzu (Pivotal Platform) version 2.5 to 2.11, and Ops Manager version 2.5 to 2.10 Control plane monitoring Compatible with version 1.11 or higher Service monitoring Compatible with version 1.13 or higher Requirements The New Relic Kubernetes integration has the following requirements: A New Relic account. Don't have one? Sign up for free. No credit card required. Linux distribution compatible with New Relic infrastructure agent. kube-state-metrics version 1.9.8 running on the cluster. When using CRI-O as the container runtime, the processes inside containers are not reported. Performance data is collected at the container level. Install using Helm For compatibility and requirements when installing the Kubernetes integration using Helm, see Alternative install using Helm.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.7911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install <em>using</em> <em>Helm</em>",
        "body": " with <em>New</em> <em>Relic</em> infrastructure agent. kube-state-metrics version 1.9.8 running on the cluster. When <em>using</em> CRI-O as the container runtime, the processes inside containers are not reported. Performance data is collected at the container level. Install <em>using</em> <em>Helm</em> For compatibility and requirements when installing the Kubernetes integration <em>using</em> <em>Helm</em>, see Alternative install <em>using</em> <em>Helm</em>."
      },
      "id": "603e92dc64441f3a974e8891"
    },
    {
      "sections": [
        "Istio adapter",
        "Enable Istio adapter",
        "Find your data"
      ],
      "title": "Istio adapter",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "Istio"
      ],
      "external_id": "05c14aeaf5d07e0edcb4bd4bc4efcb2745627f00",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/istio/istio-adapter/",
      "published_at": "2021-08-02T10:43:17Z",
      "updated_at": "2021-08-02T10:43:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Istio provides a flexible model to enforce authorization policies and collect telemetry for the services in a mesh. New Relic's Istio adapter exports telemetry data from your Istio instance to your New Relic account. Resources for our Istio adapter: Enable Istio adapter To enable our Istio adapter: If you don't have one already, create a New Relic account. It's free, forever. Follow the Istio adapter install instructions. Optional: Instead of using the native Istio trace sampling, you can enable our Infinite Tracing feature. If you use this option, you will typically want to configure Istio to send us all trace data (learn more about sampling). To enable Infinite Tracing: In the New Relic UI, set up a trace observer. Configure our Istio adapter to send data to the trace observer: Set the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the Helm chart. Find your data To find your data, go to one.newrelic.com and go to Your applications > Explorer. From the Entities screen, search for your service by name. From there, you can explore your metrics using the Data explorer and build dashboards using your metrics. If you're sending distributed tracing data, the distributed tracing feature is available to query and view traces. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.87079,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to send us all trace data (learn more about sampling). To enable Infinite Tracing: In the <em>New</em> <em>Relic</em> UI, <em>set</em> <em>up</em> a trace observer. Configure our Istio adapter to send data to the trace observer: <em>Set</em> the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the <em>Helm</em> <em>chart</em>. Find your data To find"
      },
      "id": "603e81b464441fd2a54e8875"
    }
  ],
  "/terraform/get-started-terraform": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.6137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091b486196a675dc3d52a6f"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-08-03T01:43:12Z",
      "updated_at": "2021-06-25T01:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostConditions directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_policy\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your main.tf and provider.tf to the stage for commit: bash Copy $ git add main.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.83969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "6091fa98e7b9d2063e506919"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-08-03T01:44:08Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.4988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "6091fa9964441fe25f2f36f4"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.30005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-08-02T22:59:55Z",
      "updated_at": "2021-07-22T04:34:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more child accounts, the notification channel includes only users for the currently selected parent or child account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.28873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.5148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Automate tags with our <em>CLI</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and labels that are defined in the cloud service. To add tags, you&#x27;d add them on the cloud-service-side. Automate tags with our <em>CLI</em> For a guide to automating tags using our <em>CLI</em> tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 330.06122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.12265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.90414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-08-02T02:09:17Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.3104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.77658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and <em>add</em> it to a dropdown menu in an application <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. <em>Add</em> a time picker to your app"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-08-03T00:38:53Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.56942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> new content to your dashboard",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " can use the search feature at any time to search <em>data</em> across New Relic One. <em>Add</em> new content to your dashboard There are multiple ways to <em>add</em> new content to your dashboard: From the <em>data</em> explorer and <em>query</em> builder features. Use the + <em>Add</em> to your dashboard button (accessible from the main dashboard"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-08-03T00:37:51Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.4324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> scrubber",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " or an existing dashboard. From the <em>data</em> explorer or the <em>query</em> builder: <em>Add</em> any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see <em>Add</em> pages"
      },
      "id": "603ec16028ccbc8d07eba78d"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/entity-storage-mutation/",
      "sections": [
        "EntityStorageMutation",
        "Usage",
        "Examples",
        "Props",
        "Methods",
        "EntityStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "MutationResult"
      ],
      "published_at": "2021-08-02T01:58:54Z",
      "title": "EntityStorageMutation",
      "updated_at": "2021-06-25T02:00:34Z",
      "type": "developer",
      "external_id": "da00b0c5ac105e1bdff9a733569cfa006d7dd65c",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an entity scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { EntityStorageMutation } from 'nr1' Copy Examples Props actionTyperequiredenum Type of action to perform. <One of EntityStorageMutation.ACTION_TYPE.DELETE_COLLECTION , EntityStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , EntityStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : MutationResult // Results of the mutation. ) => React.ReactNode collectionrequiredstring Collection name. documentobject NerdStorage document. Documents are restricted to 64 kB in size when JSON-stringified. documentIdstring Document identifier to operate in. When omitted the whole collection is returned. entityGuidrequiredstring GUID of the entity in which the collection is operated. scopeByActorboolean DEFAULT false Establishes whether the data needs to be scoped by actor or not; that is, whether the data read or saved is common to everybody having access to the object, or it is exclusive of the user. An object (entity or account) can have both \"global\" data and \"scoped\" data, and the data read will depend on the status of the flag. Methods EntityStorageMutation.mutate Static method to use EntityStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any EntityStorageMutation prop is a valid option except children. ) Type definitions PromiseQueryResult { error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your query. fetchMore : function|null, // If not null, fetchMore allows you to load more results for your query. New data is merged with previous data. refetch : function, // Refetch the query. } MutationResult { loading : boolean, // Indicates that the request is in flight. error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your mutation. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.901726,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>MutationResult</em>",
        "body": " of the user. An object (entity or account) can have both &quot;global&quot; <em>data</em> and &quot;scoped&quot; <em>data</em>, and the <em>data</em> read will depend on the status of the flag. Methods EntityStorageMutation.<em>mutate</em> Static method to use EntityStorageMutation as a Promise instead of as a React component. function ( props : Object"
      },
      "id": "6091f87428ccbc09fea268e2"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/account-storage-mutation/",
      "sections": [
        "AccountStorageMutation",
        "Usage",
        "Examples",
        "Props",
        "Methods",
        "AccountStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "MutationResult"
      ],
      "published_at": "2021-08-02T02:07:46Z",
      "title": "AccountStorageMutation",
      "updated_at": "2021-06-25T01:49:48Z",
      "type": "developer",
      "external_id": "ebcf287cdc8712a7a0f6c95b60e49a5e5d3fac66",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an account scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { AccountStorageMutation } from 'nr1' Copy Examples Props accountIdrequirednumber Account identifier. actionTyperequiredenum Type of action to perform. <One of AccountStorageMutation.ACTION_TYPE.DELETE_COLLECTION , AccountStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : MutationResult // Results of the mutation. ) => React.ReactNode collectionrequiredstring Collection name. documentobject NerdStorage document. Documents are restricted to 64 kB in size when JSON-stringified. documentIdstring Document identifier to operate in. When omitted the whole collection is returned. Methods AccountStorageMutation.mutate Static method to use AccountStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any AccountStorageMutation prop is a valid option except children. ) Type definitions PromiseQueryResult { error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your query. fetchMore : function|null, // If not null, fetchMore allows you to load more results for your query. New data is merged with previous data. refetch : function, // Refetch the query. } MutationResult { loading : boolean, // Indicates that the request is in flight. error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your mutation. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.898895,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>MutationResult</em>",
        "body": " option except children. ) Type definitions Promise<em>Query</em>Result { error : ApolloClient.ApolloError, &#x2F;&#x2F; Runtime error with graphQLErrors and networkError properties. <em>data</em> : Object, &#x2F;&#x2F; Object containing the result of your <em>query</em>. fetchMore : function|null, &#x2F;&#x2F; If not null, fetchMore allows you to load more"
      },
      "id": "6091fb4464441f55502f36c6"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.35693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " configuration Customize your visualization with SDK <em>components</em> 25 min Customize your visualization Add a table to your <em>app</em> 30 min Add a table to your <em>New</em> <em>Relic</em> <em>One</em> <em>app</em> Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site Create a custom map view 30 min Build an <em>app</em> to show page view <em>data</em> on a map"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.03815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and <em>components</em> in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch <em>New</em> <em>Relic</em> or third-party <em>data</em>"
      },
      "id": "6091fa39196a67a4ead52a4b"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 210.60883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help organize and find your <em>data</em>",
        "sections": "Use tags to help organize and find your <em>data</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the software industry, a tag typically refers to a piece of metadata added to a <em>data</em> set for the purpose of improving <em>data</em> organization and findability. At <em>New</em> <em>Relic</em>, our tags are key:value pairs (like team: operations) added to various sets of <em>data</em>, like monitored <em>apps</em> and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.75919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. <em>New</em> <em>Relic</em> <em>One</em>: a programmable platform We strive to have an automated user"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2021-08-03T01:47:21Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.5215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorageVault</em>",
        "sections": "Using <em>NerdStorageVault</em> in your <em>apps</em>",
        "info": "Intro to <em>NerdStorageVault</em> on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorageVault to store <em>data</em> in an encrypted storage solution. Using NerdStorageVault in your <em>apps</em> NerdStorageVault is used to store and retrieve sensitive secrets <em>data</em>"
      },
      "id": "6091fa9828ccbc86bda268a9"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.70532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Automate tags with our <em>CLI</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and labels that are defined in the cloud service. To add tags, you&#x27;d add them on the cloud-service-side. Automate tags with our <em>CLI</em> For a guide to automating tags using our <em>CLI</em> tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.36444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.44104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.979,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-08-02T02:09:17Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 314.09473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-08-03T01:47:21Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 421.80957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>, run nr1 help <em>COMMAND</em>_NAME. Usage"
      },
      "id": "6091fa98196a67ded9d52a39"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.5148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Automate tags with our <em>CLI</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and labels that are defined in the cloud service. To add tags, you&#x27;d add them on the cloud-service-side. Automate tags with our <em>CLI</em> For a guide to automating tags using our <em>CLI</em> tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 330.06122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.12265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.90414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 945.52264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Customize your visualization with <em>SDK</em> <em>components</em>",
        "body": " configuration Customize your visualization with <em>SDK</em> <em>components</em> 25 min Customize your visualization Add a table to your <em>app</em> 30 min Add a table to your <em>New</em> <em>Relic</em> <em>One</em> <em>app</em> Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site Create a custom map view 30 min Build an <em>app</em> to show page view data on a map"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 597.1049,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help organize <em>and</em> find your data",
        "sections": "Custom <em>queries</em>, <em>charts</em>, <em>and</em> alerts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored <em>apps</em> and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 567.8355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you’ll learn how to use Nerd<em>Storage</em> <em>SDK</em> <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of data, including users&#x27; configuration settings"
      },
      "id": "6091fa39e7b9d2e1425068b8"
    },
    {
      "sections": [
        "PHP agent installation overview",
        "PHP components",
        "Install the agent",
        "Tip",
        "RedHat or CentOS",
        "Ubuntu or Debian",
        "Tar archive",
        "Install PHP with partnership accounts",
        "For more help"
      ],
      "title": "PHP agent installation overview",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Installation"
      ],
      "external_id": "e2acdb74f9365baa40b0b07a0bb638d19dbe6f5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/installation/php-agent-installation-overview/",
      "published_at": "2021-08-02T02:21:37Z",
      "updated_at": "2021-08-02T02:21:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our PHP agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic PHP agent installation. Add PHP data PHP components Our PHP agent consists of two basic components: A PHP extension, which collects data from your application A local proxy daemon, which transmits the data to New Relic Your system's configuration components, including the web server, operating system, system permissions, PHP installation itself, package manager, etc., are all important factors during installation and configuration, because the agent is a part of that. For more information about supported PHP releases, frameworks, and other system requirements, see PHP compatibility and requirements. Install the agent Follow this general process to install the agent on your system. The agent installation package or tar archive includes the interactive newrelic-install script, which automates some installation tasks. Tip If your application is frequently inactive, we recommend you generate some data by interacting with the application or site. This will help ensure the agent initially connects. If you haven't already, create a New Relic account. It's free, forever. Ensure your system meets the agent's requirements, including appropriate system permissions. From your Account settings, copy your license key information. Install the agent package or tar archive on your system. RedHat or CentOS The most common way to install the agent on RedHat or CentOS is with the installation package (.rpm) and the package manager. You can tell the package manager to get it from the New Relic repository, or you can download the .rpm file directly from the New Relic website. Install the package with your preferred package manager (yum or rpm) and then run the newrelic-install script. Ubuntu or Debian Install the package either with apt-get or with dpkg commands. Typically, running the newrelic-install script is not required. Tar archive The .tar archive method is the most generic method you can use on all supported operating systems. Download the compressed tar archive for your system if any of these situations apply to you: Your operating system is not listed here. You are not using a package manager. Other methods are unsuccessful. Install the tar archive of the agent on any supported platform. Change the default application name to a meaningful name. Optional: Change other agent configuration settings to further customize your installation. Restart your web server (Apache, Nginx, PHP-FPM, etc.). Recommendation: To help ensure the PHP agent is initiated, especially if your application has infrequent activity, generate some data by using the app for a few seconds. Wait a few minutes for your application to send data to New Relic. Then, check your app's performance in the New Relic UI. Install PHP with partnership accounts Installation procedures may be different for admins who install the PHP agent through a New Relic partnership. For more information, see: AWS Heroku Magento Shared hosting providers Other partnership installation procedures Not all partners support PHP agents. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 554.1025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "PHP <em>components</em>",
        "body": " activity, generate some data by using the <em>app</em> for a few seconds. Wait a few minutes for your application to send data to <em>New</em> <em>Relic</em>. Then, check your <em>app</em>&#x27;s performance in the <em>New</em> <em>Relic</em> <em>UI</em>. Install PHP with partnership accounts Installation procedures may be different for admins who install the PHP"
      },
      "id": "6043c95064441f9382378ebf"
    },
    {
      "sections": [
        "Query and store data",
        "Tip",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2021-08-03T01:47:21Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 553.9089,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> <em>and</em> store data",
        "sections": "<em>Query</em> <em>components</em>",
        "info": "Reference guide for <em>SDK</em> <em>query</em> <em>components</em> using NerdGraph",
        "tags": "nerdgraph <em>query</em> <em>components</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. Here you can learn how to use the <em>SDK</em> <em>query</em> <em>components</em>, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip <em>Query</em>-related React <em>components</em> can be identified by the <em>Query</em>"
      },
      "id": "6091fa9828ccbc8c63a268a5"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.5148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Automate tags with our <em>CLI</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and labels that are defined in the cloud service. To add tags, you&#x27;d add them on the cloud-service-side. Automate tags with our <em>CLI</em> For a guide to automating tags using our <em>CLI</em> tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 330.06122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.12265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.90414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-08-02T02:09:17Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.3104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/build-apps/build-visualization": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-21T15:59:34Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.64716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Tip",
        "Entity relationships",
        "Important",
        "Group and organize entities"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-22T01:24:04Z",
      "updated_at": "2021-04-22T01:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities You'll find your entities wherever you see your data reporting in New Relic. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. These are granted to user roles by default. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.897995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How entities are related to <em>one</em> another How to organize them into groups for easier analysis What is an entity"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-21T15:49:43Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.62895,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-21T15:50:36Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.90482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "To view workloads, go to <em>one</em>.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-04-25T01:55:12Z",
      "updated_at": "2021-04-09T01:54:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads and the rest of our observability platform, join the New Relic family! Sign up to create your account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.90851,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": ": <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you&#x27;ve included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you"
      },
      "id": "6043cb93196a67f988960f76"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.70532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Automate tags with our <em>CLI</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and labels that are defined in the cloud service. To add tags, you&#x27;d add them on the cloud-service-side. Automate tags with our <em>CLI</em> For a guide to automating tags using our <em>CLI</em> tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.36444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.44104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.979,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-08-02T02:09:17Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 314.09473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.70532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Automate tags with our <em>CLI</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " solution. Tip Tags were previously called labels in the <em>New</em> <em>Relic</em> UI. You may sometimes see labelin our code; for example, some of our APM agent <em>config</em> files use a label <em>config</em> option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.36444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.44104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.979,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-08-02T02:09:17Z",
      "updated_at": "2021-07-27T01:48:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic One’s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything you’re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 314.09473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your entire system. To access <em>New</em> <em>Relic</em> <em>One</em>: Go to <em>one</em>"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "sections": [
        "Add custom visualizations to your dashboards",
        "Add a visualization to a dashboard",
        "Manage your dashboard visualizations"
      ],
      "title": "Add custom visualizations to your dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d6c9973ef2c2547a99539d1da027b54db23af42c",
      "image": "https://docs.newrelic.com/static/5f7bd9c6a2a163d1f19c5c8b0d844d2f/c1b63/dashboard_viz.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards/",
      "published_at": "2021-08-03T00:36:51Z",
      "updated_at": "2021-05-22T05:24:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can build your own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to custom queries from any data source. This visualization shows the number of people in each city who are viewing New Relic within an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user permissions, which include the Nerdpack manager role, you can add a visualization to a dashboard as described in the following section. The process for creating a visualization is covered in the guide, Build a custom visualization for dashboards. Add a visualization to a dashboard You can add a visualization to a new or existing dashboard. From New Relic, in the top right, click the Apps button, and then on the Apps page, click Custom Visualizations. Hint: if you don't see the Custom Visualizations tile, use the search to locate it. In Custom Visualizations, select the visualization you want to add to a dashboard and then enable it. If there are configuration options, fill those in. The visualization will update with your changes. Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard. If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name. Click Add to dashboard, then click the link to your dashboard to see the custom visualization. Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click Delete. Editing: To edit a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click Edit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.311485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Manage</em> your dashboard visualizations",
        "body": " an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user <em>permissions</em>, which include the <em>Nerdpack</em> <em>manager</em> role, you can add a visualization to a dashboard as described in the following section. The process for creating"
      },
      "id": "603ec4e628ccbc9409eba7ab"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.85718,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Nerdpack</em> <em>permissions</em>",
        "body": " configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your <em>app</em> 30 min Add a table to your New Relic One <em>app</em> <em>Nerdpack</em> <em>permissions</em> 10 minutes Learn about <em>permissions</em> for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site Create a custom map view 30 min Build an <em>app</em> to show page view data on a map"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Install PHP agent on shared hosting service",
        "Shared hosting services",
        "Installation and troubleshooting tips",
        "Important",
        "For more help"
      ],
      "title": "Install PHP agent on shared hosting service",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Installation"
      ],
      "external_id": "78f7c68a4b5931e61e9550668be5030dbe0d5620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/installation/install-php-agent-shared-hosting-service/",
      "published_at": "2021-08-02T02:20:37Z",
      "updated_at": "2021-08-02T02:20:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, basic hosting plans do not allow standard installation of New Relic's PHP agent, because administrator (root) permissions are required to install it. Your hosting provider may allow or provide installation for common web apps/frameworks (such as WordPress, Drupal, Joomla, etc), but installing the PHP agent still requires permissions not allowed in many basic plans. If necessary, contact your website developer/hosting provider for technical assistance. Shared hosting services In general, shared hosting providers (who do not provide root command line access) and hosting providers that do not have traditional operating systems (such as PaaS) do not allow users to install New Relic agents through typical channels. For example, these hosting providers do not support New Relic integrations for certain subscription levels: DreamHost: Shared Web Hosting WordPress.com hosted blog GoDaddy: Economy, Deluxe, Ultimate, WordPress Blog Hosting HostGator Web Hosting Before you install New Relic's PHP agent, make sure your hosting service level is compatible with New Relic. Also make sure you have administrator permissions for installation procedures from the command line at the root level. Installation and troubleshooting tips To help ensure that your application can integrate successfully with New Relic: Make sure your system meets New Relic's PHP compatibility requirements. Important Windows operating systems are not supported. Follow New Relic's PHP installation procedures. If your system meets New Relic's compatibility requirements but your installation is unsuccessful, gather the following information: Exact steps you tried Results, including success or failure messages Your operating system and version (for example, Ubuntu Linux version 12.04 64-bit) Your hosting service provider and subscription level If applicable, contact your website developer for assistance. For more help Additional documentation resources include: Suggest a change and learn how to contribute to our PHP agent open source repository. Finding help (resources available through the online Help Center) The New Relic user interface (overview of how to use the UI)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.74144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "In general, basic hosting plans do not allow standard installation of New Relic&#x27;s PHP agent, because administrator (root) <em>permissions</em> are required to install it. Your hosting provider may allow or provide installation for common web <em>apps</em>&#x2F;frameworks (such as WordPress, Drupal, Joomla, etc"
      },
      "id": "6043b66d64441fab16378ed9"
    },
    {
      "sections": [
        "Connect Google Cloud Platform services to New Relic",
        "Requirements",
        "Authorization options",
        "Service account (recommended)",
        "User account",
        "Connect GCP to New Relic infrastructure monitoring",
        "Tip",
        "Explore app data in New Relic",
        "Link multiple Google projects",
        "Unlink your GCP integrations"
      ],
      "title": "Connect Google Cloud Platform services to New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Google Cloud Platform integrations",
        "Get started"
      ],
      "external_id": "05934d2b03ec1ac5fa43298b21a06dc2e0f8c3b9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/google-cloud-platform-integrations/get-started/connect-google-cloud-platform-services-new-relic/",
      "published_at": "2021-08-02T12:39:29Z",
      "updated_at": "2021-08-02T12:39:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To start receiving Google Cloud Platform (GCP) data with New Relic GCP integrations, connect your Google project to New Relic infrastructure monitoring. If you don't have one already, create a New Relic account. It's free, forever. Requirements These are the requirements for the authorization: GCP integration requirements Comments Monitoring In the GCP project API & Services Library settings, you must enable Google Stackdriver Monitoring API. Authorization For service account authorization (recommended): A user with Project IAM Admin role is needed to add the service account ID as a member in your GCP project. In the GCP project IAM & admin, the service account must have the Project Viewer role and the Service Usage Consumer role or, alternatively, a custom role. For user account authorization: The New Relic user that will integrate the GCP project must have a Google account and must be able to view the GCP project that New Relic will monitor. In the GCP project IAM & admin, the user must have the Project Viewer role. Please note that this authorization method will not allow New Relic to collect labels and other inventory attributes that can be useful for narrowing down your NRQL queries, dashboards and alerts. You can migrate the authorization method from user account to service account from the Manage services link in New Relic's user interface. Project name As part of the online setup process, you must identify Project name of the projects you want to monitor with New Relic. The UI workflow automatically lists active projects you can select. Permissions (only for user account authorization) New Relic requires a specific set of read-only permissions exclusively; this means that, for certain integrations, only partial inventory data will be available. Keep in mind that New Relic doesn't inherit your Google account's permissions and therefore is not authorized to perform any changes in the project. For more information about the API permissions that New Relic uses, see the Google documentation about scopes. Authorization options Integrating your GCP project with New Relic requires you to authorize New Relic to fetch monitoring data from your GCP project. You can choose between two authorization methods: Service accounts or User accounts. Service account (recommended) The service account authorization is recommended. If you authorize New Relic to fetch data through a service account, we will call your GCP project APIs using a service account ID and its associated public/private key pair. New Relic manages a specific Google service account for your New Relic account; you do not need to create it or manage the associated private key. Just add the service account ID as a member with viewing permissions in your project. This authorization method is recommended, especially if your GCP project is managed by a team. It also guarantees that New Relic will collect labels and inventory attributes whenever possible. User account If you authorize New Relic to fetch data through a user account, New Relic will access your GCP project monitoring data on behalf of a particular Google user. The authorization process is achieved through an OAuth workflow, which redirects you from the New Relic UI to a Google authorization interface. However, since the authorization is linked to a particular Google user, this method is not recommended for GCP projects that are managed by large teams. Connect GCP to New Relic infrastructure monitoring To connect your Google account to New Relic with user account authorization: Go to one.newrelic.com > Infrastructure > GCP. At the top of Infrastructure's Google Cloud Services integrations page, select Add a GCP account. Choose Authorization Method: Select either Authorize a Service Account or Authorize a User Account, and follow the instructions in the UI to authorize New Relic. Add projects: Select the projects that you want New Relic to receive data from. Select services: From the list of available services for your GCP account, select the individual services you want New Relic to receive data from, or select all of the services. Tip These services will be enabled for all of the projects that you selected in the previous step. Once the setup process is finished, you can fine-tune the services that you want monitored for each project individually. To complete the setup process, select Finish. If you see API authentication errors, follow the troubleshooting procedures. Explore app data in New Relic After you authorize New Relic to integrate one or more of your Google project's services, New Relic starts monitoring your GCP data at regular polling intervals. After a few minutes, data will appear in the New Relic UI. To find and use your data, including links to dashboards and alert settings, go to one.newrelic.com > Infrastructure > GCP. Link multiple Google projects For your convenience, the setup process allows you to select more than one project at a time. After the first setup, if you need to monitor additional GCP projects with New Relic, you can repeat the procedure to connect your GCP services as many times as you need. Unlink your GCP integrations You can disable any of your GCP integrations any time and still keep your Google project connected to New Relic. If you want to... Do this Disable a GCP service monitoring To disconnect individual GCP services but keep the integration with New Relic for other GCP services in your Google account: Go to one.newrelic.com > Infrastructure > GCP and select Manage services. From your GCP account page, make changes to the checkbox options for available services and select Save changes. Unlink your project monitoring To uninstall all of your GCP services completely from New Relic Integrations, unlink your Google account: Go to one.newrelic.com > Infrastructure > GCP and select Manage services. From your GCP account page, select Unlink account and select Save changes. Clean your GCP Projects after unlinking New Relic To clean your GCP project after unlinking, follow these steps if you were using a service account: Open the GCP IAM Console. Select the project you want to unlink from New Relic and click Open. Select the service account that is used by New Relic. Click the Remove icon. Or follow these steps if you were using a user account: Open your Google user account settings. Open the Apps with access to your account section. Choose New Relic application. Choose Remove Access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.400116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Explore <em>app</em> data in New Relic",
        "body": " Relic. The UI workflow automatically lists active projects you can select. <em>Permissions</em> (only for user account authorization) New Relic requires a specific set of read-only <em>permissions</em> exclusively; this means that, for certain integrations, only partial inventory data will be available. Keep in mind"
      },
      "id": "603e8309196a67fc4fa83da7"
    },
    {
      "image": "https://docs.newrelic.com/static/49612c40721bfa27afa90fafcba0e95c/c1b63/login-multiple-accounts-found.png",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model/",
      "sections": [
        "Users, roles, permissions (original user model)",
        "Requirements",
        "Updates about our new account/user model",
        "View and manage users in UI",
        "Tip",
        "Add a new user",
        "Important",
        "Manage user type (basic vs full) and full user upgrades",
        "Determine full user count",
        "Enable SAML SSO and/or SCIM",
        "View pending SAML SSO users",
        "Update account roles",
        "Delete a user",
        "Update the account Owner",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "View roles",
        "Assign a managed role",
        "Create a custom role",
        "Assign a custom role",
        "Edit or delete a custom role",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads permissions"
      ],
      "published_at": "2021-08-02T07:59:31Z",
      "title": "Users, roles, permissions (original user model)",
      "updated_at": "2021-07-15T15:41:08Z",
      "type": "docs",
      "external_id": "95ae42f3474b43dec394245cfc3e23628449a1ed",
      "document_type": "page",
      "popularity": 1,
      "body": "For users on our original user model, an introduction to how the user model works, including user roles and permissions, and how to add and manage users. Requirements This doc and the surrounding section of docs shows you how to manage users on our original account/user model. If you were a New Relic customer before July 30 2020 and haven't migrated your users to the new model, your users are on our original account/user model (and not the New Relic One model). If you're an admin and want to see if you have users on the original model: If you can see users in the Users and roles UI, those users are on our original user model. Updates about our new account/user model In July of 2020, we released a new account/user model called the New Relic One user model, which offers many benefits in terms of how you manage your organization and users. At first this was only available to new sign-ups but over time we've been migrating more older customers to the new model. Some older customers are able to migrate their users on their own. We'll continue working on migrating users to the new model until the original model is fully deprecated. One impact of the new user model is that it's possible now for users to have multiple logins associated with the same email. For example, a user with access to multiple organizations (like a contractor) may have their user record updated to the new user model in one organization, resulting in them having their original login method and records and a New Relic One user model record. This may result in the user being logged in to New Relic and not being able to find an account they're looking for. For more on that, see Factors affecting access. If a user's email is associated with more than one login, they'll see a \"multiple accounts found\" note when logging in. View and manage users in UI If your New Relic account has users on our original user model, you can use the Users and roles UI. To access this: Click the account dropdown, click Account settings, and then click Users and roles. Some features in the UI are visible only to account Owners and Admins. Tip You can also use the New Relic REST API to obtain a list of everyone and their roles in your New Relic account. Here are some instructions and tips for adding and managing users via the UI: Add a new user Tip Owner or Admins To add a new user to your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. In the upper right corner, click New user. Enter the appropriate name and email address. Select their base role as either Admin, User, or Restricted. Select Add user. The new user will receive an email notification automatically from New Relic. Important New Relic recommends a maximum of 1,000 accounts per user. Additional accounts may result in limited access to some New Relic features. Manage user type (basic vs full) and full user upgrades Note that billing-related aspects of your count of full users only apply if you're on New Relic One pricing. If you're on our original pricing plan, billing impacts do not apply. To update a user's type (basic user versus full user): Go to: account dropdown > Account settings > Users and roles > Users. Either select a user and edit their type or bulk update the type for multiple useres. To control how basic users upgrade to become full users, from the Users and roles UI you can select Access requests. You have two options: Automatic approval: With this option, basic users can automatically upgrade to be full users. This option allows your users to more easily troubleshoot problems. Require review: With this option, your admins get a notification when basic users request an upgrade and must upgrade them first. You can approve them either from the notification email or from the user's entry in the Users and roles UI. For more about user type, see User type. Determine full user count If you're on New Relic One pricing plan, your count of full users is a factor in your billing. To see your count of full users, click the account dropdown and then click View your usage. If you have a parent/child account structure (including a customer partnership), your count of full users may not match what you see when you go to Account settings > Users and roles. To examine users on a parent account's children accounts, go to a parent account's Account settings UI page, click on a child account, and go to that account's Users and roles UI page. Enable SAML SSO and/or SCIM For an introduction to using SAML SSO and/or SCIM provisioning, see Get started with SAML SSO or SCIM. View pending SAML SSO users New Relic accounts with SAML Single Sign On (SSO) may have a list of Pending users. These are individuals who have been added to the SAML-enabled account but have not yet confirmed. Update account roles Tip Owner or Admins To update a person's role and capabilities: Go to: account dropdown > Account settings > Users and roles > Users. Select the person's name. Under Roles and capabilities, select their base role as Admin, User, or Restricted. The account Owner must update the Owner role. Delete a user Tip Owner or Admins To remove a user from your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. Click on the name of the person you would like to update. Click Delete User. Tip You can also add, update, or delete users in bulk via CSV file. Update the account Owner A New Relic account can have only one Owner role at any time. You must be the current account Owner to change your role to someone who currently has an Admin role for the account. If the current Owner is unavailable, contact your account representative at New Relic, or get support at support.newrelic.com. You cannot delete or remove your assigned Owner role. However, if the account has one or more Admin role, you can change an Owner to an Admin. Go to: account dropdown > Account settings > Account > Users and roles. Above the Active users list, select Change owner. If an account has no Admins, this button won't be available. Select someone who currently has an Admin role for the account. Refresh the page for changes to take effect. Your previous Owner role automatically changes to an Admin role. To find out who is the current assigned Owner: Go to: account dropdown > Account settings > Account > Users and roles. View the Base role column to locate your account Owner. The Change owner button is only visible to the current account Owner. If the current Owner is unable to change the role (for example, that person no longer is with your organization), contact your account representative at New Relic, or get support at support.newrelic.com. User types: basic user and full user Important This section is for users on our original user model. If you're on our New Relic One user model, see our New Relic One user docs. Starting March 2021, we ended the preview period for basic users on our original user model. The preview period gave these basic users the same permissions as full users. For more on this, see our Explorers Hub post on user type changes. The user type (basic user or full user) determines what features a user has access to. Below are details on the two user types. Note that billing-related aspects only apply if you're on New Relic One pricing. If you're on our original pricing plan, billing impacts do not apply. Basic user. Details: These users have access to basic features like setting up reporting of data, running queries of data, making custom charts and dashboards, and setting up alerts. They do not have access to Full-Stack Observability features (for more details on feature access, see Capabilities). Depending on access request settings, basic users can either upgrade themselves to be full users or request upgrade access from admins. No matter what custom group a basic user is assigned to, they always have the capabilities of a basic user: no more and no less. Full user. Details: Full users have access to our Full-Stack Observability features, which include our curated UI experiences like APM, infrastructure monitoring, browser monitoring, mobile monitoring, and synthetic monitors. For details on what's available, see Capabilities. For organizations on New Relic One pricing: these users are billable. The Standard edition includes one free full user and up to five total. If a user in your organization is set as a basic user in one account and a full user in another, the user has full user access for all accounts. For how to edit a user's type, see Manage users. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. Admin Can add, edit, and delete users, and can enable or set up features. User Can use (and optionally set up) New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted User One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a parent account automatically have the same level of access for all the child accounts of the parent account. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Tip Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. Tip You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Tip Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Tip Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select Edit role or Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a parent account automatically have the same level of access for all the child accounts of that parent account. However, they won't receive email notifications for alerts or weekly reports for child accounts unless they are explicitly granted permission on those accounts. Function Owner Admin User Restricted Maintain billing information. Change the account Owner. Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. Update users' job titles and roles from Account settings in the New Relic UI. Create, modify and delete child accounts from Account settings in the New Relic UI. Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. Manage flexible data retention. Subscribe and unsubscribe applications to New Relic One Add, update, and delete Proactive Detection configurations. Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. Tip New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions To give permission to delete a mobile app from New Relic, you can assign an Admin or Mobile manager role. Synthetics permissions Here's a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads permissions Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.826904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Users, roles, <em>permissions</em> (original user model)",
        "sections": "Users, roles, <em>permissions</em> (original user model)",
        "body": " dashboards with others. Mobile <em>permissions</em> To give permission to delete a mobile <em>app</em> from New Relic, you can assign an Admin or Mobile <em>manager</em> role. Synthetics <em>permissions</em> Here&#x27;s a summary of Admin and Add-on <em>manager</em> capabilities with New Relic Synthetics. To allow a User or Restricted User"
      },
      "id": "603e88b2e7b9d2a3f12a07d5"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-08-03T00:43:02Z",
      "updated_at": "2021-07-21T13:27:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in New Relic One. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, browser, and mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the data explorer. Learn more about querying data in New Relic. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of browser data Here's a NRQL query of PageView data from browser monitoring. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for browser monitoring PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.22829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "tags": "Query your <em>data</em>",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>"
      },
      "id": "60445a0e196a67cb09960f6e"
    },
    {
      "sections": [
        "Use integration data in New Relic dashboards",
        "Get started with integration data",
        "Example NRQL queries",
        "AWS EBS query example",
        "Azure Service Bus query example",
        "Azure Functions query example",
        "Azure VMs query example",
        "NGINX query example",
        "MySQL query example",
        "Inventory change query example",
        "Tip",
        "Tips for using different data types",
        "Metric data tips",
        "Event data tips",
        "Inventory data tips"
      ],
      "title": "Use integration data in New Relic dashboards",
      "type": "docs",
      "tags": [
        "Integrations",
        "Infrastructure integrations",
        "Get started"
      ],
      "external_id": "b236b0fae29853de085d0430fdec27fba74c15d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/infrastructure-integrations/get-started/use-integration-data-new-relic-dashboards/",
      "published_at": "2021-08-02T09:05:50Z",
      "updated_at": "2021-07-21T20:24:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Most data generated by integrations is available in New Relic One dashboards, where you can query your data using NRQL and build custom dashboards. The following tips and sample queries were created for New Relic-built integrations, but most will also apply to integrations built with the Integrations SDK. For a general look at how to find and use integration data, see New Relic data types. Get started with integration data Here are some tips for finding and exploring your integration data in New Relic: From the one.newrelic.com > Infrastructure > Third-party services page, select an integration dashboard. There, you can view the NRQL queries that generated a chart. For examples of NRQL queries for integration data, see the example queries. Use the data explorer or the dashboards to explore and understand the available data. Read the documentation for a specific integration to learn about the reported data. When you create a useful query you'd like to add to your dashboard, select Add to dashboard. Example NRQL queries Here are some examples of NRQL queries that use integration data: AWS EBS query example Here's a NRQL query for the AWS EBS service, showing the total write time metric, faceted by entityName: SELECT sum('provider.volumeTotalWriteTime.Sum') FROM BlockDeviceSample WHERE provider = 'EbsVolume' FACET entityName Copy Azure Service Bus query example Here's a NRQL query for the maximum number of messages in an Azure Service Bus topic queue, faceted by resource group: SELECT max(activeMessages.Maximum) FROM AzureServiceBusTopicSample FACET resourceGroupName Copy Azure Functions query example Here's a NRQL query for Azure Functions, showing the count of executed functions over the past six hours by region over time: SELECT sum(functionExecutionCount.Total) FROM AzureFunctionsAppSample FACET regionName TIMESERIES SINCE 6 hours ago Copy Azure VMs query example Here's a NRQL query for Azure VMs that compares the count of VM events over the past thirty minutes with the same time a week ago: SELECT uniqueCount(vMName) FROM AzureVirtualMachineScaleSetSample FACET name SINCE 30 minutes ago COMPARE WITH 1 week ago Copy NGINX query example Here's an example of a query that you might run on your NGINX integration data and place in a dashboard. This query creates a chart showing the average value of NGINX requests per second over time: SELECT average(net.requestsPerSecond) FROM NginxSample TIMESERIES Copy For more on how to create queries, see NRQL syntax. MySQL query example Here's an example of a query that you might run on your MySQL integration data. This query generates a chart showing the maximum number of used MySQL connections: SELECT max(net.maxUsedConnections) FROM MysqlSample Copy For more on how to create queries, see NRQL syntax. Inventory change query example Here's an example of a query that groups inventory change events from the last day by the type of change: SELECT count(*) FROM InfrastructureEvent WHERE format='inventoryChange' FACET changeType SINCE 1 DAY AGO Copy Tip You can also perform these queries using dimensional metrics. Tips for using different data types Integrations can generate metric, event, and inventory data, all of which are available for querying. Here are some tips for using the different types of integration data: Metric data tips Tips for finding and using integration metric data: All integration data is attached to a data type known as an event (not to be confused with events reported by integrations, which represent important activity in your host/service). This means that all integration data can be found via the data explorer. For more about these two basic New Relic data types, see New Relic data collection. Metric values are treated as attributes: key-value pairs attached to an event. For example, the MySQL integration has an 'active connections' metric; this would be found by querying the connectionsActive attribute of the MysqlSample event. For general information about metrics, see Integration metric data. Event data tips Here are some tips for finding and using integration event data when querying: Most integration events are inventory change events. When inventory is changed, it generates an InfrastructureEvent with a format value of inventoryChange. Integration data can be found via the data explorer. For general information about events, see Event data. Inventory data tips Here are some tips for finding and using integration inventory data: For general information about inventory data, see Integration inventory data. Some inventory data is added as attributes (key-value pairs) to this data. For example, the AWS EC2 integration collects awsRegion as inventory data; this would be found by querying the awsRegion attribute of the ComputeSample event type and provider Ec2Instance. When inventory data changes, an InfrastructureEvent event type is generated with a format value of inventoryChange. See the query examples for an example of querying this data. For more on using NRQL queries, see Intro to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.113266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use integration <em>data</em> in New Relic dashboards",
        "sections": "Use integration <em>data</em> in New Relic dashboards",
        "body": "(net.requestsPerSecond) FROM NginxSample TIMESERIES Copy For more on how to create queries, see <em>NRQL</em> <em>syntax</em>. MySQL query example Here&#x27;s an example of a query that you might run on your MySQL integration <em>data</em>. This query generates a chart showing the maximum number of used MySQL connections: SELECT max"
      },
      "id": "60450a39196a67d7dc960f7c"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "Facet non-matching data with OR",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Functions",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "capture(attribute, regular expression)",
        "capture() within a SELECT clause condition",
        "capture() within a FACET clause condition",
        "capture() within a WHERE clause condition",
        "capture() with a numeric cast",
        "Non-aggregator functions",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/static/507a44dd5750a7c536bee652e105179f/8c557/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-08-02T05:47:43Z",
      "updated_at": "2021-08-02T05:47:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute, and you can use the OR operator to facet results that don't match any of your specified cases. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy Facet non-matching data with OR This example uses the OR operator to facet results that didn't match any of your cases: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. See Use the time picker to adjust time settings for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE r'z.*|q.*'' hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*' z-app q-app ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Functions Here is a listing of the available functions in NRQL. The definitions below contain example NRQL queries. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT uniques(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy capture(attribute, regular expression) Use the capture() to extract values from an attribute using a regular expression. Uses RE2 syntax. It takes two arguments: Attribute name Regular expression with capture syntax. Regex expressions in NRQL use Python-like syntax, r'...'. When capturing, use the RE2 named-capture syntax ...(?P<name> pattern )... to capture the contained pattern, given the specified name. Currently, only 1 capture group is supported. Please see the examples below. capture() within a SELECT clause condition The following will select the domain name of the website, removing https:// and any paths following the .com SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago Copy The following will capture only the first word of the error message. SELECT capture(errorMessage, r'(?P<firstWord>\\S+)\\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null Copy capture() within a FACET clause condition The following will facet by the captured HTTP method. SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* \"(?P<httpMethod>[A-Z]+) .*') Copy capture() within a WHERE clause condition The following will filter the results based on Log events with message attribute that matches the regular expression where the captured job name is ExampleJob. SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago Copy capture() with a numeric cast The following will capture sum of CPU Time from log lines. You must explicitly cast to numeric to do mathematical operations. SELECT sum(numeric(capture(message, r'.*CpuTime:\\s(?P<cpuTime>\\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago Copy Non-aggregator functions Use non-aggregator functions for non-numerical data in NRQL queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from compound data types, such as metric data. It takes the following arguments: Metric type Supported fields summary count, total, max, min, type gauge count, total, max, min, latest, type distribution count, total, max, min, type counter count, type timeslice count, total, totalExclusive, min, and max Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.7655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>syntax</em>, clauses, and functions",
        "sections": "<em>NRQL</em> <em>syntax</em>, clauses, and functions",
        "tags": "Query your <em>data</em>",
        "body": " <em>NRQL</em> is used for, what <em>data</em> you can query with it, and basic <em>NRQL</em> <em>syntax</em> Examine <em>NRQL</em> queries used to build New Relic charts Learn how to query the Metric <em>data</em> type Simulate SQL JOIN functions Use funnels to evaluate a series of related <em>data</em> Format <em>NRQL</em> for querying with the Event API Query"
      },
      "id": "604456c1196a678db8960f41"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Access and requirements",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-08-02T05:41:35Z",
      "updated_at": "2021-08-02T05:41:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Access and requirements You'll need a New Relic Insert API key. For information on limits and restricted attributes, see Metric API requirements and limits. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting If you receive an NrIntegrationError, see Troubleshoot a NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.3905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find and use your <em>data</em>",
        "tags": "Telemetry <em>Data</em> Platform",
        "body": " For more on querying, see Metric query examples. For information on querying in general, see Query <em>data</em>. Alert on metric <em>data</em> To alert on metrics created with the Metric API, use <em>NRQL</em> alert conditions: Select the <em>NRQL</em> category when defining your condition, then use the FROM Metric ... <em>NRQL</em> query <em>syntax</em>"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-08-03T00:45:07Z",
      "updated_at": "2021-03-16T13:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.689926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY",
        "tags": "Query your <em>data</em>",
        "body": " high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar <em>data</em> but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid <em>NRQL</em>"
      },
      "id": "603e8a2528ccbc56e5eba774"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-08-03T01:40:49Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.04797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "6091fa98e7b9d215455068c4"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-08-03T01:45:31Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.03538,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "6091fa9928ccbc8f44a2689c"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-08-03T00:35:46Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.019318,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": ", go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-08-03T00:38:53Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.523376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-08-03T00:37:51Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.46073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. <em>Explore</em> your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.40822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": ": AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information"
      },
      "id": "6091fa39e7b9d2e1425068b8"
    },
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "@Trace",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "@TraceLambda",
        "Properties for @TraceLambda",
        "pattern",
        "includeNonstatic",
        "@TraceByReturnType",
        "Properties for @TraceByReturnType",
        "traceReturnTypes",
        "Performance considerations",
        "Caution",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-08-02T07:25:36Z",
      "updated_at": "2021-07-15T18:31:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. Make sure that newrelic-api.jar appears in your classpath as it contains all these annotations. @Trace Annotating a method with @Trace tells the Java agent that measurements should be taken for that method. To add a method call as a custom trace add @Trace annotations to your method. import com.newrelic.api.agent.Trace; ... @Trace public void run() { // background task } Copy Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy @TraceLambda If your transaction traces show large blocks of uninstrumented time and you want to include lambda expressions within the trace, you can use the @TraceLambda annotation without parameters: import com.newrelic.api.agent.TraceLambda; @TraceLambda class ClassContainingLambdaExpressions() { // work } Copy Lambda expressions become static methods of the containing class after compilation. By default, static methods within classes marked with the @TraceLambda annotation matching the annotations pattern will be marked with the @Trace annotation. Properties for @TraceLambda The @TraceLambda annotation supports the following properties. pattern Type: String Default: ^\\$?(lambda\\|anonfun)\\$(?\\<name\\>.*) If you set the pattern, as in @TraceLambda(pattern=\"YourPattern\"), then the marked classes method names will be matched against the regex pattern YourPattern. If matched the related method will be marked with the @Trace annotation. Here is an example: @TraceLambda(pattern=\"YourPattern\") Copy includeNonstatic Type: Boolean Default: false If true, the marked classes nonstatic methods will be eligible for assessment against the pattern for instrumentation. Here is an example: @TraceLambda(includeNonstatic=\"true\") Copy @TraceByReturnType To include methods with a particular return type within the trace, you can use the @TraceByReturnType annotation to mark a class passing the return types as a property. Methods in annotated classes that match one of the specified return types will be marked with the @Trace annotation. @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { // ... } Copy Properties for @TraceByReturnType The @TraceByReturnType annotation supports the following properties. traceReturnTypes Type: List < Class> Default: empty list If you set the traceReturnTypes, as in @TraceByReturnType(traceReturnTypes={String.class}), then the marked classes method return types will be matched against the String.class. All matched methods will be marked with the @Trace annotation. Here is an example: @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { public String doSomething() { // matches // ... } public Long somethingElse() { // does not match // ... } } Copy Performance considerations When the Java agent is present in the JVM, it will inject code on the annotated methods. The performance hit is negligible in heavyweight operations, such as database or webservice calls, but is noticeable in methods that are called frequently, such as an accessor called thousands of times a second. Caution Do not instrument all of your methods, as this can lead to decreased performance and to a metric grouping issue. More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.400608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.<em>METHOD</em>) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public <em>static</em> final String NULL = &quot;&quot;; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360/",
      "sections": [
        "Java agent v3.36.0",
        "Improvements",
        "Fixes"
      ],
      "published_at": "2021-08-02T20:09:19Z",
      "title": "Java agent v3.36.0",
      "updated_at": "2021-03-11T03:30:39Z",
      "type": "docs",
      "external_id": "620b9aa4068c44bd29515f153020db735791cd39",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.644382,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page"
      },
      "id": "60445ebc196a676dd6960f5e"
    },
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-08-02T03:32:58Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 36.653076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Child nodes for <em>method</em>",
        "body": ". The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non <em>static</em> <em>methods</em> (defaults to false); pattern - a string with the pattern to search for the lambda <em>methods</em>. Child nodes for <em>method</em> The <em>method</em> node can have several children. For more information"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-08-02T18:28:59Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 26.01374,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-08-03T01:41:02Z",
      "updated_at": "2021-08-02T22:59:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Add muting rules to suppress notifications Manage notification channels Customize loss of signal and gap filling The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.511,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using Alerts via <em>NerdGraph</em> API",
        "sections": "<em>Mutations</em>",
        "tags": "Alerts and <em>Nerdgraph</em>",
        "body": " Use NRQL conditions Add muting rules to suppress notifications Manage notification channels Customize loss of signal and gap filling The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2021-08-03T00:12:08Z",
      "updated_at": "2021-08-03T00:12:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use violation event attributes and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.38875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Manage muting rules with <em>NerdGraph</em>",
        "body": " of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with <em>NerdGraph</em> In <em>NerdGraph</em>, you can use the following queries and <em>mutations</em> with your muting"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Dashboards API",
        "Starting out with NerdGraph",
        "Operations",
        "Dashboard CRUD operations",
        "Dashboard page operations",
        "Other operations",
        "Limits",
        "Dashboard limits",
        "Dashboard page limits",
        "Widget limits",
        "Errors as first class citizens",
        "Errors as part of every mutation response"
      ],
      "title": "Dashboards API",
      "type": "docs",
      "tags": [
        "Dashboards",
        "Dashboards API"
      ],
      "external_id": "96f807b5a19101ec83176ceeb95b822eb8165896",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-api/",
      "published_at": "2021-08-03T00:36:51Z",
      "updated_at": "2021-07-09T23:44:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Dashboards API allows you to create and manage dashboards. Starting out with NerdGraph If you're new to NerdGraph and GraphQL, you may want to first read our Introduction to NerdGraph. If you’re already familiar with the dashboards API, you can read Create dashboards with NerdGraph. When using NerdGraph, it helps to understand that our dashboards are entities that report data from other entities, such as monitored apps, hosts and services. Find the NerdGraph API explorer at api.newrelic.com/graphiql. Operations We have defined a granular GraphQL API that lets you execute different dashboard operations depending on their goal and scope. Dashboard CRUD operations Operation GraphQL operation type Notes actor > entity() query Get dashboard operation. You can get all dashboard and widget data for a given dashboard entity GUID. dashboardCreate() mutation Create dashboard operation. You can create a dashboard attached to a specific account by specifying all its elements, from metadata to widget configuration. dashboardUpdate() mutation Update dashboard operation. You can update an existing dashboard given a dashboard entity GUID. You need to specify the complete, updated dashboard elements, from metadata to widget configuration. dashboardDelete() mutation Delete dashboard operation. You can delete an existing dashboard given a dashboard entity GUID. This operation executes a logical delete that lets you recover your dashboard. dashboardUndelete() mutation Undelete dashboard operation. You can recover a previously deleted dashboard given a dashboard entity GUID. Dashboard page operations Operation GraphQL operation type Notes dashboardUpdatePage() mutation Update dashboard page operation. You can update one page of an existing dashboard given a dashboard page entity GUID. You need to specify the complete, updated dashboard page elements, from metadata to widget configuration. dashboardUpdateWidgetsInPage() mutation Update widgets operation. You can update a set of existing widgets of a dashboard page given a dashboard page entity GUID. You need to specify the set of widgets to be updated and their complete configuration. dashboardAddWidgetsToPage() mutation Add widgets operation. You can add a set of new widgets to a dashboard page given a dashboard page entity GUID. You need to specify the set of new widgets and their complete configuration. Other operations Operation GraphQL operation type Notes dashboardCreateSnapshotUrl() mutation Create dashboard page snapshot operation. You can create a public URL for a given dashboard page entity GUID. The dashboard page can then be accessed in the form of a static snapshot in the resulting public URL. actor > dashboard > liveUrls() query List all live URLs operation. You can get the complete list of live URLs you have access to. A live URL is a mechanism that allows you to share dashboard pages and widgets publicly with up-to-date or live data. dashboardWidgetRevokeLiveUrl() mutation Revoke widget live URL operation. You can revoke a previously created live URL of a widget. As a result, the live URL will become unavailable to the public. Limits We have limited the values you can set to some of the dashboard properties. This allows us to keep dashboards in good shape while boosting their usability. Dashboard limits Limit Value Maximum number of pages in a dashboard 20 Maximum length of a dashboard name 255 Maximum length of a dashboard description 1024 Dashboard page limits Limit Value Maximum number of widgets in a dashboard page 40 Maximum length of a dashboard page name 255 Maximum length of a dashboard page description 1024 Widget limits Limit Value Maximum length of a widget title 255 Maximum number of entities linked to a widget 1 Maximum number of queries in a widget 20 Maximum layout column of a widget 12 Minimum layout column of a widget 1 Minimum layout row of a widget 1 Maximum layout width of a widget 12 Minimum layout width of a widget 1 Maximum layout height of a widget 8 Minimum layout height of a widget 1 Errors as first class citizens All dashboard mutations offer a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect expected potential issues. Every error has a type and a description to help you identify what’s the source of the problem. Errors as part of every mutation response mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy Keep in mind that these are expected errors that we are aware of in advance. You should also check for unexpected errors that will be returned in the standard GraphQL errors field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.03812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Starting out with <em>NerdGraph</em>",
        "body": "The Dashboards API allows you to create and manage dashboards. Starting out with <em>NerdGraph</em> If you&#x27;re new to <em>NerdGraph</em> and GraphQL, you may want to first read our Introduction to <em>NerdGraph</em>. If you’re already familiar with the dashboards API, you can read Create dashboards with <em>NerdGraph</em>. When using"
      },
      "id": "60dd3c8328ccbc8f1a71b46c"
    },
    {
      "sections": [
        "NerdGraph tutorial: Manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "NerdGraph tutorial: Manage license keys and user keys",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-08-03T06:47:29Z",
      "updated_at": "2021-04-22T11:55:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.76146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Manage license keys and user keys",
        "sections": "<em>NerdGraph</em> tutorial: Manage license keys and user keys",
        "tags": "<em>NerdGraph</em>",
        "body": " to let you rotate keys for security purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. Notes about this functionality: All <em>mutations</em> can accept multiple keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    },
    {
      "sections": [
        "NerdGraph tutorial: Understand entity relationships and dependencies",
        "Relationship types",
        "Read relationships of an entity"
      ],
      "title": "NerdGraph tutorial: Understand entity relationships and dependencies",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "3699777ea1a7bf17213ccdaad3b44793e1561948",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-relationships-api-tutorial/",
      "published_at": "2021-08-03T06:45:39Z",
      "updated_at": "2021-08-03T06:45:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to understand how your monitored entities relate to each other is using our NerdGraph API. You can use the relatedEntities field to see how pairs of entities interact and how they're related. This can help troubleshoot upstream and downstream services and understand how minor issues may have larger repercussions, similar to how service maps can be used. Relationship types Relationship types provide additional information about how two entities are related. The supported relationship types are: Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source in addition to the one you are currently viewing. Read relationships of an entity You can use NerdGraph to return the relationships between your monitored entities. The following example shows how to query an entity by its specific GUID, using the NerdGraph GraphiQL explorer. For more information, see Use NerdGraph to query entities. query{ actor{ entity(guid: YOUR_ENTITY_GUID){ name relatedEntities { results { source { entity { guid name } } target { entity { guid name } } type } } } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.043785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Understand entity relationships and dependencies",
        "sections": "<em>NerdGraph</em> tutorial: Understand entity relationships and dependencies",
        "tags": "<em>NerdGraph</em>",
        "body": " use <em>NerdGraph</em> to return the relationships between your monitored entities. The following example shows how to <em>query</em> an entity by its specific GUID, using the <em>NerdGraph</em> GraphiQL explorer. For more information, see Use <em>NerdGraph</em> to <em>query</em> entities. <em>query</em>{ actor{ entity(guid: YOUR_ENTITY_GUID){ name relatedEntities { results { source { entity { guid name } } target { entity { guid name } } type } } } } } Copy"
      },
      "id": "603ec1c664441fb7ff4e8852"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Automate workflows",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.81059,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the <em>Kubernetes</em> <em>operator</em> 20"
      },
      "id": "6091f7c8e7b9d2f6715068f1"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Access and requirements",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-08-02T05:41:35Z",
      "updated_at": "2021-08-02T05:41:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Access and requirements You'll need a New Relic Insert API key. For information on limits and restricted attributes, see Metric API requirements and limits. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting If you receive an NrIntegrationError, see Troubleshoot a NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.06946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em> on metric data",
        "body": " For more on querying, see Metric query examples. For information on querying in general, see Query data. <em>Alert</em> on metric data To <em>alert</em> on metrics created with the Metric API, use <em>NRQL</em> <em>alert</em> <em>conditions</em>: Select the <em>NRQL</em> category when defining your condition, then use the FROM Metric ... <em>NRQL</em> query syntax"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Kubernetes integration: install and configure",
        "Use automated installer",
        "Installs for managed services and platforms",
        "Amazon EKS",
        "Amazon EKS Fargate",
        "Google Kubernetes Engine (GKE)",
        "OpenShift container platform",
        "Azure Kubernetes Service (AKS)",
        "Pivotal Container Service (PKS / VMware Tanzu)",
        "Custom manifest",
        "Important",
        "Make sure New Relic pods can be scheduled",
        "Unprivileged installs of the Kubernetes integration",
        "Tip",
        "Steps to complete an unprivileged install",
        "Configure the integration",
        "Select which processes should send their data to New Relic",
        "Specify the Kubernetes API host and port",
        "Kubernetes versions 1.6 to 1.7.5: Edit manifest file",
        "Use environment variables",
        "Disable kube-state-metrics parsing",
        "Caution",
        "Specify the kube-state-metrics URL",
        "Discover kube-state-metrics pods using a label",
        "Query kube-state-metrics behind RBAC",
        "kube-state-metrics timeout: Increase the client timeout",
        "Non-default namespace deployments: Edit config file",
        "Set the TTL for the Kubernetes API responses cache",
        "Specify base URLs for control plane component endpoints",
        "Configure the infrastructure agent",
        "Update to the latest version",
        "Using the automated installer",
        "Using helm",
        "Uninstall the Kubernetes integration"
      ],
      "title": "Kubernetes integration: install and configure",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Installation"
      ],
      "external_id": "ff06c8b1d8b2940d0b23034f3057377ce571e4ab",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure/",
      "published_at": "2021-08-02T11:47:18Z",
      "updated_at": "2021-08-02T11:47:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The easiest way to install the Kubernetes integration is to use our automated installer to generate a manifest. It bundles not just the integration DaemonSets, but also other New Relic Kubernetes configurations, like Kubernetes events, Prometheus OpenMetrics, and New Relic log monitoring. Want to try out our Kubernetes integration? Create a New Relic account for free! No credit card required. Use automated installer You can use the automated installer for servers, VMs, and unprivileged environments. The installer can also help you with managed services or platforms after you review a few preliminary notes. We also have separate instructions if you need a custom manifest or prefer to do a manual unprivileged installation. Start the installer If your New Relic account is in the EU region, access the installer from one.eu.newrelic.com. Installs for managed services and platforms Before starting our automated installer, check out these notes for your managed services or platforms: Amazon EKS The Kubernetes integration monitors worker nodes. In Amazon EKS, master nodes are managed by Amazon and abstracted from the Kubernetes platforms. Before starting our automated installer to deploy the Kubernetes integration in Amazon EKS, make sure you are using the version of kubectl provided by AWS. Amazon EKS Fargate For help installing our EKS Fargate integration, see these setup options. Google Kubernetes Engine (GKE) The Kubernetes integration monitors worker nodes. In GKE, master nodes are managed by Google and abstracted from the Kubernetes platforms. Before starting our automated installer to deploy the Kubernetes integration on GKE, ensure you have sufficient permissions: Go to console.cloud.google.com/iam-admin/iam and find your username. Click edit. Ensure you have permissions to create Roles and ClusterRoles: If you are not sure, add the Kubernetes Engine Cluster Admin role. If you cannot edit your user role, ask the owner of the GCP project to give you the necessary permissions. Ensure you have a RoleBinding that grants you the same permissions to create Roles and ClusterRoles: kubectl create clusterrolebinding YOUR_USERNAME-cluster-admin-binding --clusterrole=cluster-admin --user=YOUR_GCP_EMAIL Copy Creating a RoleBinding is necessary because of a known RBAC issue in Kubernetes and Kubernetes Engine versions 1.6 or higher. For more information, see Google Cloud's documentation on defining permissions in a role. OpenShift container platform To deploy the Kubernetes integration with OpenShift: Add the <>{'<release_name>'}</>-newrelic-infrastructure service account to your privileged Security Context Constraints: oc adm policy add-scc-to-user privileged \\ system:serviceaccount:<namespace>:<release_name>-newrelic-infrastructure Copy The default <>{'<release_name>'}</> provided by the installer is nri-bundle. Complete the steps in our automated installer. If you're using signed certificates, make sure they are properly configured by using the following variables in the DaemonSet portion of your manifest to set the .pem file: - name: NRIA_CA_BUNDLE_DIR value: YOUR_CA_BUNDLE_DIR - name: NRIA_CA_BUNDLE_FILE value: YOUR_CA_BUNDLE_NAME Copy YAML key path: spec.template.spec.containers.name.env Save your changes. Azure Kubernetes Service (AKS) The Kubernetes integration monitors worker nodes. In Azure Kubernetes Service, master nodes are managed by Azure and abstracted from the Kubernetes platforms. To deploy in Azure Kubernetes Service (AKS), complete the steps in our automated installer. Pivotal Container Service (PKS / VMware Tanzu) To deploy in PKS, we recommend that you use the automated installer, or you can follow the manual instructions provided in Install the Kubernetes integration using Helm. Custom manifest If the Kubernetes automated installer doesn't provide the settings you need, you can download our manifest template and install the integration manually. To activate the Kubernetes integration, you must deploy the newrelic-infra agent onto a Kubernetes cluster as a DaemonSet: Install kube-state-metrics and get it running on the cluster. For example: curl -L -o kube-state-metrics- 1.9.5 .zip https://github.com/kubernetes/kube-state-metrics/archive/v 1.9.5 .zip && unzip kube-state-metrics- 1.9.5 .zip && kubectl apply -f kube-state-metrics- 1.9.5 /examples/standard Copy Download the manifest file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml Copy In the DaemonSet portion of your manifest, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. Recommendation: Do not change the NRIA_PASSTHROUGH_ENVIRONMENT or NRIA_DISPLAY_NAME value in your manifest. YOUR_CLUSTER_NAME is your cluster’s id in New Relic Explorer. It doesn’t need to match the name of the cluster running in your environment. YAML key path: spec.template.spec.containers.name.env env: - name: NRIA_LICENSE_KEY value: YOUR_LICENSE_KEY - name: CLUSTER_NAME value: YOUR_CLUSTER_NAME Copy If you need to adapt the manifest to fit your environment, review the configure section in this doc. Confirm that kube-state-metrics is installed. kubectl get pods --all-namespaces | grep kube-state-metrics Copy Create the DaemonSet: kubectl create -f newrelic-infrastructure-k8s-latest.yaml Copy Confirm that the DaemonSet has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets Copy To confirm that the integration is working: wait a few minutes, then look for data in the New Relic Kubernetes cluster explorer. If you don't see data, review the configuration procedures again, then follow the troubleshooting procedures. Important In the future, the number of labels collected on Kubernetes objects will be limited per object type (containers, pods, nodes, etc.). If objects have labels above the limit, you will be able to configure important labels that should always be sent to New Relic. When the limitation is in place, this documentation will be updated. Make sure New Relic pods can be scheduled Some of the New Relic pods are set up as DaemonSet in the manifest file so that they can run on every host. These include newrelic-infrastructure and newrelic-logging. In rare circumstances, other pods may be scheduled first and starve the New Relic pods of resources. Since each of these pods have to run on a specific host, they will stay in pending status until that host has enough resources, even if there are other hosts available. This could end up occurring for long periods of time and result in reporting gaps. To prevent this scenario, you can configure the Kubernetes scheduler to give New Relic pods a higher priority. Using the default scheduler: Ensure kube-scheduler flag disablePreemption is not set to true (by default it is false). Create a PriorityClass for the New Relic DaemonSet pods: Set the appropriate priority value, which should generally be higher than your other pods. preemptionPolicy is set to PreemptLowerPriority by default. This allows New Relic pods assigned this priority class to remove lower-priority pods that are taking up resources. Edit the manifest file to add priorityClassName to any DaemonSet specs. In the example below, the highlighted line sets the priority class for newrelic-infrastructure: apiVersion: apps/v1 kind: DaemonSet metadata: namespace: default labels: app: newrelic-infrastructure chart: newrelic-infrastructure-1.0.0 release: nri-bundle mode: privileged name: nri-bundle-newrelic-infrastructure spec: priorityClassName: your-priority-class ... Copy If you have already deployed the New Relic pods, re-deploy them and confirm they have been created: kubectl delete -f newrelic-infrastructure-k8s-latest.yaml kubectl create -f newrelic-infrastructure-k8s-latest.yaml kubectl get daemonsets Copy Unprivileged installs of the Kubernetes integration For platforms that have stringent security requirements, we provide an unprivileged version of the Kubernetes integration. Changes from the standard Kubernetes integration are: Runs the infrastructure agent and the Kubernetes integration as a standard user instead of root No access to the underlying host filesystem No access to /var/run/docker.sock Container's root filesystem mounted as read-only allowPrivilegeEscalation is set to false hostnetwork is set to false The tradeoff is that the solution will only collect metrics from Kubernetes, but it will not collect any metric from the underlying hosts directly. Kubernetes provides some data (metrics and metadata) about its nodes (hosts). Tip Optional: To collect the underlying host metrics, the non-containerized infrastructure agent can be deployed on the underlying host. The infrastructure agent already supports running as non-root. The combination of the Kubernetes integration in its unprivileged version and the agent running on the host will report all the metrics that our standard solution for monitoring Kubernetes receives. Steps to complete an unprivileged install Install kube-state-metrics and get it running on the cluster. For example: curl -L -o kube-state-metrics- 1.9.5 .zip https://github.com/kubernetes/kube-state-metrics/archive/v 1.9.5 .zip && unzip kube-state-metrics- 1.9.5 .zip && kubectl apply -f kube-state-metrics- 1.9.5 /examples/standard Copy Download the integration manifest: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-unprivileged-latest.yaml Copy In the manifest, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. Important YOUR_CLUSTER_NAME is your cluster’s id in New Relic Explorer. It doesn’t need to match the name of the cluster running in your environment. env: - name: NRIA_LICENSE_KEY value: YOUR_LICENSE_KEY - name: CLUSTER_NAME value: YOUR_CLUSTER_NAME Copy YAML key path: spec.template.spec.containers.name.env Confirm that kube-state-metrics is installed. kubectl get pods --all-namespaces | grep kube-state-metrics Copy Create the DaemonSet: kubectl create -f newrelic-infrastructure-k8s-unprivileged-latest.yaml Copy Confirm that the DaemonSet has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets Copy To confirm that the integration has been configured correctly, wait a few minutes, then run this NRQL query to see if data has been reported: SELECT * FROM K8sPodSample since 5 minutes ago Copy Configure the integration The Kubernetes integration comes with a default configuration that should work in most environments. To change the configuration, modify the manifest file: Select which processes should send their data to New Relic By default, data about the processes running on your pods is not sent to New Relic. You can enable it by setting enable_process_metrics to true. To choose what metric data you want to send to New Relic, configure the include_matching_metrics environment variable in your manifest. Specify the Kubernetes API host and port This is necessary when you are using SSL and not using the default FQDN. The Kubernetes API FQDN needs to match the FQDN of the SSL certificate. You do not need to specify both variables. For example, if you only specify the HOST, the default PORT will be used. - name: \"KUBERNETES_SERVICE_HOST\" value: \"KUBERNETES_API_HOST\" - name: \"KUBERNETES_SERVICE_PORT\" value: \"KUBERNETES_API_TCP_PORT\" Copy Kubernetes versions 1.6 to 1.7.5: Edit manifest file For Kubernetes versions 1.6 to 1.7.5, uncomment these two lines in the manifest file: - name: \"CADVISOR_PORT\" # Enable direct connection to cAdvisor by specifying the port. Needed for Kubernetes versions prior to 1.7.6. value: \"4194\" Copy Use environment variables Use environment variables that can be passed to the Kubernetes integration if you use a proxy to configure its URL. Disable kube-state-metrics parsing You can disable kube-state-metrics parsing for the DaemonSet by using the following configuration: - name: \"DISABLE_KUBE_STATE_METRICS\" value: \"true\" Copy Caution Disabling kube-state-metrics also disables data collection for the following: ReplicaSets DaemonSets StatefulSets Namespaces Deployments Services Endpoints Pods (that are pending) Additionally, disabling this affects the Kubernetes Cluster Explorer in the following ways: No pending pods are shown. No filters based on services. Specify the kube-state-metrics URL If several instances of kube-state-metrics are present in the cluster, uncomment and configure the following lines to specify which one to use: - name: \"KUBE_STATE_METRICS_URL\" value: \"http://KUBE_STATE_METRICS_IP_OR_FQDN:PORT\" Copy Important Even though a KUBE_STATE_METRICS_URL is defined, the KSM service should contain one of the following labels for the auto-discovery process: k8s-app=kube-state-metrics OR app=kube-state-metrics OR ​​app.kubernetes.io/name=kube-state-metrics Important This configuration option overrides KUBE_STATE_METRICS_POD_LABEL. If you have both defined, KUBE_STATE_METRICS_POD_LABEL has no effect. Discover kube-state-metrics pods using a label If several instances of kube-state-metrics are present in the cluster, another option to easily target one of these instances with the Kubernetes integration is to use label-based discovery. - name: \"KUBE_STATE_METRICS_POD_LABEL\" value: \"LABEL_NAME\" Copy Important When a KUBE_STATE_METRICS_POD_LABEL is defined, the label should have a value equal to true. For example, if the label name is my-ksm, ensure that my-ksm=true. Important This configuration option is incompatible with KUBE_STATE_METRICS_URL. If you have both defined, KUBE_STATE_METRICS_URL is used. Query kube-state-metrics behind RBAC If your instance of kube-state-metrics is behind kube-rbac-proxy, the integration can be configured in a compatible way using the combination of the label-based discovery and two other environment variables: - name: \"KUBE_STATE_METRICS_SCHEME\" value: \"https\" - name: \"KUBE_STATE_METRICS_PORT\" value: \"KSM_RBAC_PROXY_PORT\" Copy To confirm which port should be used as the value of KUBE_STATE_METRICS_PORT, we recommend running a describe command on the kube-state-metrics pod and look for the port exposed by the container named kube-rbac-proxy-main. Important These two configuration options only work when using the KUBE_STATE_METRICS_POD_LABEL configuration described above. kube-state-metrics timeout: Increase the client timeout To increase the client timeout of kube-state-metrics, add a new environment variable, TIMEOUT, to the manifest file: env: - name: TIMEOUT value: 5000 # The default client timeout when calling kube-state-metrics, in milliseconds Copy Then, add this new environment variable to the NRIA_PASSTHROUGH_ENVIRONMENT Non-default namespace deployments: Edit config file If you want to deploy in a different namespace from default, change all values of namespace in the manifest. Set the TTL for the Kubernetes API responses cache By default, the integration will cache any retrieved information from the Kubernetes API for 5 minutes. Use the API_SERVER_CACHE_TTL environment variable to set a custom cache duration for responses from the API server. Valid time unit values are: ns, us, ms, s, m, and h. To disable caching, set to 0s. env: - name: API_SERVER_CACHE_TTL value: \"1m\" Copy Specify base URLs for control plane component endpoints Use the following environment variables if any of the Kubernetes control plane components export metrics on base URLs that are different from the defaults. This is necessary for environments such as OpenShift when a control plane component metrics endpoint is using SSL or an alternate port. Values of these environment variables must be base URLs of the form [scheme]://[host]:[port]. URLs should not include a path component. For example: - name: \"SCHEDULER_ENDPOINT_URL\" value: \"https://localhost:10259\" - name: \"ETCD_ENDPOINT_URL\" value: \"https://localhost:9979\" - name: \"CONTROLLER_MANAGER_ENDPOINT_URL\" value: \"https://localhost:10257\" - name: \"API_SERVER_ENDPOINT_URL\" value: \"https://localhost:6443\" Copy The /metrics path segment is added automatically. In addition, if the https scheme is used, authentication to the control plane component pod(s) is accomplished via service accounts. Caution If a FQDN (fully qualified domain name) is used in a multi-master cluster, inconsistent results may be returned. Therefore, it is recommended to use localhost only. Important Even though a custom base URL is defined for a given control plane component, the control plane component pod(s) must contain one of the labels supported by the auto-discovery process. Important Even though a custom ETCD_ENDPOINT_URL can be defined, ETCD will always require https and mTLS authentication to be configured. Here are some additional configurations to consider: Do more configuration for control plane monitoring Link New Relic APM to the Kubernetes integration Monitor services that run on Kubernetes Configure the infrastructure agent The Kubernetes integration image comes with a default configurations for the agent that can be modified if needed. When installing with the manifest, you can modify the infrastructure agent configuration by editing the manifest and adding any needed configuration option of the agent as environment variables of the newrelic-infrastructure DaemonSet. When installing with Helm, you can specify the needed infrastructure agent configuration options in the values.yaml as shown in the example in GitHub. The config object is used to populate the configMap that is mounted automatically in the location of the infrastructure agent configuration file in the pods created by the newrelic-infrastructure DaemonSet. Update to the latest version Using the automated installer To update a Kubernetes integration installed with the automated installer, just run the installer again. It will always offer a manifest pointing to the last released version of the integration. Using helm See Install the Kubernetes integration using Helm Custom manifest If you are already running the Kubernetes integration and want to update the newrelic-infra agent to the latest agent version: Run this NRQL query to check which version you are currently running (this will return the image name by cluster): SELECT latest(containerImage) FROM K8sContainerSample WHERE containerImage LIKE '%newrelic/infrastructure%' FACET clusterName SINCE 1 day ago Copy If you've set a name other than newrelic/infrastructure for the integration's container image, the above query won't yield results: to make it work, edit the name in the query. Download the integration manifest file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml Copy Copy the changes you made to the manifest. At a minimum, include CLUSTER_NAME and NRIA_LICENSE_KEY, and paste your changes in the manifest you downloaded. Install the latest DaemonSet with the following command (Kubernetes will automatically do a rollout upgrade for the integration's pods): kubectl apply -f newrelic-infrastructure-k8s-latest.yaml Copy Uninstall the Kubernetes integration To uninstall the Kubernetes integration: Verify that newrelic-infrastructure-k8s-latest.yaml corresponds to the filename of the manifest as you have saved it. Example: If you are using the unprivileged version of the integration, the default filename will be newrelic-infrastructure-k8s-unprivileged-latest.yaml. After you verify the filename, use the following command: kubectl delete -f newrelic-infrastructure-k8s-latest.yaml Copy You only need to execute this command once, regardless of the number of nodes in your cluster.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.32747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Kubernetes</em> integration: install and configure",
        "sections": "<em>Kubernetes</em> integration: install and configure",
        "tags": "<em>Kubernetes</em> integration",
        "body": " pointing to the last released version of the integration. Using helm See Install the <em>Kubernetes</em> integration using Helm Custom manifest If you are already running the <em>Kubernetes</em> integration and want to update the newrelic-infra agent to the latest agent version: Run this <em>NRQL</em> query to check which version"
      },
      "id": "60450ae964441f0603378f15"
    },
    {
      "sections": [
        "Install Kubernetes events integration",
        "Requirements",
        "Install the Kubernetes events integration",
        "View your Kubernetes events",
        "Query events",
        "Get attributes names",
        "See event details",
        "Search events in New Relic",
        "View events in the Kubernetes cluster explorer",
        "Optional: Collect metrics of the event collector",
        "Optional: Define custom attributes",
        "Troubleshooting",
        "Get logs on event collection",
        "Get logs on sending events"
      ],
      "title": "Install Kubernetes events integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Kubernetes events"
      ],
      "external_id": "a19259cc9ac093cc7acf401c1201e48d5daa9682",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/kubernetes-events/install-kubernetes-events-integration/",
      "published_at": "2021-08-02T10:27:44Z",
      "updated_at": "2021-07-27T13:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Kubernetes events integration watches for events happening in your Kubernetes clusters and sends those events to New Relic. To visualize your event data, use the Kubernetes cluster explorer in New Relic One platform, or use the infrastructure events UI. Requirements The Kubernetes events integration requires you to: Install and activate the New Relic Kubernetes integration. Configure a Kubernetes pod with the label app.kubernetes.io/name=nri-kube-events and two containers, one used to capture events in the Kubernetes cluster and the other to forward the events to New Relic. Install the Kubernetes events integration To install the New Relic Kubernetes events integration in a Kubernetes environment: Download the integration manifest YAML file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/nri-kube-events-latest.yaml Copy Edit the nri-kube-events-latest.yaml manifest file, adding both a cluster name, to identify your Kubernetes cluster (required), and your New Relic license key (required). clusterName: \"YOUR_CLUSTER_NAME\" [...] - name: \"NRIA_LICENSE_KEY\" value: \"YOUR_LICENSE_KEY\" Copy Deploy the integration in your Kubernetes cluster: kubectl apply -f nri-kube-events-latest.yaml Copy To confirm that the integration has been configured correctly, wait a few minutes, then go to one.newrelic.com > Query builder, and run the following NRQL query to see if data has been reported: FROM InfrastructureEvent SELECT count(*) WHERE clusterName = 'YOUR_CLUSTER_NAME' since 1 hour ago Copy View your Kubernetes events Once you have successfully installed the Kubernetes event integration, you can view and query your events in New Relic. To add events to your New Relic One dashboard: Add a chart to a new or existing dashboard or create a chart using the New Relic query builder. When creating or updating your chart, select the chart type table and use the following event query, replacing YOUR_CLUSTER_NAME with the name of your cluster: FROM InfrastructureEvent SELECT event.involvedObject.kind,event.involvedObject.name,event.reason,event.message WHERE clusterName = 'YOUR_CLUSTER_NAME' limit 100 Copy Query events Here are a few examples to query your data: Get attributes names To see all the attributes names, use the following query: FROM InfrastructureEvent SELECT keyset() WHERE category = 'kubernetes' Copy See event details To see details about the latest events in a cluster, use the following query, replacing YOUR_CLUSTER_NAME with the name of your cluster: FROM InfrastructureEvent SELECT event.involvedObject.kind, event.involvedObject.name, event.type, event.message, event.reason WHERE category = 'kubernetes' AND clusterName='YOUR_CLUSTER_NAME'​ Copy The events collected by New Relic will have the exact same attributes as given by Kubernetes. For a reference of these attributes, see the Kubernetes event v1 core documentation. Search events in New Relic To search events in the New Relic Infrastructure UI: Navigate to the Infrastructure event page: Go to one.newrelic.com > Infrastructure > Events. In Category, select kubernetes. Use the Search events field to look for specific events. To focus on a specific set of events, select or change the filter set. View events in the Kubernetes cluster explorer To view events in the Kubernetes cluster explorer, use either of these methods: In New Relic One: Go to one.newrelic.com > Kubernetes cluster explorer. Then, to view the pod details: In the Kubernetes cluster explorer, select a pod. Select Show pod events. Optional: Collect metrics of the event collector To collect metric data for the event collector itself, install the New Relic Prometheus OpenMetrics integration. To get started: Install the New Relic Prometheus OpenMetrics integration. Label the deployment of your Kubernetes events integration with your configured scrape label (default is prometheus.io/scrape=true). Optional: Define custom attributes To add custom attributes to the events sent by the integration these need to be specified as environment variables following the nomenclature NRI_KUBE_EVENTS_attributeKey=attributeValue. These environment variables should be defined as part of the spec for the kube-events container. For example, to add the attribute environment with value staging to all the events, add the following to your manifest: env: - name: NRI_KUBE_EVENTS_environment value: dev Copy Be sure to specify the environment in the spec for the kube-events container, making your manifest look something like this: ... kind: Deployment ... spec: ... template: ... spec: containers: - name: kube-events ... env: - name: NRI_KUBE_EVENTS_environment value: dev Copy Troubleshooting Here are some troubleshooting tips when using the Kubernetes events integration. Get logs on event collection To check the logs of our event collector: kubectl logs deploy/nr-kube-events kube-events Copy To add more details, enable verbose mode by adding verbose: \"true\" in the config section of you configuration file, either before or after the clusterName. Get logs on sending events To check the logs of the agent responsible for sending the events to New Relic: kubectl logs deploy/nr-kube-events infra-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.6644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Kubernetes</em> events integration",
        "sections": "Install <em>Kubernetes</em> events integration",
        "tags": "<em>Kubernetes</em> integration",
        "body": "The New Relic <em>Kubernetes</em> events integration watches for events happening in your <em>Kubernetes</em> clusters and sends those events to New Relic. To visualize your event data, use the <em>Kubernetes</em> cluster explorer in New Relic One platform, or use the infrastructure events UI. Requirements The <em>Kubernetes</em>"
      },
      "id": "603eae45196a67b26ba83d8f"
    },
    {
      "sections": [
        "Kubernetes integration: compatibility and requirements",
        "Compatibility",
        "Requirements",
        "Install using Helm"
      ],
      "title": "Kubernetes integration: compatibility and requirements",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Get started"
      ],
      "external_id": "e9bbd729904fa01739eb91e4f3c74561b51c2ba1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements/",
      "published_at": "2021-08-02T10:25:43Z",
      "updated_at": "2021-08-02T10:25:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Kubernetes integration can be installed directly on a server or VM, or through several cloud platforms, such as GKE, EKS, AKS, or OpenShift. Each has a different compatibility with our integration. Compatibility Our Kubernetes integration is compatible with the following versions, depending on the installation mode: Install mode or feature Kubernetes versions Kubernetes cluster Currently tested with versions 1.10 to 1.21 Kubernetes cluster GKE Currently tested with versions 1.17 to 1.19 Kubernetes cluster EKS (EC2 nodes or Fargate) Compatible with version 1.11 or higher Kubernetes cluster AKS Compatible with version 1.11 or higher Kubernetes cluster OpenShift Currently tested with versions 3.7, 3.9, 4.2, 4.3, 4.4, 4.5 and 4.6 Kubernetes cluster VMware Tanzu Compatible with VMware Tanzu (Pivotal Platform) version 2.5 to 2.11, and Ops Manager version 2.5 to 2.10 Control plane monitoring Compatible with version 1.11 or higher Service monitoring Compatible with version 1.13 or higher Requirements The New Relic Kubernetes integration has the following requirements: A New Relic account. Don't have one? Sign up for free. No credit card required. Linux distribution compatible with New Relic infrastructure agent. kube-state-metrics version 1.9.8 running on the cluster. When using CRI-O as the container runtime, the processes inside containers are not reported. Performance data is collected at the container level. Install using Helm For compatibility and requirements when installing the Kubernetes integration using Helm, see Alternative install using Helm.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.64938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Kubernetes</em> integration: compatibility and requirements",
        "sections": "<em>Kubernetes</em> integration: compatibility and requirements",
        "tags": "<em>Kubernetes</em> integration",
        "body": "New Relic&#x27;s <em>Kubernetes</em> integration can be installed directly on a server or VM, or through several cloud platforms, such as GKE, EKS, AKS, or OpenShift. Each has a different compatibility with our integration. Compatibility Our <em>Kubernetes</em> integration is compatible with the following versions"
      },
      "id": "603e92dc64441f3a974e8891"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-08-03T01:45:10Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.04784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "6091fa99196a67e912d52a10"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-08-03T01:45:31Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.03538,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "6091fa9928ccbc8f44a2689c"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-08-03T00:35:46Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.019318,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": ", go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-08-03T00:38:53Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.523376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-08-03T00:37:51Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.46073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. <em>Explore</em> your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-08-03T01:43:04Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.63712,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6091fa9928ccbc8a70a268ac"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-08-03T01:43:12Z",
      "updated_at": "2021-06-25T01:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostConditions directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_policy\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your main.tf and provider.tf to the stage for commit: bash Copy $ git add main.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.83969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "6091fa98e7b9d2063e506919"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-08-03T01:44:08Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.4988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "6091fa9964441fe25f2f36f4"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-07-18T01:40:25Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.30005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "6091fa9828ccbc8fdaa26899"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-08-02T22:59:55Z",
      "updated_at": "2021-07-22T04:34:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more child accounts, the notification channel includes only users for the currently selected parent or child account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.28873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-08-03T01:40:49Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.04797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "6091fa98e7b9d215455068c4"
    },
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-08-03T01:45:10Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.04784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "6091fa99196a67e912d52a10"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Why it matters",
        "Tip",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "3e9b224cd3c33fa278974feb4746ffcae0f66004",
      "image": "https://docs.newrelic.com/static/e31aec3eac2aa8c43b9e0332f87f033b/38cea/browse_data_explorer.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer/",
      "published_at": "2021-08-03T00:35:46Z",
      "updated_at": "2021-07-27T21:12:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces query interfaces to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From the data explorer you can access the query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.019318,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": ", go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Duplicate your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-08-03T00:38:53Z",
      "updated_at": "2021-07-27T22:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Duplicate your dashboard You can duplicate your dashboard clicking the duplicate icon regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. The duplicate has Public - Read and write permissions. Access the new, duplicated dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word “copy”. For example, if you duplicate a dashboard named This is my dashboard, the duplicate is called This is my dashboard copy. You can change the name when you duplicate it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.523376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Tip",
        "Import a dashboard",
        "Duplicate a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-08-03T00:37:51Z",
      "updated_at": "2021-07-27T21:16:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By duplicating an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Duplicate a dashboard Duplicate any dashboard by clicking the Duplicate dashboard button that appears when you hover over any dashboard row in the index. You can duplicate any dashboard regardless of your permission levels. The dashboard is automatically copied and the duplicate is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The duplicated dashboard is named like the original dashboard followed by the word \"copy\". For example, if you duplicate a dashboard named this is my dashboard, the duplicate will be created as this is my dashboard copy. The duplicate has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your duplicated dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can duplicate it. Private: Only you can see the dashboard. Everything but the metadata is hidden. When you create a dashboard using the Create a dashboard button or by duplicating another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.46073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " Relic platform. Why it matters With New Relic One dashboards you can customize and understand the data you collect. <em>Explore</em> your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 724.71564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": " default class MyAwesome<em>NerdpackNerdletNerdlet</em> extends React.Component { render() { return &lt;h1&gt;&quot;Hello, World!&quot;&lt;&#x2F;h1&gt;; } } Copy Step 4 of 9 As an optional step, you can add a custom <em>launcher</em> icon using any image <em>file</em> named icon.png. Replace the default icon.png <em>file</em> under <em>launcher</em> by dragging in your <em>new</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 639.9116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes <em>launchers</em>, <em>Nerdlets</em>, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the <em>New</em> <em>Relic</em> platform. Guides to serve, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 624.95544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "<em>Launchers</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " up your <em>New</em> <em>Relic</em> <em>One</em> application. Since ab-test-<em>nerdlet</em> is the only <em>Nerdlet</em> in this <em>Nerdpack</em>, there is only <em>one</em> subdirectory. In <em>nerdlets</em>&#x2F;ab-test-<em>nerdlet</em>, there are three files: index.js is the JavaScript <em>file</em> that contains your <em>Nerdlet</em> component styles.scss holds the Sass stylesheet for your"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 352.8094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions: <em>New</em> <em>Relic</em> <em>One</em> user model",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": ", review the tables below for a summary of your <em>Nerdpack</em> capabilities. Original user model If your organization was created before July 30, 2020 and you haven&#x27;t transitioned to our <em>New</em> <em>Relic</em> <em>One</em> pricing model, you&#x27;re on the original pricing plan. Capabilities for our original user model differ from those"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 308.12164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable advanced configurations for your <em>Nerdpack</em>",
        "sections": "Enable advanced configurations for your <em>Nerdpack</em>",
        "info": "Enable advanced configurations for your <em>Nerdpack</em>",
        "body": "Most of the time, the nr1 <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, <em>Nerdlets</em>, <em>launchers</em>, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.32053,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.72597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.84073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how your system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Features",
        "Improved query abilities",
        "Improved visualizations",
        "Steps for a successful transition"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-08-02T12:17:49Z",
      "updated_at": "2021-07-21T20:51:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we're upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries, charts, and dashboards. With New Relic One, we have modernized the experience for you to access, analyze, and visualize your data. New Relic One offers an improved charts and dashboards experience, and it provides a platform where we can more rapidly bring new innovations to you. This transition guide can help you understand: What are some of the new and improved features you get with New Relic One charts, dashboards, and queries Why it's easy to transition to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Features You can scroll down to the transition details, but first here are some features we've added that show how New Relic One dashboards are a clear improvement over Insights dashboards. Improved query abilities With New Relic One, you get: Ability to query many accounts from the same widget: New Relic One lets you query across all your associated accounts in one place. Better querying and charting experiences: Query access is available globally, no matter where you are in New Relic One. Learn how to browse and query data in New Relic. Improved query experience: You can query both the Metric data type and metric timeslice data. Easy customization: Every visualization now has the query accessible. You can augment any curated chart just by changing the NRQL query. Improved visualizations Not only can you select a wide range of visualization options, you can also add more to your dashboards: Better display options: Make your data easier to understand by using visualizations other than dense, line-heavy charts. New Relic One also offers a better TV mode. Facet linking: You can filter your dashboards by faceted attributes, making your dashboards more interactive and easy to use. There's also support for cases. Learn more. More charts or widgets in an area: Insights restricted you to a 3-across limit. Now you can display up to 12 across your dashboard, providing increased data density along with improved tooltips and tracking across charts. Easier creation of multi-page dashboards: Insights referred to these as data apps. Your Insights data apps are preserved as multi-page dashboards in New Relic One. Chart consistency and flexibility: Dashboards include facet color consistency across widgets and faster loading times for more performant dashboards. Also, you can add any chart type to a dashboard in New Relic One! The New Relic Insights UI has served our users well for many years, but it's time to give you an even better experience. Join us and make the switch to New Relic One! Steps for a successful transition The transition to New Relic One has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to New Relic One UI We have already taken care of your transition from Insights to New Relic One for you! As of April 12, 2021, your old Insights URLs redirect automatically to New Relic One. We recommend that you familiarize yourself with the new UI features available to you, as described in this transition guide. If you need to view any Insights charts embedded in other websites, go to one.newrelic.com > More > Manage Data. (These older embedded charts will continue to function as expected.) Mobile apps The Insights mobile app is deprecated as of April 11, 2021. Go to the Google Play Store 2 or Apple App store. Delete your old Insights mobile app, and download the New Relic One mobile app. tvOS apps and large displays New Relic's tvOS app is still available. No action is needed by you at this time. Some New Relic customers with the original pricing model may have set up dashboards on wall screens for restricted users with kiosk mode. No action is required for you to continue to view these dashboards. APIs In July of 2021, the Insights Dashboard API will be deprecated and replaced with NerdGraph functionality. For more on this change, and tips on how to migrate, see NerdGraph API for dashboards. Partnership accounts This applies only if your account is one of the few using our partnership account structure to deliver New Relic services to your direct customers. In this situation, the Insights EOL will not affect your customers’ pricing. This is simply an EOL for the UI, not an EOL for the account type. Questions If you have questions about the transition, please comment in our Explorers Hub post. Or, if you work with an account team, they will be happy to help you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.32948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "! Steps for a successful transition The transition to <em>New</em> <em>Relic</em> <em>One</em> has two parts: the UI and mobile <em>app</em> experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to <em>New</em> <em>Relic</em> <em>One</em> UI We have already taken care of your transition from Insights to <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.76624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 642.9652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the <em>NerdGraphQuery</em> <em>component</em> to an application 20 minutes The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-query/",
      "sections": [
        "NerdGraphQuery",
        "Usage",
        "Examples",
        "Props",
        "Methods",
        "NerdGraphQuery.query",
        "Type definitions",
        "PromiseQueryResult",
        "QueryResult"
      ],
      "published_at": "2021-08-03T01:49:50Z",
      "title": "NerdGraphQuery",
      "updated_at": "2021-06-25T01:48:19Z",
      "type": "developer",
      "external_id": "1ada6e056e031c141b2bb989e4ec200b3a7ce988",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One SDK provides Query components based on ApolloClient's query components. These components are an abstraction layer making it easier to query NerdGraph without worrying about configuring Apollo Client and, for the most common use cases, without having to write GraphQL queries. A generic NerdGraph Query component that allows you to query anything from NerdGraph. Usage import { NerdGraphQuery } from 'nr1' Copy Examples Props childrenfunction Render prop function as a child. function ( queryResult : QueryResult // Results of the query. ) => React.ReactNode fetchPolicyTypeenum DEFAULT NerdGraphQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_FIRST , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. Set to zero to avoid any kind of regular polling. queryrequiredstring|object GraphQL query, either as a string or a GraphQL document parsed into an AST by the gql method of nr1. skipboolean DEFAULT false When set to true, the query will be skipped entirely from rendering. variablesobject DEFAULT {} Object containing all of the variables your query needs to execute. Methods NerdGraphQuery.query Static method to use NerdGraphQuery as a Promise instead of as a React component. function ( props : Object // Object containing the query options. Any NerdGraphQuery prop is a valid option except children and pollInterval. ) Type definitions PromiseQueryResult { error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your query. fetchMore : function|null, // If not null, fetchMore allows you to load more results for your query. New data is merged with previous data. refetch : function, // Refetch the query. } QueryResult { loading : boolean, // Indicates that the request is in flight. error : ApolloClient.ApolloError, // Runtime error with graphQLErrors and networkError properties. data : Object, // Object containing the result of your query. fetchMore : function|null, // If not null, fetchMore allows you to load more results for your query. New data is merged with previous data. refetch : function, // Refetch the query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.13254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphQuery</em>",
        "sections": "<em>NerdGraphQuery</em>",
        "body": " containing all of the variables your <em>query</em> needs to execute. Methods <em>NerdGraphQuery.query</em> Static method to use <em>NerdGraphQuery</em> as a Promise instead of as a React <em>component</em>. function ( props : Object &#x2F;&#x2F; Object containing the <em>query</em> options. Any <em>NerdGraphQuery</em> prop is a valid option except children"
      },
      "id": "6091f8cee7b9d213095068a2"
    },
    {
      "sections": [
        "Drop data with drop filter rules",
        "Savings, security, speed",
        "Caution",
        "How drop filter rules work",
        "Cautions when dropping data",
        "Create drop filter rules",
        "Types of drop filter rules",
        "Drop log events",
        "Drop attributes",
        "Tip",
        "View or delete drop filter rules"
      ],
      "title": "Drop data with drop filter rules ",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "9590bd4593abd451633a4beacd94d56eb1a481bd",
      "image": "https://docs.newrelic.com/static/db4b077fafd911b9f5019b022b3048ab/b04e4/ingest-pipeline.png",
      "url": "https://docs.newrelic.com/docs/logs/log-management/ui-data/drop-data-drop-filter-rules/",
      "published_at": "2021-08-02T13:07:00Z",
      "updated_at": "2021-08-02T13:07:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After log event data has been shipped to New Relic, it can either be stored in our NRDB database or dropped (discarded). We can drop both log events and event attributes via drop filter rules. You can manage drop filter rules using our Logs UI, as explained in this document. You can also use NerdGraph. Savings, security, speed Drop filter rules help you accomplish several important goals: Lower costs by storing only logs relevant to your account. Protect privacy and security by removing personal identifiable information (PII). Reduce noise by removing irrelevant events and attributes. Caution Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, review the responsibilities and considerations for dropping data. How drop filter rules work A drop filter rule matches data based on a query. When triggered, the drop filter rule removes the matching data from the ingestion pipeline before it is written to NRDB. This creates an explicit demarcation between the logs being forwarded from your domain and the data that New Relic collects. Since the data removed by the drop filter rule doesn't reach our backend, it cannot be queried: the data is gone and cannot be restored. During the ingestion process, customer log data can be parsed, transformed, or dropped before being stored in New Relic's database. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic doesn't review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Any user with the relevant role-based access control permissions can view and edit all information in the rules you create. Create drop filter rules To create and edit drop filters, you must have admin permissions in New Relic, or you must be a member of a role with create and edit permissions for Logging Parsing Rules. Once a drop filter rule is active, it's applied to all log events ingested from that point onwards. Rules are not applied retroactively. Logs collected before creating a rule are not filtered by that rule. Filter or query the set of logs that contain the data you want to drop. Then, from Manage Data on the left nav of the Logs UI, click Create drop filter. To create a new drop filter rule, you can use new or existing log queries. Go to one.newrelic.com > Logs. Filter or query to the specific set of logs that contain the data to be dropped. Once the query is active, from Manage Data on the left nav of the Logs UI, click Create drop filter. Recommendation: Change the drop rule's default name to a meaningful name. Choose to either drop the entire log event that matches the query or just a specific subset of attributes in the matching events. Review the log partitions where this drop rule applies. Save the drop filter rule. Types of drop filter rules The drop filters UI prompts you to select whether to drop logs based on the query or on specific attributes. Drop log events The default type of drop filter rule is to drop logs. This option drops the entire log events that match the filter or query. When creating a rule, try to provide a specific query that only matches log data that should be dropped. Our drop filters process won't let you create drop filter rules without values in the matching query. This prevents badly formed rules from dropping all log data. Drop attributes You can specify attributes to be dropped in a log event that matches your query. At least one or more attributes must be selected. Any attribute which is selected will be dropped; all remaining attributes will be kept and stored in NRDB. Tip We recommend this method for removing fields that could contain personal identifiable information (PII) or other sensitive attributes without losing valuable monitoring data. View or delete drop filter rules To view or delete a drop filter rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Drop filters. Click the delete icon next to the drop filter rule you want to remove. Once deleted, rules no longer filter ingested log events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 373.03055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Drop</em> <em>data</em> with <em>drop</em> filter rules ",
        "sections": "<em>Drop</em> <em>data</em> with <em>drop</em> filter rules",
        "tags": "UI and <em>data</em>",
        "body": " <em>NerdGraph</em>. Savings, security, speed <em>Drop</em> filter rules help you accomplish several important goals: Lower costs by storing only logs relevant to your <em>account</em>. Protect privacy and security by removing personal identifiable information (PII). Reduce noise by removing irrelevant events and attributes. Caution"
      },
      "id": "603e813f28ccbc08c1eba787"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.77777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help organize and find your <em>data</em>",
        "sections": "<em>Transactions</em> per team",
        "body": " <em>app</em> or host. Near the entity’s name at the top of the page, select the See metadata and manage tags <em>menu</em>. In the <em>menu</em> that pops up, add or delete a tag. To manage tags via API: see our <em>NerdGraph</em> tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-08-03T06:47:30Z",
      "updated_at": "2021-07-27T11:27:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.79245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "sections": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "tags": "<em>NerdGraph</em>",
        "body": "&quot;: &quot;{ requestContext { userId apiKey } }&quot; } &#x27; Copy What can you do with <em>NerdGraph</em>? <em>NerdGraph</em> functionality can be broken <em>down</em> into two main categories: Querying New Relic <em>data</em>. You can fetch <em>data</em> for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One <em>app</em> for custom"
      },
      "id": "6043ff97196a67d0a0960f55"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-08-02T06:12:37Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.89548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.0609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> <em>access</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use Nerd<em>Storage</em> SDK <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of <em>data</em>, including users&#x27; configuration settings"
      },
      "id": "6091fa39e7b9d2e1425068b8"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.72809,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help organize and find your <em>data</em>",
        "sections": "Use tags to help organize and find your <em>data</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the software industry, a tag typically refers to a piece of metadata added to a <em>data</em> set for the purpose of improving <em>data</em> organization and findability. At <em>New</em> <em>Relic</em>, our tags are key:value pairs (like team: operations) added to various sets of <em>data</em>, like monitored <em>apps</em> and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.57166,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of the accounts you have <em>access</em> to. A workload can include: Any <em>New</em> <em>Relic</em>-monitored entity, including services, browser <em>apps</em>, mobile <em>apps</em>, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.89777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. <em>New</em> <em>Relic</em> <em>One</em>: a programmable platform We strive to have an automated user"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.58176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Create a <em>custom</em> <em>map</em> <em>view</em>",
        "body": " configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your <em>app</em> 30 min Add a table to your New Relic One <em>app</em> <em>Nerdpack</em> permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a <em>custom</em> <em>map</em> <em>view</em> 30 min Build an <em>app</em> to show <em>page</em> <em>view</em> data on a <em>map</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-08-02T05:41:36Z",
      "updated_at": "2021-08-02T05:41:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Find or register an Insert API key for your account: Go to: one.newrelic.com > account dropdown > Account settings > API keys, and select Insights API keys. Insert your API key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_API_KEY_HERE\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. The Insert API key authenticates you to use the Metric API. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors in the NrIntegrationError event in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. See Troubleshoot a NRIntegrationError event for more information. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.6636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&quot;: { &quot;host.name&quot;: &quot;dev.server.com&quot;, &quot;<em>app</em>.name&quot;: &quot;foo&quot; } } ] } ] Copy Required key-value pairs Each metric data point <em>map</em> in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-08-03T01:40:57Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin Before you begin, we recommend first reading about permissions. To start building, you must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.59271,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "body": " guides: Build a &quot;Hello, World!&quot; application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query"
      },
      "id": "6091fa3ae7b9d2e0595068b1"
    },
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-08-02T02:02:10Z",
      "updated_at": "2021-07-30T01:44:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.14859,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example of <em>custom</em> configuration",
        "body": " this to the above command: -e NR_EU_<em>REGION</em>=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add <em>custom</em> tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest"
      },
      "id": "6043a32364441fa554378eee"
    },
    {
      "sections": [
        "Tag your Nerdpack's release version",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Tag a version",
        "Important",
        "Untag a version",
        "Resolve issues with tagging a Nerdpack version",
        "Tip",
        "Unsubscribe from the Nerdpack"
      ],
      "title": "Tag your Nerdpack's release version",
      "type": "developer",
      "tags": [
        "nerdpack",
        "tag"
      ],
      "external_id": "28721c4ecc9f44a5634357fa16af417dc5e5c323",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/tag/",
      "published_at": "2021-08-03T01:49:22Z",
      "updated_at": "2021-05-21T01:42:22Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to tag your Nerdpack's release version",
      "body": "Tag your Nerdpack versions to track and subscribe to them. Untag versions to prevent subscriptions or hide Nerdpacks from the catalog. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To tag a Nerdpack version, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can tag them. Tag a version After you've published a Nerdpack version to the New Relic One catalog, you can tag it with the nr1 CLI. Step 1 of 2 In the root folder of your Nerdpack, run nr1 nerdpack:tag: bash Copy $ nr1 nerdpack:tag --tag=DEV ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as DEV. Here, you tagged version 1.0.0 as DEV. Now, you, and other users on your account, can use this tag: You see the tag as an option to subscribe to when you add the Nerdpack to your account If you subscribe to the DEV tag and it gets updated later—say, DEV is applied to version 1.0.1—you automatically get upgraded to the new version without having to subscribe again. Important One of the features of tagging release versions is that users who are subscribed to a tag automatically get updates when that tag is used for another version. This means that if a user is testing one version, say 1.0.0, and you apply that same tag to another version, say 1.0.1, that user will see version 1.0.1 in their account, and they can no longer access the Nerdpack they were testing before. Often times, this is the expected behavior, but make sure you consider this side effect when you use tags. Step 2 of 2 View your Nerdpack's registry information: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------- ---- 1.0.0 5 hours ago DEV This output confirms your DEV tag on version 1.0.0. Untag a version As you build more versions of your Nerdpack, you may update your tags to newer versions. However, you can also remove a tag from your Nerdpack with nr1. Step 1 of 3 From your Nerdpack's root directory, view your registry information: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------------- ---- 2.0.0 a few seconds ago DEV 1.0.1 8 minutes ago BETA, STABLE 1.0.0 6 hours ago Here, you see that version 1.0.0 has no tags, version 1.0.1 has two tags, BETA and STABLE, and version 2.0.0 has one tag, DEV. Step 2 of 3 Remove the BETA tag from your Nerdpack versions: bash Copy $ nr1 nerdpack:untag --tag=BETA ✔ Removed nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 tag BETA. Step 3 of 3 Verify that the tag was removed from your Nerdpack: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- -------------- ---- 2.0.0 5 minutes ago DEV 1.0.1 13 minutes ago STABLE 1.0.0 6 hours ago Resolve issues with tagging a Nerdpack version Sometimes, when you tag to a Nerdpack version, you may come across issues. Whether you can't tag your Nerdpack or you can't untag your Nerdpack, consider some common solutions for resolving these issues. Publish your Nerdpack If you try to tag your Nerdpack without first publishing it, you'll get an error: bash Copy $ nr1 nerdpack:tag --tag=DEV › Error: A downstream error occurred. This error message doesn't say much, but you can use the --verbose option to see more information: bash Copy $ nr1 nerdpack:tag --tag=DEV --verbose init version: @oclif/command@1.8.0 argv: [ '--tag=DEV', '--verbose', [length]: 2 ] dist/metadata.json does not exist. package.json will be used instead. Using profile account-1234567 Request: POST https://api.newrelic.com/graphql Data: mutation nerdpackTagVersion( nerdpackId: \"ab123c45-678d-9012-efg3-45hi6jkl7890\", versionTag: tag: \"DEV\", version: \"1.0.0\" } ) nerdpackId tags version } } Headers: 'API-Key': '<YOU USER KEY>', 'Content-Type': 'application/graphql' } This more verbose error message shows the GraphQL that runs behind the scenes for nr1 nerdpack:tag. The important part of the message here is: bash Copy dist/metadata.json does not exist. package.json will be used instead. The dist directory is created when you publish your app. So, because it hasn't been published yet, this directory doesn't exist and nr1 falls back to package.json to look for details about your Nerdpack. But, because the UUID in your package.json isn't in the New Relic registry, the command failed. So, before you tag your versions, publish them to the registry: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:tag --tag=DEV Tip Remember that you can also tag a version at the same time you deploy it! bash Copy $ nr1 nerdpack:publish --tag=DEV Unsubscribe from the Nerdpack You can only remove tags that have no subscribers. If you try to remove a tag that users are subscribed to, you'll get an error: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 2.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 3 Version Date Tags ------- ----------- ---- 2.0.0 an hour ago DEV 1.0.1 an hour ago 1.0.0 6 hours ago $ nr1 nerdpack:untag -t DEV › Error: A downstream error occurred. In this case, check to see if you're subscribed to the Nerdpack: bash Copy $ nr1 subscription:list Listing subscribed deployed nerdpacks on your account: Version UUID Name Date User ------- ------------------------------------ ----------------- ----------- ---------- 2.0.0 ab123c45-678d-9012-efg3-45hi6jkl7890 MyAwesomeNerdpack an hour ago 1000383529 This shows that you're subscribed to MyAwesomeNerdpack. Unsubscribe, then try to remove the DEV tag again: bash Copy $ nr1 nerdpack:unsubscribe Unsubscribed account 1234567 from the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the DEV channel. $ nr1 nerdpack:untag --tag=DEV ✔ Removed nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 tag DEV. $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 2.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 3 Version Date Tags ------- ----------- ---- 2.0.0 an hour ago 1.0.1 an hour ago 1.0.0 6 hours ago",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.14656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag your <em>Nerdpack&#x27;s</em> release version",
        "sections": "Tag your <em>Nerdpack&#x27;s</em> release version",
        "info": "Learn to tag your <em>Nerdpack&#x27;s</em> release version",
        "tags": "<em>nerdpack</em>",
        "body": " update your tags to newer versions. However, you can also remove a tag from your <em>Nerdpack</em> with nr1. Step 1 of 3 From your <em>Nerdpack</em>&#x27;s root directory, <em>view</em> your registry information: bash Copy $ nr1 <em>nerdpack</em>:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 <em>Region</em>: us Account ID: 1234567 Local version: 1.0.0"
      },
      "id": "609c868664441f30c62f36f5"
    }
  ],
  "/components/charts": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.73347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable advanced configurations for your <em>Nerdpack</em>",
        "sections": "Enable advanced configurations for your <em>Nerdpack</em>",
        "info": "Enable advanced configurations for your <em>Nerdpack</em>",
        "body": " configurations for your <em>Nerdpack</em>. Before you begin Make sure you have the latest version of the <em>nr1</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Extend your webpack configuration You can use our .extended-webpackrc.js <em>file</em> to extend your webpack 4 configuration. This allows you to add your own aliases, scripts"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    },
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.77374,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install and configure the New Relic One <em>CLI</em>",
        "sections": "Install and configure the New Relic One <em>CLI</em>",
        "info": "Install and configure the New Relic One <em>CLI</em>",
        "body": " profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ <em>nr1</em> profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One <em>CLI</em>! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a <em>Nerdpack</em>."
      },
      "id": "6091faf1196a6714b4d52a39"
    },
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.4763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Account access, deselect the account you want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you&#x27;ve built a New Relic One application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a <em>Nerdpack</em>"
      },
      "id": "6091fb4464441f42962f3737"
    },
    {
      "sections": [
        "Subscribe to a Nerdpack",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Tip",
        "Subscribe from the command line",
        "Technical detail",
        "Unsubscribe from a Nerdpack",
        "Unsubscribe using the command line",
        "Resolve issues with accessing your published Nerdpack",
        "Tag your Nerdpack version",
        "Subscribe with the web UI"
      ],
      "title": "Subscribe to a Nerdpack",
      "type": "developer",
      "tags": [
        "nerdpack",
        "subscribe"
      ],
      "external_id": "1e44b2ed6ab9788b17cd19ca10ae4b4cfd4c2fe1",
      "image": "https://developer.newrelic.com/static/157cec05491eea35b82fe9066d24f004/0086b/subscribe-to-account-maturity-app.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/subscribe/",
      "published_at": "2021-08-03T01:47:20Z",
      "updated_at": "2021-05-21T01:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to subscribe to a Nerdpack",
      "body": "Subscribe to a Nerdpack to use it in the New Relic platform. Unsubscribe from Nerdpacks you no longer use. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To subscribe to a Nerdpack, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can subscribe to them: Publish your Nerdpack Tag your Nerdpack if it's published and doesn't yet have a tag Subscribe to a Nerdpack Subscribe to a published Nerdpack, with either the web UI or the nr1 CLI, to use it in your account. Subscribing allows you to select the tagged version you want to use as well as the account you want to subscribe with. This lets you control what Nerdpacks you use in your account. Tip When the tag you've subscribed to gets an update, New Relic updates your Nerdpack automatically. Step 1 of 7 Go to New Relic: Step 2 of 7 Navigate to Apps: Step 3 of 7 Find your published Nerdpack under New Relic One catalog: All published Nerdpacks are shown in the New Relic One catalog. However, the one you're looking for maybe filtered out. Adjust the filter to find the Nerdpack you're looking for: Step 4 of 7 Select the Nerdpack you want to add to your New Relic account: Step 5 of 7 Click Add this app: This button says Manage access if you're already subscribed to the Nerdpack. Step 6 of 7 Select the account to subscribe with and the tagged version to subscribe to. Then, update your account(s): Tip In the web UI, and some places in the CLI, we refer to tags as channels. This is a relic of a past implementation of Nerdpack versioning. Ignoring historical and implementation details, consider them to be synonyms. Now you, and members of the accounts you've subscribed with, can launch the Nerdpack from New Relic. Step 7 of 7 If you subscribed to an app, find it under Your apps: If you subscribed to a visualization, find it under Custom visualizations: Subscribe from the command line If you've published your own Nerdpack, it may be quicker to subscribe to your Nerdpack with the nr1 CLI. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack For simplicity, this guide refers to your Nerdpack as my-awesome-nerdpack. Step 2 of 3 Ensure that your Nerdpack was published and tagged: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------------- ------ 1.0.0 a few seconds ago STABLE You should see at least one published version with a tag. It doesn't have to be STABLE. You can subscribe to any tagged version. Step 3 of 3 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe --channel=STABLE Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the STABLE channel Here, you've subscribed to the STABLE tag. You can also subscribe to DEV and BETA tags from the CLI, but the subscription command doesn't allow for arbitrary tags. To subscribe to any other tagged version, you need to use the web UI. Similar to the web UI, the term channel nr1 nerdpack:subscribe is a reference to an older implementation of Nerdpack versions. Technical detail nr1 nerdpack:subscribe is an alias for nr1 subscription:set. Read the nr1 subscription:set documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:set --help Unsubscribe from a Nerdpack Unsubscribe from a Nerdpack to remove it from your account. Step 1 of 5 Go to New Relic: Step 2 of 5 Navigate to Apps: Step 3 of 5 Click the \"i\" icon next to the Nerdpack you're subscribed to: This opens the detail page. Step 4 of 5 Click Manage access: Step 5 of 5 Deselect the accounts you want to unsubscribe with. Then, update those accounts: Unsubscribe using the command line Quickly unsubscribe your CLI profile from Nerdpacks. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack Step 2 of 3 View your profile's subscriptions: bash Copy $ nr1 subscription:list Listing subscribed deployed nerdpacks on your account: Version UUID Name Date User ------- ------------------------------------ ---------------- ----------- ------- 0.6.4 384de6e5-8e57-4d56-9d13-299ee7ae8641 Account Maturity a month ago 2774472 Step 3 of 3 Unsubscribe from the Nerdpack with the UUID: bash Copy $ nr1 nerdpack:unsubscribe --nerdpack-id=384de6e5-8e57-4d56-9d13-299ee7ae8641 Unsubscribed account 1234567 from the nerdpack 384de6e5-8e57-4d56-9d13-299ee7ae8641 on the STABLE channel. Tip nr1 nerdpack:unsubscribe is an alias for nr1 subscription:unset. Read the nr1 subscription:unset documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:unset --help Resolve issues with accessing your published Nerdpack Sometimes, when you subscribe to a Nerdpack, you may run into issues. Whether you can't subscribe or see duplicate subscriptions in your account, consider some common solutions for resolving these issues. Tag your Nerdpack version When you subscribe to an Nerdpack, you choose a specific tag. So, if the Nerdpack you're trying to subscribe to isn't tagged, or doesn't have the tag you're targeting, tag your release version: bash Copy $ nr1 nerdpack:subscribe --channel=DEV › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel DEV. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED $ nr1 nerdpack:tag --tag=DEV ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as DEV. $ nr1 nerdpack:subscribe --channel=DEV Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the DEV channel. If you subscribe without a --channel argument, the default channel is STABLE, so make sure you have a STABLE version in this case: bash Copy $ nr1 nerdpack:subscribe › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel STABLE. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED Subscribe with the web UI When you subscribe with the CLI, you pass a --channel argument to select a tag. A channel is, for all intents and purposes, a tag. This term is a relic of a past implementation of Nerdpack versioning. However, while the terms are synonymous, using --channel is limited in the CLI. When you subscribe with a --channel, you can only choose between DEV, BETA, and STABLE. So, to subscribe to a different tag, use the web UI: bash Copy $ nr1 nerdpack:subscribe --channel=QA › Error: Expected --channel=QA to be one of: DEV, BETA, STABLE › See more help with --help › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.15574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Subscribe to a <em>Nerdpack</em>",
        "sections": "Subscribe to a <em>Nerdpack</em>",
        "info": "Learn to subscribe to a <em>Nerdpack</em>",
        "tags": "<em>nerdpack</em>",
        "body": "Subscribe to a <em>Nerdpack</em> to use it in the New Relic platform. Unsubscribe from Nerdpacks you no longer use. Update your <em>CLI</em> Before you run any commands, ensure that you have the latest version of the <em>CLI</em>: bash Copy $ <em>nr1</em> update Check your permissions To subscribe to a <em>Nerdpack</em>, you need: Access"
      },
      "id": "609c8686196a67beaed52a2c"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.10959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "6091fa39196a67a4ead52a4b"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-08-03T01:43:03Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you’re looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 μs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is “loading” its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 376.99554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to use charts in your <em>NR1</em> app.",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "In your application, you can display data in charts, like those used elsewhere in New Relic&#x27;s user interface. The New Relic <em>One</em> SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply"
      },
      "id": "6091fb4428ccbc063ca268b7"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-08-03T01:43:03Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 351.46198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d<em>1</em>ef88dd0 version <em>1</em>.0.0 as STABLE. This means that your <em>Nerdpack</em> was published to the New Relic <em>One</em> <em>catalog</em> that you can find under Apps. Step 2 of 9 <em>Subscribe</em> to your <em>Nerdpack</em>: bash Copy $ <em>nr1</em> <em>nerdpack:subscribe</em> Subscribed account 3014918"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-08-03T01:40:59Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 351.23276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create your visualization Step <em>1</em> of 2 Ensure you&#x27;re working with the latest version of the New Relic <em>One</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 2 Create a visualization, called radar-or-treemap, in a <em>Nerdpack</em>, called alternate-viz: bash"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-08-03T01:41:57Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 348.41968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your <em>Nerdpack</em>, publish and <em>subscribe</em> to your visualization: bash Copy $ <em>nr1</em> <em>nerdpack</em>:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Customize your visualization with configuration options",
        "Course",
        "Tip",
        "Add a new configuration option",
        "Replace your SegmentedControl with the configurable property",
        "Summary"
      ],
      "title": "Customize your visualization with configuration options",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9028e58f383ea362d2c9d3a7ecd6404dbfeac87c",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/customize-visualizations-with-configuration/",
      "published_at": "2021-08-03T01:40:51Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization using configuration",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Custom visualizations and the New Relic One SDK, before starting this one. In the previous lesson, you built a custom visualization that shows queried data in one of two chart types: RadarChart Treemap You used a SegmentedControl to switch between the two chart types in the visualization UI. This implementation takes up space in the visualization, but it offers your users the choice to switch between two chart types even after you've created an instance of your chart. But what if you only need to be able to select an option once, when initializing the visualization? In this lesson you'll learn how to add a configuration option to your visualization which replaces the SegmentedControl. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Add a new configuration option Step 1 of 8 In your visualization's nr1.json file, add an enum configuration object for selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve If you're still serving your Nerdpack from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to nr1.json. Step 4 of 8 Go to https://one.newrelic.com/?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from the local server. Step 5 of 8 Open the Apps page: Step 6 of 8 Go to Custom Visualizations, which is favorited by default: Step 7 of 8 In Custom Visualizations, find and click your visualization: Step 8 of 8 Notice the new Select chart configuration option: Selecting a chart type doesn't effect your visualization. This is because you first need to introduce the selectedChart property to the visualization component. Then, you use selectedChart to determine the chart type to render. Replace your SegmentedControl with the configurable property Step 1 of 5 Open your visualization's index.js file. You'll be working here for the rest of the guide. Step 2 of 5 In render(), include selectedChart as a constant you get from destructuring props, and remove your component's state: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now that you're using selectedChart from the configuration options instead of component state, you can select a chart in the configuration panel and watch the visualization change. Unfortunately, there's a bug. The default chart option is Radar, but the initial render shows a Treemap. Step 3 of 5 Update your ternary expression to account for the case where there is no selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now, your data is rendered in a RadarChart if you haven't yet configured the option. Step 4 of 5 Remove SegmentedControl from render(): index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 Spinner, 18 } from 'nr1'; 19 20 const CHART_TYPES = { 21 'Radar': 'radar', 22 'Treemap': 'treemap' 23 } 24 25 export default class RadarOrTreemapVisualization extends React.Component { 26 // Custom props you wish to be configurable in the UI must also be defined in 27 // the nr1.json file for the visualization. See docs for more details. 28 static propTypes = { 29 /** 30 * A fill color to override the default fill color. This is an example of 31 * a custom chart configuration. 32 */ 33 fill: PropTypes.string, 34 35 /** 36 * A stroke color to override the default stroke color. This is an example of 37 * a custom chart configuration. 38 */ 39 stroke: PropTypes.string, 40 /** 41 * An array of objects consisting of a nrql `query` and `accountId`. 42 * This should be a standard prop for any NRQL based visualizations. 43 */ 44 nrqlQueries: PropTypes.arrayOf( 45 PropTypes.shape({ 46 accountId: PropTypes.number, 47 query: PropTypes.string, 48 }) 49 ), 50 }; 51 52 /** 53 * Restructure the data for a non-time-series, facet-based NRQL query into a 54 * form accepted by the Recharts library's RadarChart. 55 * (https://recharts.org/api/RadarChart). 56 */ 57 transformData = (rawData) => { 58 return rawData.map((entry) => ({ 59 name: entry.metadata.name, 60 // Only grabbing the first data value because this is not time-series data. 61 value: entry.data[0].y, 62 })); 63 }; 64 65 /** 66 * Format the given axis tick's numeric value into a string for display. 67 */ 68 formatTick = (value) => { 69 return value.toLocaleString(); 70 }; 71 72 render() { 73 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 74 75 const nrqlQueryPropsAvailable = 76 nrqlQueries && 77 nrqlQueries[0] && 78 nrqlQueries[0].accountId && 79 nrqlQueries[0].query; 80 81 if (!nrqlQueryPropsAvailable) { 82 return <EmptyState />; 83 } 84 85 return ( 86 <AutoSizer> 87 {({width, height}) => ( 88 <NrqlQuery 89 query={nrqlQueries[0].query} 90 accountId={parseInt(nrqlQueries[0].accountId)} 91 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 92 > 93 {({data, loading, error}) => { 94 if (loading) { 95 return <Spinner />; 96 } 97 98 if (error) { 99 return <ErrorState />; 100 } 101 102 const transformedData = this.transformData(data); 103 104 return ( 105 <React.Fragment> 106 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 107 <RadarChart 108 width={width} 109 height={height} 110 data={transformedData} 111 > 112 <PolarGrid /> 113 <PolarAngleAxis dataKey=\"name\" /> 114 <PolarRadiusAxis tickFormatter={this.formatTick} /> 115 <Radar 116 dataKey=\"value\" 117 stroke={stroke || '#51C9B7'} 118 fill={fill || '#51C9B7'} 119 fillOpacity={0.6} 120 /> 121 </RadarChart> 122 ) : ( 123 <Treemap 124 width={width} 125 height={height} 126 data={transformedData} 127 dataKey=\"value\" 128 ratio={4 / 3} 129 stroke={stroke || '#000000'} 130 fill={fill || '#51C9B7'} 131 /> 132 )} 133 </React.Fragment> 134 ); 135 }} 136 </NrqlQuery> 137 )} 138 </AutoSizer> 139 ); 140 } 141 } 142 143 const EmptyState = () => ( 144 <Card className=\"EmptyState\"> 145 <CardBody className=\"EmptyState-cardBody\"> 146 <HeadingText 147 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 148 type={HeadingText.TYPE.HEADING_3} 149 > 150 Please provide at least one NRQL query & account ID pair 151 </HeadingText> 152 <HeadingText 153 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 154 type={HeadingText.TYPE.HEADING_4} 155 > 156 An example NRQL query you can try is: 157 </HeadingText> 158 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 159 </CardBody> 160 </Card> 161 ); 162 163 const ErrorState = () => ( 164 <Card className=\"ErrorState\"> 165 <CardBody className=\"ErrorState-cardBody\"> 166 <HeadingText 167 className=\"ErrorState-headingText\" 168 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 169 type={HeadingText.TYPE.HEADING_3} 170 > 171 Oops! Something went wrong. 172 </HeadingText> 173 </CardBody> 174 </Card> 175 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 5 of 5 Serve your Nerdpack locally, and view it in the Custom Visualizations app in New Relic. Select a chart type from the dropdown in the configuration sidebar, and see your visualization update to show the matching chart type: Summary Congratulations on completing this lesson! You've learned how to customize your visualization using nr1.json configuration. Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Add custom visualizations to your dashboards.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 348.0978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>nerdpack</em>:serve If you&#x27;re still serving your <em>Nerdpack</em> from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to <em>nr1</em>.json. Step 4 of 8 Go to https:&#x2F;&#x2F;<em>one</em>.newrelic.com&#x2F;?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from"
      },
      "id": "6091fa3ae7b9d2df595068c1"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.76239,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add tags via UI or <em>API</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and labels that are defined in the cloud service. To add tags, you&#x27;d add them on the cloud-service-side. Automate tags with our <em>CLI</em> For a guide to automating tags using our <em>CLI</em> tool, see our <em>developer</em> site. Use tags to filter the UI Use the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:53:28Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.86911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a <em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use <em>CLI</em> commands to: Generate"
      },
      "id": "6091fa9864441feb412f36d4"
    },
    {
      "sections": [
        "Fluentd plugin for log forwarding",
        "Compatibility and requirements",
        "Enable Fluentd for New Relic log management",
        "Install the Fluentd plugin",
        "Install using fluent-gem install",
        "Install using td-agent-gem",
        "Configure the Fluentd plugin",
        "Tip",
        "Configure with the New Relic Insert API key (recommended)",
        "Configure with the New Relic license key",
        "Configure the Fluentd Plugin for EU accounts",
        "Add EU Endpoint to API key configuration",
        "Add EU Endpoint to License key configuration",
        "Test the Fluentd plugin",
        "View log data",
        "Tune-up log Fluentd buffer",
        "What's next?"
      ],
      "title": "Fluentd plugin for log forwarding",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "d1885aba09c8ad676b284acb140b46c33a191517",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/fluentd-plugin-log-forwarding/",
      "published_at": "2021-08-02T10:52:31Z",
      "updated_at": "2021-08-02T10:52:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a Fluentd output plugin to connect your Fluentd monitored log data to New Relic. Read on to learn how to enable this feature. Compatibility and requirements To forward logs to New Relic using Fluentd, ensure your configuration meets the following requirements: Insert API key (recommended) or New Relic license key Fluentd 1.0 or higher Enable Fluentd for New Relic log management To enable log management with Fluentd: Install the Fluentd plugin. Configure the Fluentd plugin. Optional: Configure EU Endpoint Test the Fluentd plugin. Generate some traffic and wait a few minutes, then check your account for data. Install the Fluentd plugin To install the Fluentd plugin: Install using fluent-gem install To install using fluent-gem install, enter the following command into your terminal or command line interface: fluent-gem install fluent-plugin-newrelic Copy Install using td-agent-gem To install using the td-agent plugin, enter the following command into your terminal or command line interface: td-agent-gem install fluent-plugin-newrelic Copy Configure the Fluentd plugin Tip If you're configuring Fluentd for the first time, you may find it helpful to review our collection of pre-built configuration files addressing common use cases. To configure your Fluentd plugin: In your fluent.conf file, or td-agent.conf if using the td-agent, add the following block of data, replacing the placeholder text with your Insert API key (recommended) or New Relic license key. Configure with the New Relic Insert API key (recommended) Configure with the New Relic Insert API key: #Tail one or more log files <source> @type tail <parse> @type none </parse> path /path/to/file tag example.service </source> #Add hostname and service_name to all events with \"example.service\" tag <filter example.service> @type record_transformer <record> service_name ${tag} hostname \"#{Socket.gethostname}\" </record> </filter> #Forward all events to New Relic <match **> @type newrelic api_key YOUR_API_INSERT_KEY </match> Copy Configure with the New Relic license key Configure with the New Relic license key: #Tail one or more log files <source> @type tail <parse> @type none </parse> path /path/to/file tag example.service </source> #Add hostname and service_name to all events with \"example.service\" tag <filter example.service> @type record_transformer <record> service_name ${tag} hostname \"#{Socket.gethostname}\" </record> </filter> #Forward all events to New Relic <match **> @type newrelic license_key YOUR_LICENSE_KEY </match> Copy Restart the Fluentd service to ensure your changes are applied. Configure the Fluentd Plugin for EU accounts By default the Fluentd plugin forwards logs to New Relic's US endpoint: https://log-api.newrelic.com/log/v1. If your account is on New Relic's EU datacenter then you will need to manually set the base_uri property to the EU endpoint. For example: Add EU Endpoint to API key configuration Configure EU endpoint with the New Relic Insert API key: #Tail one or more log files <source> @type tail <parse> @type none </parse> path /path/to/file tag example.service </source> #Add hostname and service_name to all events with \"example.service\" tag <filter example.service> @type record_transformer <record> service_name ${tag} hostname \"#{Socket.gethostname}\" </record> </filter> #Forward all events to New Relic EU Endpoint <match **> @type newrelic api_key YOUR_API_INSERT_KEY base_uri https://log-api.eu.newrelic.com/log/v1 </match> Copy Add EU Endpoint to License key configuration Configure EU Endpoint with the New Relic license key: #Tail one or more log files <source> @type tail <parse> @type none </parse> path /path/to/file tag example.service </source> #Add hostname and service_name to all events with \"example.service\" tag <filter example.service> @type record_transformer <record> service_name ${tag} hostname \"#{Socket.gethostname}\" </record> </filter> #Forward all events to New Relic EU Endpoint <match **> @type newrelic license_key YOUR_LICENSE_KEY base_uri https://log-api.eu.newrelic.com/log/v1 </match> Copy Test the Fluentd plugin To test if your Fluentd plugin is receiving input from a log file: Run the following command to append a test log message to your log file: echo \"test message\" >> /PATH/TO/YOUR/LOG/FILE Copy Search New Relic Logs UI for test message. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy Tune-up log Fluentd buffer By default, the plugin sends logs to New Relic One every 5 seconds. If you want to change this timing, add a <buffer> block to the configuration by following this example: [...] # Forward all events to New Relic EU Endpoint <match **> @type newrelic license_key YOUR_LICENSE_KEY <buffer time> timekey 60s </buffer> </match> Copy To read more about all the available configurations for buffers, check out the fluentd documentation about Buffer configurations. What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. If no data appears after you enable New Relic Logs, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.63333,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Configure with the <em>New</em> <em>Relic</em> Insert <em>API</em> <em>key</em> (recommended)",
        "tags": "Enable log management in <em>New</em> <em>Relic</em>",
        "body": ". Configure with the <em>New</em> <em>Relic</em> Insert <em>API</em> <em>key</em> (recommended) Configure with the <em>New</em> <em>Relic</em> Insert <em>API</em> <em>key</em>: #Tail <em>one</em> or more log files &lt;source&gt; @type tail &lt;parse&gt; @type none &lt;&#x2F;parse&gt; path &#x2F;path&#x2F;to&#x2F;file tag example.service &lt;&#x2F;source&gt; #Add hostname and service_name to all events with &quot;example.service&quot; tag &lt;filter"
      },
      "id": "603ec2d464441fb5ef4e8839"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-08-03T01:45:10Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"context\": { \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }] }, \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.97285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> command nr1 create and select Nerdpack to create a Nerdpack template that includes"
      },
      "id": "6091fa3928ccbc3197a268f1"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.72597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> <em>account</em> for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    }
  ],
  "/build-apps/custom-visualizations-and-the-new-relic-one-sdk": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 573.14087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-08-03T01:43:03Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 547.9797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build your first custom <em>visualization</em>",
        "sections": "Build your first custom <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>One</em> <em>catalog</em> Add your visualization to a dashboard Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create a new visualization Use <em>nr1</em> to generate the boilerplate for a new visualization"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-08-03T01:41:57Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 378.36966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your custom <em>visualization</em> to a dashboard",
        "sections": "Add your custom <em>visualization</em> to a dashboard",
        "info": "Add your custom <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your Nerdpack, publish and <em>subscribe</em> to your visualization: bash Copy $ <em>nr1</em> nerdpack:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Customize your visualization with configuration options",
        "Course",
        "Tip",
        "Add a new configuration option",
        "Replace your SegmentedControl with the configurable property",
        "Summary"
      ],
      "title": "Customize your visualization with configuration options",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9028e58f383ea362d2c9d3a7ecd6404dbfeac87c",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/customize-visualizations-with-configuration/",
      "published_at": "2021-08-03T01:40:51Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization using configuration",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Custom visualizations and the New Relic One SDK, before starting this one. In the previous lesson, you built a custom visualization that shows queried data in one of two chart types: RadarChart Treemap You used a SegmentedControl to switch between the two chart types in the visualization UI. This implementation takes up space in the visualization, but it offers your users the choice to switch between two chart types even after you've created an instance of your chart. But what if you only need to be able to select an option once, when initializing the visualization? In this lesson you'll learn how to add a configuration option to your visualization which replaces the SegmentedControl. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Add a new configuration option Step 1 of 8 In your visualization's nr1.json file, add an enum configuration object for selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve If you're still serving your Nerdpack from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to nr1.json. Step 4 of 8 Go to https://one.newrelic.com/?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from the local server. Step 5 of 8 Open the Apps page: Step 6 of 8 Go to Custom Visualizations, which is favorited by default: Step 7 of 8 In Custom Visualizations, find and click your visualization: Step 8 of 8 Notice the new Select chart configuration option: Selecting a chart type doesn't effect your visualization. This is because you first need to introduce the selectedChart property to the visualization component. Then, you use selectedChart to determine the chart type to render. Replace your SegmentedControl with the configurable property Step 1 of 5 Open your visualization's index.js file. You'll be working here for the rest of the guide. Step 2 of 5 In render(), include selectedChart as a constant you get from destructuring props, and remove your component's state: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now that you're using selectedChart from the configuration options instead of component state, you can select a chart in the configuration panel and watch the visualization change. Unfortunately, there's a bug. The default chart option is Radar, but the initial render shows a Treemap. Step 3 of 5 Update your ternary expression to account for the case where there is no selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now, your data is rendered in a RadarChart if you haven't yet configured the option. Step 4 of 5 Remove SegmentedControl from render(): index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 Spinner, 18 } from 'nr1'; 19 20 const CHART_TYPES = { 21 'Radar': 'radar', 22 'Treemap': 'treemap' 23 } 24 25 export default class RadarOrTreemapVisualization extends React.Component { 26 // Custom props you wish to be configurable in the UI must also be defined in 27 // the nr1.json file for the visualization. See docs for more details. 28 static propTypes = { 29 /** 30 * A fill color to override the default fill color. This is an example of 31 * a custom chart configuration. 32 */ 33 fill: PropTypes.string, 34 35 /** 36 * A stroke color to override the default stroke color. This is an example of 37 * a custom chart configuration. 38 */ 39 stroke: PropTypes.string, 40 /** 41 * An array of objects consisting of a nrql `query` and `accountId`. 42 * This should be a standard prop for any NRQL based visualizations. 43 */ 44 nrqlQueries: PropTypes.arrayOf( 45 PropTypes.shape({ 46 accountId: PropTypes.number, 47 query: PropTypes.string, 48 }) 49 ), 50 }; 51 52 /** 53 * Restructure the data for a non-time-series, facet-based NRQL query into a 54 * form accepted by the Recharts library's RadarChart. 55 * (https://recharts.org/api/RadarChart). 56 */ 57 transformData = (rawData) => { 58 return rawData.map((entry) => ({ 59 name: entry.metadata.name, 60 // Only grabbing the first data value because this is not time-series data. 61 value: entry.data[0].y, 62 })); 63 }; 64 65 /** 66 * Format the given axis tick's numeric value into a string for display. 67 */ 68 formatTick = (value) => { 69 return value.toLocaleString(); 70 }; 71 72 render() { 73 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 74 75 const nrqlQueryPropsAvailable = 76 nrqlQueries && 77 nrqlQueries[0] && 78 nrqlQueries[0].accountId && 79 nrqlQueries[0].query; 80 81 if (!nrqlQueryPropsAvailable) { 82 return <EmptyState />; 83 } 84 85 return ( 86 <AutoSizer> 87 {({width, height}) => ( 88 <NrqlQuery 89 query={nrqlQueries[0].query} 90 accountId={parseInt(nrqlQueries[0].accountId)} 91 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 92 > 93 {({data, loading, error}) => { 94 if (loading) { 95 return <Spinner />; 96 } 97 98 if (error) { 99 return <ErrorState />; 100 } 101 102 const transformedData = this.transformData(data); 103 104 return ( 105 <React.Fragment> 106 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 107 <RadarChart 108 width={width} 109 height={height} 110 data={transformedData} 111 > 112 <PolarGrid /> 113 <PolarAngleAxis dataKey=\"name\" /> 114 <PolarRadiusAxis tickFormatter={this.formatTick} /> 115 <Radar 116 dataKey=\"value\" 117 stroke={stroke || '#51C9B7'} 118 fill={fill || '#51C9B7'} 119 fillOpacity={0.6} 120 /> 121 </RadarChart> 122 ) : ( 123 <Treemap 124 width={width} 125 height={height} 126 data={transformedData} 127 dataKey=\"value\" 128 ratio={4 / 3} 129 stroke={stroke || '#000000'} 130 fill={fill || '#51C9B7'} 131 /> 132 )} 133 </React.Fragment> 134 ); 135 }} 136 </NrqlQuery> 137 )} 138 </AutoSizer> 139 ); 140 } 141 } 142 143 const EmptyState = () => ( 144 <Card className=\"EmptyState\"> 145 <CardBody className=\"EmptyState-cardBody\"> 146 <HeadingText 147 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 148 type={HeadingText.TYPE.HEADING_3} 149 > 150 Please provide at least one NRQL query & account ID pair 151 </HeadingText> 152 <HeadingText 153 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 154 type={HeadingText.TYPE.HEADING_4} 155 > 156 An example NRQL query you can try is: 157 </HeadingText> 158 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 159 </CardBody> 160 </Card> 161 ); 162 163 const ErrorState = () => ( 164 <Card className=\"ErrorState\"> 165 <CardBody className=\"ErrorState-cardBody\"> 166 <HeadingText 167 className=\"ErrorState-headingText\" 168 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 169 type={HeadingText.TYPE.HEADING_3} 170 > 171 Oops! Something went wrong. 172 </HeadingText> 173 </CardBody> 174 </Card> 175 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 5 of 5 Serve your Nerdpack locally, and view it in the Custom Visualizations app in New Relic. Select a chart type from the dropdown in the configuration sidebar, and see your visualization update to show the matching chart type: Summary Congratulations on completing this lesson! You've learned how to customize your visualization using nr1.json configuration. Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Add custom visualizations to your dashboards.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 378.0608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with configuration options",
        "sections": "Customize your <em>visualization</em> with configuration options",
        "info": "Customize your <em>visualization</em> using configuration",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": "&quot;: &quot;Stroke color&quot;, 51 &quot;description&quot;: &quot;A stroke color to override the default stroke color&quot;, 52 &quot;type&quot;: &quot;string&quot; 53 } 54 ] 55 } <em>visualizations</em>&#x2F;radar-or-treemap&#x2F;<em>nr1</em>.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ <em>nr1</em>"
      },
      "id": "6091fa3ae7b9d2df595068c1"
    },
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.35226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "info": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " serving it locally! Tip If you don&#x27;t see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application"
      },
      "id": "6091fb4464441f42962f3737"
    }
  ],
  "/build-apps/customize-visualizations-with-configuration": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 533.66565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-08-03T01:41:57Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 444.864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your custom <em>visualization</em> to a dashboard",
        "sections": "Add your custom <em>visualization</em> to a dashboard",
        "info": "Add your custom <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ <em>nr1</em> nerdpack:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-08-03T01:43:03Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.81927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build your first custom <em>visualization</em>",
        "sections": "Build your first custom <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>One</em> <em>catalog</em> Add your visualization to a dashboard Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create a new visualization Use <em>nr1</em> to generate the boilerplate for a new visualization"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-08-03T01:40:59Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.6973,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with SDK components",
        "sections": "Customize your <em>visualization</em> with SDK components",
        "info": "Customize your <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create your visualization Step <em>1</em> of 2 Ensure you&#x27;re working with the latest version of the New Relic <em>One</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 283.59103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Most of the time, the <em>nr1</em> <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, Nerdlets, launchers, and <em>visualizations</em> without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    }
  ],
  "/build-apps/ab-test/third-party-service": [
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 722.43854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> PlatformStateContext to your Nerdlet",
        "sections": "<em>Add</em> PlatformStateContext to your Nerdlet",
        "info": "<em>Add</em> PlatformStateContext to your Nerdlet",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Fetch</em> <em>data</em> <em>from</em> a <em>third</em>"
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-08-03T01:49:52Z",
      "title": "Access NerdStorageVault from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "d35788d1b5e58689f48c12aa4cbdc2f446550102",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorageVault from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.16922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Access</em> NerdStorageVault <em>from</em> your Nerdlet",
        "sections": "<em>Access</em> NerdStorageVault <em>from</em> your Nerdlet",
        "info": "<em>Access</em> NerdStorageVault <em>from</em> your Nerdlet",
        "body": " is to show you how your software is helping you meet your business objectives. Sometimes, New Relic <em>data</em> is all you need to make that happen, but other times you need to look beyond New Relic for <em>data</em> to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Fetch</em> <em>data</em> <em>from</em> a <em>third</em>-<em>party</em> <em>service</em>."
      },
      "id": "6091faf264441f1cbe2f36e1"
    },
    {
      "sections": [
        "Introduction to on-host integrations",
        "Get started",
        "Features",
        "Monitor remote and multi-tenant configurations"
      ],
      "title": "Introduction to on-host integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "Get started"
      ],
      "external_id": "0e84cd158def0d2b748d2a54a0716f9820691f0d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/get-started/introduction-host-integrations/",
      "published_at": "2021-08-02T11:40:01Z",
      "updated_at": "2021-07-27T16:14:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure integrations allow you to send data from popular products and services to New Relic. You can select from our list of available on-host integrations to collect and send data to our platform. Get started To get started with on-host integrations: Browse the lists of on-host integrations. If you do not already have New Relic infrastructure monitoring enabled, install the infrastructure agent. Follow the procedures to install and configure the selected on-host integration, including prerequisites for compatibility and other requirements. If we don't currently offer an integration for a service you use, consider creating your own integration with Flex. Features After you install and activate an integration, you will be able to: Filter and analyze the metrics and configuration data in Infrastructure UI. Create custom queries and charts of your integration data. Create alert conditions to monitor problems with your services' performance in New Relic's alerts. Monitor remote and multi-tenant configurations Some configurations may use third party elements, such as databases, which reside in non-accessible, remote hosts. Our integrations can fetch data from local and remote hosts or servers, ensuring a continuous monitoring of your service. They also support multi-tenant clustered configurations—by abstracting the service from the host, multiple entities can be monitored as remote instances. You can activate remote monitoring and multi-tenancy in the Apache, Cassandra, MySQL, NGINX, and Redis integrations with the remote_monitoring parameter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.65349,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Monitor remote <em>and</em> multi-tenant configurations",
        "body": " alert conditions to monitor problems with your services&#x27; performance in New Relic&#x27;s alerts. Monitor remote and multi-tenant configurations Some configurations may use <em>third</em> <em>party</em> elements, such as databases, which reside in non-accessible, remote hosts. Our integrations can <em>fetch</em> <em>data</em> <em>from</em> local"
      },
      "id": "6044e41ce7b9d2ad305799ef"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-08-02T06:12:37Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.449135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "sections": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "body": "NerdGraph allows you to access your New Relic <em>data</em>, but when you want to <em>fetch</em> <em>third</em>-<em>party</em> <em>data</em>, NerdStorageVault allows you to safely store a secret to authenticate with a <em>third</em>-<em>party</em> <em>service</em>. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terms/",
      "sections": [
        "Terms and conditions"
      ],
      "published_at": "2021-08-02T10:57:00Z",
      "title": "Terms and conditions",
      "updated_at": "2021-08-02T10:57:00Z",
      "type": "developer",
      "external_id": "5c260dc18b9f68a28114875ddc900a8935479040",
      "document_type": "page",
      "popularity": 1,
      "info": "Developer terms and conditions",
      "body": "New Relic Developer Terms Welcome to New Relic's developer program (\"Developer Program\")! We are excited that you're here. Our intent is to maintain a vibrant software development community. We require that all users that develop on the New Relic platform adhere to these terms. These terms (\"Terms\") apply to participation in the Developer Program and form a legal agreement between you (\"you\" or \"Developer\") and New Relic, Inc. (\"New Relic\", \"we\", \"our\" or \"us\"), so please read them carefully. If you are entering into these Terms on behalf of a company, organization or another legal entity, then \"you\" or \"Developer\" means that entity, and you represent and warrant that you have the authority to bind that entity to these Terms. Please ensure you have that authority, since otherwise you may not accept these Terms or use the Developer Resources. New Relic may modify these Terms from time to time, subject to Section 19 (Changes to Terms) below. By clicking \"I agree\" (or a similar button) or by accessing or using the Developer Resources, you agree to be bound by these Terms. Introduction. Our Developer Resources help you build apps, add-ons and features that extend, augment or complement the New Relic Service (\"Apps\"). The \"Developer Resources\" are the APIs, SDKs, sample code, Developer Accounts, command line interfaces, tokens, credentials and other resources we provide as part of the Developer Program, as described on the Developer Site. The \"New Relic Service\" is our SaaS offering and related software, which we provide under separate terms (\"New Relic Terms of Service\"). How These Terms Apply. These Terms apply if you use our Developer Resources to build or manage Apps. Any use of the New Relic Service itself (including our standard tools and APIs that help you configure usage or retrieve your data) remains subject to the New Relic Terms of Service, not these Terms. Registration. To access or use the Developer Resources, you need to complete any registration or credentialing requirements established by New Relic. Use of Developer Resources. Subject to these Terms, you may use the Developer Resources to enable your Apps to interface with the New Relic Service. Your use is subject to the developer documentation currently available on the Developer Site or otherwise provided by New Relic (\"Developer Documentation\"), which is considered part of the Developer Resources. Your rights are limited, non-exclusive, non-sublicensable and non-transferable. You may permit your agents and contractors to exercise your rights on your behalf, provided you remain responsible for their compliance with these Terms. Developer Account. New Relic may offer test or sandbox accounts as part of the Developer Program (\"Developer Accounts\"), which you may use only for internal development or testing of your Apps as part of your rights in Section 4 (Use of Developer Resources). Because Developer Accounts are for development or testing purposes only, you may not use personally identifiable or production data with Developer Accounts (and no End User Data). New Relic has no security, privacy or other responsibility for data contained in Developer Accounts and may access, modify or delete such data at any time for any reason. You may not provide access to your Developer Accounts to anyone else. Developer Accounts may be subject to additional usage restrictions as set forth from time to time in the Developer Documentation. Access Limits; Compliance. New Relic may (but is not required to) monitor your use of the Developer Resources and how your Apps interact with the New Relic Service, including to ensure your compliance with these Terms. You agree to cooperate with our reasonable inquiries and, upon request, provide us with proof that your use of the Developer Resources and your Apps comply with these Terms. From time to time New Relic may also place limits on access (e.g., limits on number of API calls). Restrictions. We expect all developers to respect New Relic, end users and other third parties. In using the Developer Resources, you must comply with New Relic's Acceptable Use Policy currently available here (\"Acceptable Use Policy\"). You will not (and will not permit anyone else to): (a) use the Developer Resources except with the New Relic Service as permitted in these Terms; (b) sublicense, sell, distribute or grant third parties access to the Developer Resources, other than your agents and contractors (see Section 4) or as permitted in the Developer Documentation (e.g., distributable elements of SDKs); (c) use the Developer Resources for competitive purposes, with Apps that substantially replicate features of the New Relic Service or to circumvent any intended limitations of the New Relic Service (e.g., payment of fees or user access structures); (d) reverse engineer, modify or create derivative works of the Developer Resources; (e) access the Developer Resources through means other than the tokens and credentials we provide; (f) make calls using an App not driven by bona fide end user requests (except for reasonable testing); (g) publish benchmarks or performance information regarding the Developer Resources; (h) test the performance, bandwidth or capacity of the Developer Resources or New Relic Service or disrupt their integrity or performance; (i) transmit any viruses, illegal content or other harmful materials to the Developer Resources or New Relic end users; or (j) take any action that would subject the Developer Resources or New Relic Service to any open source licenses or other third party terms. Use of New Relic Marks. Subject to these Terms, you may use the appropriate New Relic names, logos and trademarks designated in the New Relic Trademark Guidelines currently available here (\"New Relic Marks\") to promote your App's availability for use with the New Relic Service. Your use of New Relic Marks must comply with the New Relic Trademark Guidelines and (without limiting New Relic's other termination rights) you must promptly cease any use of New Relic Marks upon notice by New Relic. You receive no other rights to New Relic Marks under these Terms. All goodwill arising from use of New Relic Marks belongs to New Relic. Your Responsibilities. You and your Apps must meet important standards related to privacy, security, business practices and user experience, as set out below. a. Your Apps and End Users. You are solely responsible, at your own expense, for your Apps (including their operation, components, integrations and support) and your relationships and agreements with end users regarding your Apps. b. Support. You will provide end users with reasonable web-based and/or email support for your Apps. You will also provide New Relic with a current email address to which New Relic may direct end user inquiries about your Apps and designate a support contact (name and email address) for New Relic. c. End User Data. An end user may enable you or your App to access certain of its data, content or information within the New Relic Service (\"End User Data\"). You may access and process End User Data only to the extent enabled by the end user and as necessary to provide your Apps to that end user. You will ensure that all End User Data is collected, processed, transmitted, maintained and used in accordance with: (i) your agreement with the end user and a legally adequate privacy policy (\"End User Terms\"), and appropriate notices to and consents from end users, (ii) all laws, rules, regulations or orders, including those relating to data privacy, data transfer, international communications or the export of technical or personal data (\"Laws\") and (iii) industry-standard technical, administrative and physical security measures that protect the security and privacy of all End User Data. New Relic is not responsible for any regulatory action or claim to which you may be subject in connection with your Apps. New Relic is also not responsible for any transmission, disclosure, modification or deletion of End User Data in the New Relic Service by, through or resulting from an App. d. Security Breaches. In case of any suspected or actual security breach affecting your App or End User Data, you must immediately notify New Relic and cooperate with New Relic to remediate the issue and mitigate its effects. You must obtain New Relic's approval for any security breach notifications to end users that refer directly or indirectly to New Relic. e. New Relic Customer Terms. Use of the New Relic Service requires each end user to have a valid subscription subject to the New Relic Terms of Service. You will not facilitate or encourage any end user to violate the New Relic Terms of Service or Acceptable Use Policy. For clarity, if New Relic receives any data from you or your Apps on an end user's behalf, such data will be subject solely to the New Relic Terms of Service with the end user, and such data will no longer be subject to your own terms with the end user. f. Fees. You may not directly or indirectly charge end users for use of, or access to, the functionality of the Developer Resources. If you charge any fees for your Apps, you are solely responsible for collecting those fees independently from New Relic and the New Relic Catalog. You are also responsible for any related refunds or liabilities to end users and for any associated end user communications under Section 13.d (End User Communications). These Terms grant you no right to distribute or resell the Developer Resources or New Relic Service. g. Your Representations and Warranties. You represent and warrant that: (i) you have full power and authority to enter into and perform these Terms and to exploit your Apps without violating any other agreement; (ii) your Apps and their use will not violate any Laws or third party rights (including intellectual property rights, and rights of privacy or publicity), and you will notify New Relic if your Apps become subject to any claim or complaint regarding violation of Laws or third party rights; (iii) all information you provide to New Relic is and will be true, accurate and complete (and you will keep such information up-to-date); and (iv) you will not interfere with New Relic's business practices or the way in which it licenses or distributes the Developer Resources or New Relic Service. You agree not to: (A) suggest any affiliation with New Relic (including that New Relic sponsors, endorses or guarantees your Apps) except for the relationship expressly contemplated in these Terms or (B) make any representations, warranties or commitments on New Relic's behalf or regarding the Developer Resources or New Relic Service. h. Indemnification. You will indemnify, defend (at New Relic's request) and hold harmless New Relic and its affiliates and their respective directors, officers, employees, agents, contractors, end users and licensees from and against any regulatory actions, claims, losses, costs, expenses (including reasonable attorneys' fees), damages or liabilities based on or arising from (i) your Apps, (ii) your relationships or interactions with any end users or third parties in connection with your Apps, or (iii) your breach or alleged breach of these Terms. New Relic may, at its own expense, participate in the defense and settlement of any claim with its own counsel, and you may not settle a claim without New Relic's prior written consent (not to be unreasonably withheld). Listings. This Section 10 applies only if you choose to submit your App for listing in the New Relic Catalog. a. Submission. To submit your App for potential listing in the New Relic Catalog, you must follow New Relic's Listing Requirements and provide: i. Your App meeting the Listing Requirements, including regarding security and coding practices, ii. Listing information, trademarks and documentation (\"Listing Materials\"), iii. End User Terms for your App, and iv. Other related materials that we reasonably request. b. Approval. New Relic may approve or reject any submitted App in its sole discretion and reserves the right to test Apps against the Listing Requirements and other security and performance criteria. You remain solely responsible for your Apps despite any New Relic approval. c. New Relic Rights. If New Relic approves your submitted App, you hereby grant New Relic a license to: i. List your App in the New Relic Catalog; ii. Copy, distribute, publicly perform and display, and create derivative works of your Listing Materials, and screenshots of your App's use with the New Relic Service, in order to market and promote your App, the New Relic Catalog and the New Relic Service (but we will not change your trademarks except for sizing and formatting); and iii. Use, host, copy, distribute, publicly perform and display your App to permit your App to operate with the New Relic Service, including by permitting End Users to enable and deploy your App with their New Relic Service accounts. New Relic's license rights are worldwide, non-exclusive, royalty-free and fully paid-up and sublicensable through multiple tiers. New Relic retains sole discretion and control over the placement, look and feel of the New Relic Catalog. d. End User Deployment. If New Relic lists your App on the New Relic Catalog, interested end users may select and deploy your App with their New Relic Service accounts. New Relic does not guarantee any end users will search for or use your App. e. End User Terms. You are responsible for your End User Terms and how you present them to end users and obtain their agreement. Your End User Terms must be consistent with your rights and obligations in these Terms (including regarding End User Data and any termination, suspension or take-down of your App), and you agree your App will not be licensed under a Copyleft License. New Relic is not a party to your End User Terms and is not responsible for how end users use your App or for enforcing your End User Terms. \"Copyleft License\" means any OSS license that seeks to require any party that uses, modifies or distributes the licensed code to make such code (or modification or derivative work thereof) or any other code that may be combined with or linked to such code available in source code form or that may impose any other obligation or restriction with respect to such party's patent or other intellectual property rights (such as, for example purposes only, any version of the GPL or LGPL, Affero, CPL, CDDL, Eclipse or Mozilla licenses). f. Take-Downs. You may request that we take-down your App from the New Relic Catalog at any time by contacting opensource+nr1-catalog@newrelic.com. We will use commercially reasonable efforts to promptly remove your App from the New Relic Catalog following receipt of your request. In addition to its other rights, New Relic may temporarily or permanently take-down any App listed in the New Relic Catalog in its discretion, without notice to you. Section 13.c (Wind-Down) will apply following any take-down pursuant to this Section 10.f. g. New Relic Catalog. \"New Relic Catalog\" means (i) the New Relic One Catalog that New Relic makes available in connection with the New Relic Service and (ii) any other App listing or catalog that New Relic makes available through its own or third party products or websites. Ownership. New Relic does not claim ownership of your Apps (other than our own technology) and you reserve all rights not expressly granted in these Terms. New Relic and its licensors retain all ownership and other rights (including all intellectual property rights) in the Developer Resources, the New Relic Service and our related technology. Providing feedback, comments, or suggestions about the Developer Program or Developer Resources (\"Feedback\") to New Relic is wholly voluntary. New Relic may freely use Feedback for any purpose. Support; Changes. New Relic has no obligation to provide maintenance or support for the Developer Resources or your Apps, or to fix any errors or defects. New Relic may change the Developer Resources from time to time as our business changes and technology evolves, and future versions of the Developer Resources may not be compatible with Apps built using previous versions. We typically make these changes as part our overall Developer Program and are unable to provide notice of the changes to developers individually. New Relic will have no liability resulting from these changes. Termination and Suspension. These Terms remain in effect until terminated. a. By Developer. Developer may terminate these Terms at any time by ceasing all use of the Developer Resources. b. By New Relic. New Relic may terminate or suspend these Terms or your access to or right to use the Developer Resources (in whole or in part): (i) for no reason or any reason upon 15 days' notice to you, (ii) immediately (A) if you breach any provision of these Terms, (B) if New Relic is required to do so by Laws, (C) if New Relic ceases offering the Developer Resources, (D) in case of any security breach or other concern under Section 9.d (Security Breaches), or (E) if New Relic otherwise determines in its discretion that such action is necessary to avoid harm, liability or reputational damage to New Relic, the Developer Resources, the New Relic Service, or any end user. For clarity, suspension may include disabling your Apps. c. Wind-Down. Following any termination of these Terms, at New Relic's request (i) the parties will cooperate to effectuate an orderly wind-down and (ii) these Terms will continue in effect for up to 90 days to enable deployed end users to continue using your Apps. d. End User Communications. In the event of any termination, suspension or take-down under this Section 13 or Section 10.f (Take-Downs), Developer remains responsible for managing its own end user relationships and communications, including as relates to any transition to alternate Developer offerings or any impact on fees, refunds or commercial terms with end users. Developer will ensure that any such end user communications are accurate and conducted in a positive and professional manner, consistent with any guidelines New Relic may provide. e. Effect of Termination. Upon any termination, subject to Section 13.c (Wind-Down) (i) your rights to use the Developer Resources and New Relic Marks will immediately terminate and you will cease all such use, (ii) you will return or destroy all Confidential Information (as requested by New Relic) and (iii) Sections 9 (Your Responsibilities), 11 (Ownership) and 13 (Termination and Suspension) through 24 (General) will survive. After termination, you will have no further access to any data or content that you submitted to New Relic relating to the Developer Resources. f. No Obligation or Liability. New Relic will have no obligation or liability resulting from termination, suspension or take-down as described in this Section 13 or Section 10.f (Take-Downs). Disclaimer of Warranties. TO THE FULL EXTENT PERMITTED BY LAW, THE DEVELOPER RESOURCES ARE PROVIDED \"AS IS\" AND \"WITH ALL FAULTS\" AND NEW RELIC AND ITS THIRD-PARTY LICENSORS DISCLAIM ALL REPRESENTATIONS, WARRANTIES AND GUARANTEES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR ANY PURPOSE. NEW RELIC MAKES NO REPRESENTATION, WARRANTY OR GUARANTEE RELATED TO RELIABILITY, ACCURACY OR COMPLETENESS OF THE DEVELOPER RESOURCES, THAT NEW RELIC WILL CONTINUE TO OFFER THE DEVELOPER RESOURCES OR THAT USE OF THE DEVELOPER RESOURCES WILL BE SECURE, TIMELY, UNINTERRUPTED, ERROR-FREE OR MEET DEVELOPER'S REQUIREMENTS OR EXPECTATIONS. You may have other statutory rights, in which case the disclaimers above will apply to the full extent permitted by law. Limitations of Liability. TO THE FULL EXTENT PERMITTED BY LAW, IN NO EVENT WILL NEW RELIC BE LIABLE (i) FOR ANY LOSS OF USE, LOST DATA, FAILURE OF SECURITY MECHANISMS, INTERRUPTION OF BUSINESS OR ANY INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND (INCLUDING LOST PROFITS OR LOST DATA), EVEN IF INFORMED OF THE POSSIBILITY OF SUCH DAMAGES IN ADVANCE OR (ii) IN ANY EVENT, FOR ANY DAMAGES OR LIABILITIES EXCEEDING ONE HUNDRED U.S. DOLLARS (\\$100), ARISING FROM OR RELATING TO THESE TERMS, USE OF THE DEVELOPER RESOURCES, YOUR APPS OR THEIR COMBINATION OR INTERACTION WITH THE DEVELOPER RESOURCES OR NEW RELIC SERVICE. NOTWITHSTANDING ANYTHING TO THE CONTRARY, NEW RELIC HAS NO WARRANTY, INDEMNIFICATION OR OTHER OBLIGATION OR LIABILITY WITH RESPECT TO YOUR APPS OR THEIR COMBINATION, INTERACTION OR USE WITH THE DEVELOPER RESOURCES OR NEW RELIC SERVICE. You acknowledge and agree that this Section 15 reflects a reasonable allocation of risk and will apply regardless of the form of action or legal theory, whether in contract, tort (including negligence), strict liability or otherwise, and that New Relic would not enter into these Terms without these liability limitations. This Section will survive even if any limited remedy fails of its essential purpose. New Relic Confidential Information. Any non-public elements of the Developer Resources and any other information disclosed by New Relic that is marked as confidential or proprietary or that should reasonably be understood to be confidential or proprietary from the circumstances of disclosure is \"Confidential Information.\" Confidential Information does not include any information that: (i) is or becomes generally known to the public; (ii) was known to you before its disclosure by New Relic; or (iii) is received from a third party, in each case without breach of an obligation owed to New Relic or anyone else. You will (A) maintain Confidential Information in confidence (using at least the same measures as for your own confidential information, and no less than reasonable care) and not divulge it to any third party and (B) only use Confidential Information to fulfill your obligations under these Terms. If you are compelled by law to disclose Confidential Information, you must provide New Relic with prior notice of such compelled disclosure (to the extent legally permitted) and reasonable assistance if New Relic wishes to contest the disclosure. If you breach or threaten breach of this Section 16, it could cause substantial harm for which damages are inadequate and New Relic will have the right to seek injunctive relief in addition to other remedies. Independent Development; Information You Provide Not Confidential. New Relic develops a variety of offerings and works with many other developers and partners, and either New Relic or these third parties could in the future develop (or already have developed) products, services, concepts or features similar to yours. Nothing limits New Relic's right to do so, though this Section itself does not grant us any license under your intellectual property rights. Unless separately set forth in another agreement, New Relic has no confidentiality obligations for information you submit in connection with the Developer Program. Usage Data. In addition to New Relic's other rights, New Relic may collect certain data and information regarding your use of the Developer Site and Developer Resources, including data about your data pulls or requests, and your Apps (\"Usage Data\"). We may use and exploit Usage Data for any purpose in connection with operating, improving and supporting the Developer Program and Developer Resources. Changes to Terms. We may change these Terms from time to time as our business changes and technology evolves. New Relic will use reasonable efforts to notify you of changes to these Terms as provided in Section 22 (Notices). You may be required to click through the modified Terms to show your acceptance and in any event your continued use of the Developer Resources after the modification constitutes your acceptance to the modifications. If you do not agree to the modified Terms, your sole remedy is to terminate your use of the Developer Resources as described in Section 13 (Termination and Suspension). Open Source Software. Certain code in the Developer Resources (e.g., SDKs) may be licensed under or include components subject to \"open source\" software terms (\"OSS\"), as listed in the Developer Documentation. The OSS licenses may grant you additional rights to the OSS code itself and allow you to use the OSS outside of our Developer Program. To be clear, though, when you use the OSS as part of our Developer Program, you must comply with these Terms. Pre-Release Versions. New Relic may make available certain Developer Resources on a pre-release or early access basis (\"Pre-Release Versions\"). Use of Pre-Release Versions may be subject to additional terms designated by New Relic. Pre-Release Versions are optional and either party may terminate use at any time for any reason. If you choose to use a Pre-Release Version, you agree to provide Feedback at our reasonable request. Pre-Release Versions may be inoperable, incomplete or include features that New Relic may never release, and their features and performance information are New Relic's Confidential Information. Notices. New Relic may provide you with notices and communications at your email or physical address on file, through the Developer Site or other reasonable means. Any notices or communications to New Relic must be sent to legal@newrelic.com or New Relic, Inc., Attention: Legal Department - Developer Terms, 188 Spear Street, Suite 1200, San Francisco, CA 94105. Export. The Developer Resources may be subject to export restrictions by the United States government and import restrictions by certain foreign governments, and you agree to comply with all applicable export and import laws and regulations in your use of the Developer Resources. You represent and warrant that you are not located in a country subject to a U.S. Government embargo, or that has been designated by the U.S. Government as a \"terrorist supporting\" country, and that you are not listed on any U.S. Government list of prohibited or restricted parties. General. These Terms are the parties' entire agreement and supersede any prior or concurrent agreements relating to its subject matter. Except as set forth in Section 19 (Changes to Terms), all amendments or modifications must be in writing and signed by both parties. The words \"including\" and similar terms are to be construed without limitation. Failure to enforce any provision is not a waiver and all waivers must be in writing. If any provision is found to be unenforceable it (and related provisions) will be interpreted to best accomplish its intended purpose. Developer may not assign, transfer or delegate any right or obligations under these Terms and any non-permitted assignment is void. New Relic may assign these Terms and its rights and obligations to any of its affiliates or in connection with a merger, reorganization, acquisition or other transfer of all or substantially all of its assets or voting securities to which these Terms relate. The parties are independent contractors and these Terms do not create any agency, partnership or joint venture. These Terms will be governed by and construed under the laws of the State of California, as applied to agreements entered into and to be performed in California by California residents. The parties consent to the exclusive jurisdiction and venue of the courts located in and serving San Francisco, California. New Relic will not be liable to Developer for any delay or failure to perform any obligation under these Terms if the delay or failure is due to unforeseen events that are beyond its reasonable control. The Developer Resources include commercial computer software. If the user or licensee of such technology is an agency, department or other entity of the United States Government, the use, duplication, reproduction, release, modification, disclosure or transfer of such technology, or any related documentation of any kind, including technical data and manuals, is restricted by these Terms in accordance with Federal Acquisition Regulation 12.212 for civilian purposes and Defense Federal Acquisition Regulation Supplement 227.7202 for military purposes. The Developer Resources were developed fully at private expense. All other use is prohibited.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.369774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Terms <em>and</em> conditions",
        "sections": "Terms <em>and</em> conditions",
        "info": "Developer terms <em>and</em> conditions",
        "body": " to the Developer Resources or New Relic end users; or (j) take any action that would subject the Developer Resources or New Relic <em>Service</em> to any open source licenses or other <em>third</em> <em>party</em> terms. Use of New Relic Marks. Subject to these Terms, you may use the appropriate New Relic names, logos and trademarks"
      },
      "id": "6091f9c828ccbc0a1da26890"
    }
  ],
  "/build-apps/ab-test/chart-headings": [
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add a grid",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "fab1a23ddf5003cd0fb8189b903f3707a97d66e5",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a grid",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 523.87274,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a grid",
        "sections": "<em>Add</em> a grid",
        "info": "<em>Add</em> a grid",
        "body": " steps, you significantly improved the readability and usability of your A&#x2F;B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll <em>add</em> <em>headings</em> to your charts to remind yourself of what data each <em>chart</em> presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>chart</em> <em>headings</em>."
      },
      "id": "6091faf228ccbcbfe2a268f2"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add version descriptions",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "13644740111a7835d4738836f19589a74c711e26",
      "document_type": "page",
      "popularity": 1,
      "info": "Add version descriptions",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 514.7324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> version descriptions",
        "sections": "<em>Add</em> version descriptions",
        "info": "<em>Add</em> version descriptions",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>chart</em> <em>headings</em>, before"
      },
      "id": "6091fb44196a6744a7d52a81"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/article-templates/create-release-notes/",
      "sections": [
        "Create release notes",
        "New release note",
        "What makes a great release note?",
        "New release notes category",
        "Category landing page",
        "Landing page",
        "Links from other categories"
      ],
      "published_at": "2021-08-02T02:35:53Z",
      "title": "Create release notes",
      "updated_at": "2021-08-02T02:35:53Z",
      "type": "docs",
      "external_id": "e19983d8091fca385a3d4439ca6be36415e72236",
      "document_type": "page",
      "popularity": 1,
      "body": "This page is for release notes for downloadable software. For product announcements, see What's new style guidelines. New release note To add a release note to the Docs site: Find the most recent release note for your agent, and make a copy of it in the same folder. When you rename your copy, avoid potential version naming conflicts by using a - separator in your file name. For example, instead of agent-123, use agent-1-2-3 for version 1.2.3 and agent-12-3 for version 12.3. Fill in the subject, releaseDate, and version. If applicable, include downloadLink and watermark fields. Using our standard headings for New features, Improvements, and Bug fixes, add enough summary information in these sections to make a great release note. Link to docs or other resources where they can learn more. Commit your changes and submit a pull request. If your release is date-sensitive, make a note in your PR. A Tech Docs hero will review your release note content and approve your PR to get it published. You can also request others on your team to review your PR. We build and deploy the Docs site a few times a day, and sometimes builds can take a few hours to complete. If your release is time-sensitive, ensure you've planned for enough time to get your docs live. What makes a great release note? Great release notes help users quickly become familiar with your important update, so they know why it matters. Great release notes also help our support and security teams. By encouraging users to keep current with your latest release, this reduces support time to solve problems on outdated versions. It also mitigates risks if any potential vulnerabilities have been resolved with your latest version. To write a great release note, be as specific as possible. For example: Briefly describe new functionality. Give an example of the value it provides, and link to more detailed information. Don't use vague wording such as \"various bug fixes.\" Instead, clearly state what has been improved, so readers will know if an issue they’ve experienced has been resolved. New release notes category This information is primarily for the Tech Docs team's use. To add a new release notes category, update the following areas of the Docs site. (You do not need to update the releaseNote.js or releaseNoteLandingPage.js files in the nav/templates folder.) Before you submit your pull request to the GitHub docs site, check that the landing pages and placeholder release note build correctly in your localhost. Category landing page In /src/content/docs/release-notes, add the following: A folder for your new release notes category. The RSS feed link, page format, and date order for release notes listed on this page are generated automatically. For example, see the C SDK category landing page format. An index.mdx file in your new folder containing the subject. The subject is the name that will appear on the Release notes landing page. A placeholder release note in this folder for the agent team to fill out. If used, the downloadLink field in the release note will be formatted automatically in the published release note. Before the new category goes live, check with the team's Product Marketing Management (PMM) rep whether they want to include the link in an upcoming What's new post. Landing page In /src/content/docs/release-notes/index.mdx, add a new tile section in alphabetical order for your release notes category. Example: <TechTile name=\"Logs\" icon=\"logo-newrelic\" to=\"/docs/release-notes/logs-release-notes\" /> Copy Logos come from @newrelic/gatsby-theme-newrelic/icons/logo/. If a logo does not already exist for the new agent, use the standard logo-newrelic icon or an image in @newrelic/gatsby-theme-newrelic/icons/feathers.js. If you need other options, talk to the team's designer. Links from other categories Add a link to your new release notes category in the agent's documentation, typically in its Get started category. For more information, see our documentation about docs in multiple menus. Optional: Add a link in the agent's landing page text by updating the index.mdx file in its taxonomy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.572266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " standard <em>headings</em> for New features, Improvements, and Bug fixes, <em>add</em> enough summary information in these sections to make a great release note. Link to docs or other resources where they can learn more. Commit your changes and submit a pull request. If your release is date-sensitive, make a note in your"
      },
      "id": "6043db3e196a67dbb9960f7f"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-guidelines/levels-headings/",
      "sections": [
        "Levels of headings",
        "Use parallel construction",
        "Keep it short, avoid -ing words",
        "Do not use h1 headings",
        "Use level two headings to identify chunks of information",
        "Important",
        "Avoid using level three headings"
      ],
      "published_at": "2021-08-02T04:29:54Z",
      "title": "Levels of headings",
      "updated_at": "2021-05-21T14:31:50Z",
      "type": "docs",
      "external_id": "981282f676b2697e24f69ad23bce7e3412bb1d22",
      "document_type": "page",
      "popularity": 1,
      "body": "Taking some time to consider your headings and document titles will be time well spent. Titles and headings are not only important for search results, but they can make your docs easier to skim. For all headings and document titles, use sentence case. Use parallel construction Use parallel construction when naming headers. For example, use all nouns (\"Organization,\" \"Tone\"), all verbs (\"Create,\" \"Delete\"), etc. Keep it short, avoid -ing words For all headers, keep the title as short as possible. In particular, avoid headers that are more than a line long. As with all our writing, you should feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which add to character count without contributing clarity. Do not use h1 headings After you publish your doc, the Docs site will automatically use what you added to the Title field as the doc's level one heading (h1). To ensure that your doc is properly indexed for search, do not manually create additional h1 headings. If your doc's title is long and you would like a shorter title to appear in the sidebar menu, create a GitHub issue and we'll help you with that change. Use level two headings to identify chunks of information Organize chunks of information into sections with level two headings (##). For example: ## Create a new user [#create-new-user] Copy Important If you don't specify an ID manually, the site will use your header text as that header's ID (also known as anchor link). Create a manual ID to preserve links to that header if you change the header text. If you have too many level sections, consider splitting the document into multiple pages. Avoid using level three headings Avoid using ### headings unless it makes sense for the content or if the content is lengthy. Collapsers, tables, and other structural elements are often a better choice. Be particularly careful about level three headings that make a level two section longer than a single screen height. Here are two examples of good scenarios for using level three headings: Example #1: Events-to-metrics API doc Example #2: Infrastructure integration doc",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.27333,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Levels of <em>headings</em>",
        "sections": "Levels of <em>headings</em>",
        "body": " feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which <em>add</em> to character count without contributing clarity. Do not use h1 <em>headings</em> After you publish your doc, the Docs site will automatically use what you added"
      },
      "id": "604221d3196a677e3aa83db4"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add user interface components to your application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "ed894ca79a689bdfbf6cff8d64273d4921872e41",
      "document_type": "page",
      "popularity": 1,
      "info": "Add user interface components to your application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.38108,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> user interface components to your application",
        "sections": "<em>Add</em> user interface components to your application",
        "info": "<em>Add</em> user interface components to your application",
        "body": " functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> <em>headings</em> to clarify what each <em>chart</em> represents. Third, you&#x27;ll <em>add</em> descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section"
      },
      "id": "6091fb4464441f44672f36fa"
    }
  ],
  "/build-apps/ab-test/persist-version": [
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Add a section to end your test",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "b6a72d3fa08cce5a0edcacd34e8fa438dcfeaede",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a section to end your test",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 631.36597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " value in the component doesn&#x27;t change. You must control the value that <em>Select</em> displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to <em>persist</em> your <em>version</em> choice in the <em>Select</em> component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Persist</em> the <em>selected</em> <em>version</em>."
      },
      "id": "6091faf228ccbcbf1fa268ea"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Present an end test confirmation modal",
      "updated_at": "2021-05-05T01:54:59Z",
      "type": "developer",
      "external_id": "d304e6d4f2b5f3ca8465df20913b58f4360652d7",
      "document_type": "page",
      "popularity": 1,
      "info": "Present an end test confirmation modal",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. The modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.95193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>the</em> <em>version</em> you <em>selected</em> in your modal",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Persist</em> the <em>selected</em> <em>version</em>"
      },
      "id": "6091faf428ccbcbe03a268f3"
    },
    {
      "sections": [
        "Handled exceptions: Analyze trends, prevent crashes",
        "Handled exceptions workflow",
        "Exception percentage charts",
        "Exception percentage charts example",
        "Groups and filters",
        "Groups and filters example",
        "Top five exception locations",
        "Top five exception locations example",
        "Query builder links",
        "Exception locations table",
        "Exception locations table example"
      ],
      "title": "Handled exceptions: Analyze trends, prevent crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "d325744648613b771d7dd39de3f1448fe8a54ab9",
      "image": "https://docs.newrelic.com/static/5891a9437b94b543d81ee04a70ebe876/8c557/mobile-handled-exceptions-ui.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/handled-exceptions-analyze-trends-prevent-crashes/",
      "published_at": "2021-08-02T10:53:28Z",
      "updated_at": "2021-07-21T21:33:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Handled exceptions help you identify significant factors contributing to poor mobile application experience, and use filterable data to find a resolution more quickly. You can also use the handled exceptions API to customize the data you send, and use NRQL to query and share the data. Handled exceptions workflow To get the most out of the Handled exceptions UI, use this basic workflow: Go to one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions. Use any of New Relic's standard page functions to drill down into detailed information; for example, zoom into any area of a chart. Look for obvious or general trends in the Users affected and Sessions affected percentage charts. Adjust the types of exceptions shown by using groups and filters. Optional: Query or share the chart data. Look for similar patterns where exceptions appear in stack traces with the Top 5 exception locations table. To view stack trace thread details for each occurrence of the exception, select a record from the Top 5 exceptions location table. one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: As you explore the wealth of data in the charts and table, use groups and filters to discover patterns that help you determine the root cause of mobile app exceptions. Exception percentage charts Start with the Users affected and Sessions affected percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with exceptions in general. (If the Users affected chart is empty, there were no user sessions during the selected time period.) For example: Are there any spikes near a recent version release? Is there a time period when the percentage of users has been affected significantly by the exception? Are there uneventful periods? To examine data in greater detail: Below any chart, select Expand chart. Exception percentage charts example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: The percentage charts help you quickly see any unexpected spikes, dips, or patterns with exceptions in general. Groups and filters Use the groups and filters to examine attributes for crashes, devices, locations, or other custom attributes in more detail. You can select a group, then filter to specific data. For example: Group the list by exception location (default), cause, app build or version, devices, connections, or other custom attributes. This lets you discover patterns in your exceptions to determine the root cause. Use the time picker to adjust the currently selected time period. Filter by a specific Version or by one or more attribute Filter, such as appVersion, exceptionLocationMethod, lastInteraction, or any of the longer list of standard and custom attributes. The currently selected filters appear at the top of the UI page. You can close them, add other filters, or select other groups and filters. Groups and filters example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: Group the data by attributes that matter to the most to you, then select one or more filters to help pinpoint specific causes behind the exceptions. Top five exception locations Use the Top 5 exception locations table to find or sort patterns in the type of exception you selected from the groups and filters. This includes: Recurring locations in the stack trace Mobile app version Number of occurrences Number of users affected during the selected time period For example, you can group by Exception Message, filter to timeout message, then select individual timeout locations from the table to review the stack trace thread and details about each occurrence. To filter or group by other attributes, use the table's search window, or select any of the available filters. For example, filter by type of occurrence, device, a specific location, or any custom attributes. To look for other historical patterns, change the selected time period. Top five exception locations example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: This example shows the Expand chart button and links to the query builder, where you can query, create dashboards, and share the handled exceptions data. Query builder links Handled exceptions charts use default attributes for mobile events (including MobileHandledException), along with any custom attributes you have added to this event type. When you mouse over the charts, direct links appear below them. These links to the query builder allow you to analyze your mobile app data even deeper. View query link: View the NRQL query used to calculate the chart data. View in query builder link: View the chart, and share it with others. Exception locations table The Exception locations table supplements the charts. It lists where the top five handled exceptions appear in their stack trace thread, and links them to relevant details. Each row helps you find answers to questions such as: How many of this exception occurred within the selected time period? Does a specific app version have a higher (or lower) number of users affected? Which exception has the fewest number of occurrences? You can change the sort order or filter options to focus on just the types of exceptions that matter the most to you and your teams. To view additional thread details for each occurrence of the exception, select a record from the Top 5 exceptions location table. Exception locations table example one.newrelic.com > Mobile > (select an app) > Exceptions > Handled exceptions: To continue to the handled exception's Occurrences page, select any row on the table.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.796906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " from the groups and filters. This includes: Recurring locations in the stack trace Mobile app <em>version</em> Number of occurrences Number of users affected during the <em>selected</em> time period For example, you can group by Exception Message, filter to timeout message, then <em>select</em> individual timeout locations"
      },
      "id": "604505ae28ccbc783e2c6085"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-08-02T05:22:55Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.64952,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " scheduling options, such as day of the week, time of day, and how long the window will last. <em>Select</em> the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be <em>selected</em>. <em>Select</em> Create. Create a one-time monitor downtime"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Versions analysis",
        "Versions analysis details",
        "Viewing drill-down details",
        "How version numbers are obtained",
        "Android",
        "iOS"
      ],
      "title": "Versions analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Usage pages"
      ],
      "external_id": "3906aba3231864c2adb43694636f085ae5332d0e",
      "image": "https://docs.newrelic.com/static/f359bb98f6fbf2a5c90dd604778a5dcd/c1b63/screen-versions_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/versions-analysis/",
      "published_at": "2021-08-02T12:31:59Z",
      "updated_at": "2021-07-09T12:29:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring includes a comparative analysis of adoption and performance between versions of your application, including top versions by: Interaction time Active sessions Error rate The Versions page also includes a table comparing each version by date created, average memory, average CPU, average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific version. Versions analysis details one.newrelic.com > Mobile > (select an app) > Usage > Versions: The Versions analysis includes color-coded charts of mobile app usage, plus a table that summarizes mobile app versions and their averages for memory, CPU, active users, and network RPM (requests per minute). The Versions page provides a list of all versions of your app that have been detected, plus overview information on all versions active in the last seven days. To view the comparative analysis: Go to one.newrelic.com > Mobile > (select an app) > Usage > Versions. To select the time period, use the time picker below the New Relic menu bar. Optional: Select the Sort by options. To view details only for a specific version, select its name. The Versions page provides a list of all versions of your app that have been active in the selected time window. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details one.newrelic.com > Mobile > (select an app) > Usage > Versions > (selected version): Here is an example of details for a selected version. The details page provides further insight into how the selected version compares to a reference version (a recent or popular version), and the average of other versions of your app. Time series show the comparison across error rate, response time, active sessions, and memory usage. To exit the details page, select the Close (X) button. How version numbers are obtained The way that mobile monitoring obtains the version number varies by platform: Android The Android agent obtains the version information from the android:versionName property in the manifest. iOS The iOS agent uses both CFBundleShortVersionString and CFBundleVersion properties to obtain the app version. The agent accesses those properties through iOS APIs. It does not obtain them by reading the info.plist file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Versions</em> analysis",
        "sections": "<em>Versions</em> analysis",
        "body": ", average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific <em>version</em>. Versions analysis details one.newrelic.com &gt; Mobile &gt; (<em>select</em> an app) &gt; Usage &gt; Versions: The Versions analysis includes color-coded charts"
      },
      "id": "603eaeeae7b9d262be2a080c"
    }
  ],
  "/build-apps/ab-test/nerdstoragevault": [
    {
      "image": "https://developer.newrelic.com/static/d2303a01613c5e0506712d9e593ec1db/ba3ac/nerdsletter-success.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/",
      "sections": [
        "Fetch data from a third-party service",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Fetch data from a third-party service",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92ddade6115ab659f26d62248a75ff9ec3ed7203",
      "document_type": "page",
      "popularity": 1,
      "info": "Fetch data from a third-party service",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1110.4143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Fetch data <em>from</em> a third-party service",
        "sections": "Fetch data <em>from</em> a third-party service",
        "info": "Fetch data <em>from</em> a third-party service",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorageVault</em> <em>from</em>"
      },
      "id": "6091fb4464441f43272f3724"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Access NerdStorage from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "8c49cf33a6d954510f5c4b309a8a4d2f848fd68c",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorage from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 453.28683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": "&#x27;s own data store. While <em>NerdStorage</em> is a great place for many categories of data, it&#x27;s not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you&#x27;d use <em>NerdStorageVault</em>. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091faf1196a67250bd52a2b"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-08-02T06:12:37Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 375.3045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "<em>Nerd</em>Graph allows you to <em>access</em> <em>your</em> New Relic data, but when you want to fetch third-party data, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and encrypted <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2021-08-03T01:47:21Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 373.15778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorageVault</em>",
        "sections": "Using <em>NerdStorageVault</em> in <em>your</em> apps",
        "info": "Intro to <em>NerdStorageVault</em> on New Relic One",
        "tags": "<em>nerdstoragevault</em>",
        "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use <em>NerdStorageVault</em> to store data in an encrypted <em>storage</em> solution. Using <em>NerdStorageVault</em> in <em>your</em> apps <em>NerdStorageVault</em> is used to store and retrieve sensitive secrets data"
      },
      "id": "6091fa9828ccbc86bda268a9"
    },
    {
      "image": "https://developer.newrelic.com/static/AaronSoto-6fa5ebc7cdc0169f102fd9dd988071d1.jpg",
      "url": "https://developer.newrelic.com/nerd-days/",
      "sections": [
        "Nerd Days is a free 1-day event focused on building more perfect software",
        "Register for Nerd Days 1.0",
        "What’s is Nerd Days exactly…",
        "Save the date & join us online",
        "Upcoming Nerd Days",
        "Speaker line up",
        "Aaron Soto",
        "Caitlin Halla",
        "David Shanker",
        "Jeremy Cooper",
        "Joel Worrall",
        "John Vajda",
        "Jon Thurman",
        "Justin Eveland",
        "Leon Chapman",
        "Lindsy Farina",
        "Talia Nassi",
        "Thomas Martin",
        "Alec Swanson",
        "Brian Thomason",
        "Chris Trombley",
        "Sander Blue",
        "Gabe O'Brien",
        "Liam Hurrell",
        "Michael Caron",
        "Phil Weber",
        "Sebastian Remirez",
        "Jewels Nocera",
        "Nica Fee",
        "Stijn Polfliet",
        "Brad Schmitt",
        "Eric Mittelhammer",
        "Colin MacNaughton",
        "Tracks",
        "Observability",
        "Cloud migration",
        "Open source",
        "Devops journey",
        "Fundamentals",
        "Nerd Days AMER Agenda",
        "DevOps journey",
        "Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements",
        "Instrumenting your service using agents",
        "New Relic CLI Wizardry",
        "5 Steps to Kubernetes Observability",
        "Delivering SRE as a Service",
        "Building applications on New Relic One",
        "Exploring your data using NRQL",
        "New Relic AI",
        "Going Serverless: Chipping at the monolith",
        "Logging for Modern Organizations",
        "Power up your Prometheus metrics with the Telemetry Data Platform",
        "Lunch with Lew",
        "Custom Instrumentation",
        "Exploring Data with NerdGraph",
        "Consolidating Your Data with New Relic’s Telemetry Data Platform",
        "Testing in Production",
        "How Open Source powers the New Relic One Catalog",
        "Alerts Best Practices",
        "The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data",
        "Monitoring your Cloud Usage and Spend",
        "Scaling the Developer Toolkit Team: Writing Code that Writes Code",
        "Reducing toil with Terraform",
        "True availability using Synthetics",
        "How Observability-Driven Development accelerates DevOps transformations",
        "AWS Modernization",
        "Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks'",
        "NerdStorageVault: ThirdParty Secrets",
        "Closing + Swag",
        "Engage with the developer community"
      ],
      "published_at": "2021-08-02T03:47:45Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-04T01:52:48Z",
      "type": "developer",
      "external_id": "0b8374051901a77e242ce296c00eeb3c760439d1",
      "document_type": "page",
      "popularity": 1,
      "body": "Nerd Days is a free 1-day event focused on building more perfect software Register for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region) What’s is Nerd Days exactly… A FREE developer focused live digital conference covering a broad range of topics at varying levels for all skill sets. Including: Live workshops Live coding and demos Customer examples Panel / Q&A sessions Presented by Relics, partners, Developer Champions, and customers Save the date & join us online Whether you’re new or a data nerd, there’s an interactive session for you. Choose the sessions you're interested in and add Nerd Days to your calendar. Date: October 13, 2020 Time: 9AM PST - 3PM PST We look forward to building with you during Nerd Days! If you have any questions about Nerd Days please emails deco@newrelic.com. Upcoming Nerd Days EMEA RegistrationNov 10, 2020 Speaker line up Get hands on with sessions presented by the following Relics, partners, Developer Champions, and customers. Aaron Soto Sr. Partner Solutions Architect AWS Caitlin Halla Software Engineer New Relic David Shanker Director, Platform Engineering Kinect Consulting Jeremy Cooper Sr. TechOps Strategy Consultant New Relic Joel Worrall Director, Open Source and Developer Advocacy New Relic John Vajda Senior Product Manager New Relic Jon Thurman Senior Solutions Consultant New Relic Justin Eveland Software Engineer New Relic Leon Chapman Senior TechOps Strategy Consultant New Relic Lindsy Farina Senior Product Manager New Relic Talia Nassi Developer Advocate Split Software Thomas Martin Director, Site Reliability 27 Global Alec Swanson Software Engineer New Relic Brian Thomason Senior Partner Solutions Consultant New Relic Chris Trombley Senior Software Engineer New Relic Sander Blue Senior Software Engineer New Relic Gabe O'Brien Senior Software Engineer New Relic Liam Hurrell Senior Technical Training Specialist New Relic Michael Caron Senior Technical Training Specialist New Relic Phil Weber Senior Technical Training Specialist New Relic Sebastian Remirez Lead Software Engineer New Relic Jewels Nocera Senior Software Engineer New Relic Nica Fee Developer Advocate New Relic Stijn Polfliet Principal TechOps Strategy Consultant New Relic Brad Schmitt Senior TechOps Strategy Consultant New Relic Eric Mittelhammer Senior TechOps Strategy Consultant New Relic Colin MacNaughton Lead Software Engineer New Relic Tracks Tracks will vary by region. All sessions will be recorded and distributed after the event. Observability Cloud migration Open source Devops journey Fundamentals Nerd Days AMER Agenda We’ve got a packed schedule with thought-leaders of their respective industries Fundamentals Observability Cloud migration DevOps journey Open source 9:00AM PST Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements Lew Cirne 10:00AM PST Instrumenting your service using agents Michael Caron New Relic CLI Wizardry Jon Thurman 5 Steps to Kubernetes Observability Stijn Polfliet & Brad Schmitt Delivering SRE as a Service Thomas Martin Building applications on New Relic One Joel Worrall 11:00AM PST Exploring your data using NRQL Phil Weber New Relic AI Sebastian Ramirez Going Serverless: Chipping at the monolith Nica Fee Logging for Modern Organizations Jeremy Cooper & Leon Chapman Power up your Prometheus metrics with the Telemetry Data Platform Liam Hurrell & Colin MacNaughton 12:00PM PST Lunch with Lew Lew Cirne & Jemiah Sius 1:00PM PST Custom Instrumentation Michael Caron Exploring Data with NerdGraph Caitlin Halla Consolidating Your Data with New Relic’s Telemetry Data Platform Eric Mittelhammer Testing in Production Talia Nassi How Open Source powers the New Relic One Catalog Justin Eveland 2:00PM PST Alerts Best Practices Phil Weber The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data Lindsy Farina Monitoring your Cloud Usage and Spend Jewels Nocera Scaling the Developer Toolkit Team: Writing Code that Writes Code Sander Blue Reducing toil with Terraform Jon Thurman 3:00PM PST True availability using Synthetics Michael Caron How Observability-Driven Development accelerates DevOps transformations Dave Shanker AWS Modernization Aaron Soto & Brian Thomason Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks' Gabe O’Brien & Alec Swanson NerdStorageVault: ThirdParty Secrets John Vajda 4:00PM PST Closing + Swag Jemiah Sius Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.91934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerd</em> Days is a free 1-day event focused on building more perfect software",
        "body": " transformations Dave Shanker AWS Modernization Aaron Soto &amp; Brian Thomason Writing Reliably Bad Software, AKA &#x27;How to get paid to write memory leaks&#x27; Gabe O’Brien &amp; Alec Swanson <em>NerdStorageVault</em>: ThirdParty Secrets John Vajda 4:00PM PST Closing + Swag Jemiah Sius Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin"
      },
      "id": "5f3dd5bf28ccbc2349f56e4e"
    }
  ],
  "/build-apps/ab-test/version-descriptions": [
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add chart headings",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "01dece7fe0259e5d6ff3c32f2022c97034db7a5a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart headings",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 403.34317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> chart headings",
        "sections": "<em>Add</em> chart headings",
        "info": "<em>Add</em> chart headings",
        "body": " grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it&#x27;d be nice to <em>add</em> <em>descriptions</em> to help you remember what each <em>version</em> in your A&#x2F;B test represents. In the next lesson, you&#x27;ll <em>add</em> a description for each design <em>version</em>"
      },
      "id": "6091faf128ccbcdaa2a26895"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Add a section to end your test",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "b6a72d3fa08cce5a0edcacd34e8fa438dcfeaede",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a section to end your test",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.4641,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a section to end your test",
        "sections": "<em>Add</em> a section to end your test",
        "info": "<em>Add</em> a section to end your test",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>version</em> <em>descriptions</em>"
      },
      "id": "6091faf228ccbcbf1fa268ea"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.691376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a local <em>version</em> of the &quot;Hello, World!&quot; application",
        "body": ": Step 3 of 5 In the catalog directory of your project, <em>add</em> screenshots or various types of metadata to describe your project. For details about what you can <em>add</em>, see <em>Add</em> catalog metadata and screenshots. Step 4 of 5 After you <em>add</em> the screenshots and <em>descriptions</em> you want, execute the following to save"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-08-03T00:46:14Z",
      "updated_at": "2021-08-03T00:46:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.30178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Device profile: How many users use the latest OS <em>versions</em>?",
        "body": " by default for: Android <em>version</em> 5.15.2 or higher iOS <em>version</em> 6.0.0 or higher For earlier versions, starting with Android <em>version</em> 5.14.0 or iOS <em>version</em> 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS <em>version</em>, or <em>add</em> the required feature flag to your app. Below are some NRQL"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "Update the Node.js agent",
        "Upgrade to Node.js agent version 8",
        "Node version support",
        "Tip",
        "Upgrade to Node.js agent version 7",
        "Upgrade to Node.js agent version 6",
        "Upgrade to Node.js agent version 5",
        "Feature flags as of v5",
        "Upgrade to Node.js agent version 4",
        "Upgrade https-proxy-agent from v0 to v2",
        "Upgrade to Node.js agent version 3",
        "Major changes with Node.js v3 agent",
        "Feature flags as of v3",
        "Upgrade to Node.js agent version 2",
        "Major changes with Node.js v2 agent",
        "Updated configuration options as of v2",
        "Deprecated API methods as of v2",
        "newrelic.createWebTransaction()",
        "newrelic.createBackgroundTransaction()",
        "newrelic.addCustomParameter()",
        "newrelic.addCustomParameters()",
        "New v2 agent API methods",
        "newrelic.getTransaction()",
        "newrelic.startWebTransaction()newrelic.startBackgroundTransaction()",
        "newrelic.instrument()newrelic.instrumentDatastore()newrelic.instrumentWebframework()newrelic.instrumentMessages()",
        "newrelic.addCustomAttribute()",
        "newrelic.addCustomAttributes()",
        "Node version support for v2",
        "npm version support as of v2",
        "Feature flags as of v2",
        "Framework minimum versions as of v2"
      ],
      "title": "Update the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "7534966716b25d9a64d3b1fe24fe9e72cfd15530",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/update-nodejs-agent/",
      "published_at": "2021-08-02T07:54:54Z",
      "updated_at": "2021-08-02T07:54:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To take full advantage of New Relic's latest features, enhancements, and important security patches, we recommend you update your Node.js agent to the latest version. For additional information about specific agent updates, refer to the Node.js agent release notes. The release notes include a download link when applicable, plus instructions to download and install the latest version. If the newrelic module is listed in your package.json, run npm install. If you want to target just the newrelic module, run npm update newrelic. Recommendation: Test your updated version before moving it into production. If you have problems, follow the Node.js agent troubleshooting procedures. Upgrade to Node.js agent version 8 Before upgrading to Node.js version 8, review this information for major changes. Major changes with Node.js agent v8 Comments Added official parity support for Node 16. BREAKING: Dropped Node v10.x support. For further information see our support policy. BREAKING: Removed serverless_mode as a feature flag. The standard serverless_mode configuration still exists. BREAKING: The agent no-longer includes the New Relic certificate bundle automatically when using the 'certificates' configuration (commonly with proxies). If you find this breaking your current environment, you may leverage a feature-flag to temporarily restore this functionality. Example configuration: feature_flag: { certificate_bundle: true }. In this case, we recommend getting a certificate bundle for your environment such as the one from Mozilla. The New Relic bundle and feature flag will be fully removed in next major release. Defaulted config.feature_flags.certificate_bundle to false. Update New Relic Dependencies to versions with updated Node version support @newrelic/aws-sdk v4.0.1 @newrelic/koa v6.0.1 @newrelic/native-metrics v7.0.1 @newrelic/superagent v5.0.1 @newrelic/test-utilities v6.0.0 Node version support Node v12 is the earliest version supported by the New Relic Node.js v8 agent. Node 10 and 11 are not supported by v8. Customers running Node 11 and earlier have two options: Upgrade to a supported version of Node and take advantage of the New Relic Node.js v8 agent's new features. Remain on New Relic Node.js v7 agent without the ability to use new features only available with update agent versions. Tip Upgrade to a newer version of Node as soon as possible. The next major version of the New Relic Node.js agent will likely remove support for Node 12. Upgrade to Node.js agent version 7 Before upgrading to Node.js version 7, review this information for major changes. Major changes with Node.js agent v7 Comments BREAKING Removed deprecated httpResponseCode, response.status and httpResponseMessage http response attributes v6.4.2-v6.14.0: Starting in agent v6.4.2, these attributes were marked as deprecated but left in to give a transition period for the new attributes. v7: When http response attribute reporting is enabled, http.statusCode and http.statusText will be reported. BREAKING Removed deprecated setIgnoreTransaction API method v5 - v6: Starting in agent v5.0.0, this method was marked as deprecated but left in to give a transition period for the new methods. v7: Applications must use the API method transactionHandle.ignore(). BREAKING Removed the api.custom_parameters_enabled configuration item and associated environment variable NEW_RELIC_API_CUSTOM_PARAMETERS. Applications must use the configuration api.custom_attributes_enabled or the associated environment variable NEW_RELIC_API_CUSTOM_ATTRIBUTES to enable newrelic.addCustomAttribute and newrelic.addCustomAttributes. BREAKING Removed deprecated Distributed Tracing API methods, createDistributedTracePayload() and acceptDistributedTracePayload() v6.4.0-v6.14.0: Starting in agent v6.4.0, these method were marked as deprecated but left in to give a transition period for the new methods. v7: Applications must use the API methods transactionHandle.insertDistributedTraceHeaders(headers) and transactionHandle.acceptDistributedTraceHeaders(transportType, headers) . With these methods, the Node agent will now accept W3C's traceparent and tracestate headers when calling transactionHandle.acceptDistributedTraceHeaders(headers) and include the W3C headers along with the New Relic distributed tracing header when calling transactionHandle.insertDistributedTraceHeaders(headers), unless the New Relic trace header format is disabled using distributed_tracing.exclude_newrelic_header:true. Update New Relic Dependencies to versions with updated Node version support @newrelic/aws-sdk v3.0.0 @newrelic/koa v5.0.0 @newrelic/native-metrics v6.0.0 @newrelic/superagent v4.0.0 @newrelic/test-utilities v5.0.0 Node version support Node v10 is the earliest version supported by the New Relic Node.js v7 agent. Node 8 and 9 are not supported by v7. Customers running Node 9 and earlier have two options: Upgrade to a supported version of Node and take advantage of the New Relic Node.js v7 agent's new features. Remain on New Relic Node.js v6 agent without the ability to use new features only available with update agent versions. Node 10 does not receive updates. Upgrade to a newer version of Node as soon as possible. Support for Node 10 has been discontinued with the New Relic Node.js agent v8. Upgrade to Node.js agent version 6 Before upgrading to Node.js agent version 6, review this information for major changes. Major changes with Node.js agent v6 Comments Upgraded official Koa framework instrumentation module to v3.0.0 v6: Added support for @koa/router up to v8.0.2. @koa/router v8.0.3 and greater are currently unsupported. v6: Added support for Node v12 and removed support for Node v6, 7, and 9. The minimum supported version is Node v8. Also see New Relic's Koa Release Notes on Github.. Removed deprecated max_samples_per_minute configuration parameter, which is replaced by max_samples_stored behavior v1 - v5: max_samples_per_minute defined the maximum number of events the agent collects per minute. If your application previously used max_samples_per_minute as an upper bound, you may need to lower the threshold to a valid maximum to avoid data being dropped on the server. We recommend less than 10k. v5: In agent v5 and lower, max_samples_stored defined the maximum number of events the agent stores if it's unable to communicate with the New Relic collector. v6: The new behavior of max_samples_stored defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. This usage of the configuration is consistent with the other APM agents. Troubleshooting tips: If you're missing event data, increase the value of max_samples_stored or revert to the default value. The value of max_samples_stored should not be over 10,000. Node version support Node 8 is the earliest version supported by the New Relic Node.js v6 agent. Node 6, 7 and 9 are not supported by v6. Customers running Node 6, 7 and 9 have two options: Upgrade to a supported version of Node and take advantage of the New Relic Node.js v6 agent's new features. Remain on New Relic Node.js v5 agent without the ability to use new features only available with update agent versions. Node 8 no longer receive updates, but New Relic will continue to support these versions of Node for the time being. Tip Upgrade to a newer version of Node as soon as possible. The next major version of the New Relic Node.js agent will likely remove support for Node 8. Upgrade to Node.js agent version 5 Before upgrading to Node.js agent v5, review this information for major changes. Also see New Relic's Node.js v5 migration guide on GitHub. Major changes with Node.js v5 agent Comments Removed deprecated addCustomParameter methods. v2 - v4: Starting in agent v2.7.0, these methods were marked as deprecated but left in to give a transition period for the new methods. v5: Applications must use the API methods newrelic.addCustomAttribute() and newrelic.addCustomAttributes(). These are drop-in replacements for the old methods. Removed deprecated create*Transaction methods. v2 - v4: Starting in agent v2.0.2, these methods were marked as deprecated but left in to give a transition period to the new methods. v5: Applications must update to the API methods newrelic.startWebTransaction() and newrelic.startBackgroundTransaction(). Troubleshooting tips: These new methods are not drop-in replacements for the old ones. Before moving to these new methods, review our custom instrumentation guide. Removed deprecated createTracer method. v3 - v4: Starting in agent v3.3.0, this method was marked as deprecated in favor of newrelic.startSegment(). v5: Applications must update to newrelic.startSegment(). Removed node-cassandra-cql instrumentation. v4: Applications using the npm package node-cassandra-cql would get datastore metrics for Cassandra. v5: Applications must migrate to the cassandra-driver package to get Cassandra datastore metrics. This module is actively maintained by the same developers. The node-cassandra-cql package was abandoned in February of 2014 in favor of the cassandra-driver package. Removed deprecated capture_params and ignored_params configurations. v2 - v4: Starting in agent v2.7.0, these configuration parameters caused a warning to be logged, and the values were automatically upgraded to the new attributes configurations. v5: A warning will still be logged but the configuration is ignored, and no automatic upgrading happens any more. Troubleshooting tips: If your application had parameters listed in the ignored_params configuration, you will need to move them to attributes.exclude. Node version support Node 6 is the earliest version supported by the New Relic Node.js v5 agent. Node 4 and 5 are not supported by v5. Customers running Node 4 or 5 have two options: Upgrade to a supported version of Node and take advantage of the New Relic Node.js v5 agent's new features. Remain on New Relic Node.js v4 agent without the ability to use new features only available with update agent versions. Node 7 and 9 no longer receive updates, but New Relic will continue to support these versions of Node for the time being. Tip Upgrade to a newer version of Node as soon as possible. The next major version of the New Relic Node.js agent will likely remove support for Node 6 and 7. Feature flags as of v5 As of New Relic for Node.js v5: custom_instrumentation: This feature is no longer configurable. custom_metrics: This feature is no longer configurable. synthetics: This feature is no longer configurable. native_metrics: This feature is now controlled by the plugins.native_metrics.enabled configuration value. Upgrade to Node.js agent version 4 Before upgrading to Node.js agent v4, review this information for major changes. Also see New Relic's Node.js v4 migration guide on GitHub. Upgrade https-proxy-agent from v0 to v2 Major changes with Node.js v4 agent include an upgrade of the https-proxy-agent from v0 to v2. This dependency has been updated due to a security issue in the https-proxy-agent that the New Relic Node.js agent used. Because https-proxy v2 is incompatible with node v0.10 and v0.12, New Relic has deprecated those agent versions. There is no required action to migrate from v3 to v4 of New Relic's Node.js agent. Node version support Node 4 is the earliest version supported by the New Relic Node.js v4 agent. Node 0.10 and 0.12 are not supported by v4. Customers running Node 0.10 or 0.12 have two options: Upgrade to a supported version of Node and take advantage of the New Relic Node.js v4 agent's new features. Remain on the New Relic Node.js v3 agent without the ability to use new features only available with updated agent versions. Node 4, 5, and 7 also no longer receive updates, but New Relic will continue to support these versions of Node for the time being. Tip Upgrade to a newer version of Node as soon as possible. The next major version of the New Relic Node.js agent will likely remove support for Node 4 and 5. Upgrade to Node.js agent version 3 Before upgrading to Node.js agent agent v3, review this information for major changes. Also see New Relic's Node.js v3 migration guide on GitHub. Major changes with Node.js v3 agent Major changes with Node.js v3 agent Comments Removed SSL configuration v2: With the v2 agent, it was possible to configure the agent to connect to New Relic without encryption. v3: Node.js agent v3 always connects to New Relic servers using TLS encryption to protect communications. If the agent is configured to disable this, a warning is logged and the setting is ignored. Request parameters now prefixed with request.parameters. v2: The v2 agent collects request parameters, such as route parameters (/users/:userId) and query parameters (/users?userId=123), as the parameter name (userId). v3: The v3 agent prefixes all request parameters with the string request.parameters.. For example,userId appears as request.parameters.userId. Troubleshooting tips: If you have dashboards, alert policies, or other NRQL queries based on request parameters, update them with the new parameter names. Feature flags as of v3 As of New Relic Node.js agent v3, the send_request_uri_attribute feature is no longer configurable. Upgrade to Node.js agent version 2 Before upgrading to Node.js agent v2, review this information for major changes. Also see New Relic's Node.js v2 migration guide on GitHub. Major changes with Node.js v2 agent Major changes with Node.js v2 agent Comments Reversed naming and ignore rules v1: With the v1 agent, rules defined in the config properties rules.name and rules.ignore were applied in reverse order; the first rule in the list was applied last. v2: Node.js agent v2 applies rules in the order they are defined, so the first rule in the list is applied first. Troubleshooting tips: If you used naming rules in the v1 agent and notice problems, reverse the order of your rules in your configuration. De-duplicated HTTP request transactions v1: The v1 agent started a new transaction for each listener on an HTTP server's request event. In applications with multiple listeners on the request event, this resulted in extraneous transactions being created that almost always did not get named correctly. v2: The v2 agent only creates a single transaction for each request event emitted. Troubleshooting tips: If you used multiple request event listeners and added a call to newrelic.ignoreTransaction() to remove the extra transactions, remove those calls. Stopped swallowing outbound request errors v1: The v1 agent swallowed unhandled error events emitted by outbound HTTP request objects. v2: The v2 agent removes this behavior. Instead, the v2 agent does not change normal Node execution. This means the error event will always be emitted. Troubleshooting tips: If you are making outbound requests and currently do not listen for the error event, add a listener and handle the error as appropriate for your application. Updated configuration options as of v2 In newrelic.js, edit the Node.js agent configuration properties you use for compatiblity with the latest versions: Deprecated property New property capture_params attributes.enabled: false By default, request attributes are not sent to New Relic. Set attributes.enabled: true to include agent-defined or custom attributes in traces. The capture_params property has been deprecated. ignored_params attributes.exclude: [] Add any request attribute keys to the attributes.exclude list. Now, instead of having to be an exact match, wildcards (*) may be appended to each item for broader filtering. The ignored_params property has been deprecated. These Node.js agent configuration properties also have overrides for specific destinations, including: transaction_tracer transaction_events error_collector browser_monitoring For example, if the root attributes.enabled is true and you set transaction_tracer.attributes.enabled: false, this will restrict attributes from being collected in transaction traces, while still allowing them for all others. Deprecated API methods as of v2 The following methods from the Node.js agent have been deprecated, and New Relic has deleted them in v5 of the agent. Each has an easy replacement that accomplishes the same task in a more flexible and reliable way. newrelic.createWebTransaction() Replace with newrelic.startWebTransaction() and newrelic.getTransaction(). newrelic.createBackgroundTransaction() Replace with newrelic.startBackgroundTransaction() and newrelic.getTransaction(). newrelic.addCustomParameter() Replace with newrelic.addCustomAttribute(). newrelic.addCustomParameters() Replace with newrelic.addCustomAttributes(). New v2 agent API methods The following API methods are new with the New Relic Node.js v2 agent. newrelic.getTransaction() This method gets a reference to the currently running transaction. Use in conjunction with: newrelic.startWebTransaction newrelic.startBackgroundTransaction Callback-based message consumer services for troubleshooting message consumers newrelic.startWebTransaction()newrelic.startBackgroundTransaction() These new API methods replace the older create*Transaction methods. They are easier to use and seamlessly work with promises. Unlike the v1 method, the provided callback is invoked immediately. newrelic.instrument()newrelic.instrumentDatastore()newrelic.instrumentWebframework()newrelic.instrumentMessages() Use these methods to add custom instrumentation for third party modules, including those already instrumented by the New Relic Node.js agent. For more information, see New Relic's Node.js instrumentation tutorials on GitHub. newrelic.addCustomAttribute() Use this method to add a custom trace attribute. newrelic.addCustomAttributes() Use this method to add multiple custom trace attributes. Node version support for v2 The earliest version of Node supported by the New Relic Node.js v2 agent is 0.10. Node 0.8, which has not been updated since July of 2014, is not supported by v2. Customers running Node 0.8 have two options: Upgrade to a supported version of Node and take advantage of the New Relic Node.js v2 agent's new features. Remain on New Relic Node.js v1 agent without the ability to use new features only available with updated agent versions. Node 0.10 also no longer receives updates, but New Relic will continue to support this version of Node for the time being. Recommendation: Upgrade to a newer version of Node as soon as possible. npm version support as of v2 The New Relic Node.js agent now requires npm version 2.0.0 or higher. This version of npm comes packaged with Node 0.10.44 or higher. If you are using an earlier version of Node 0.10 you will need to first install npm 2.0.0 or higher, or upgrade to a newer version of Node. To install npm version 2: $ npm install --global npm@2 Copy Feature flags as of v2 As of New Relic Node.js agent v2: express_segments: This feature is no longer configurable. cat: This feature is now controlled by the cross_application_tracer.enabled configuration value. Framework minimum versions as of v2 As of New Relic Node.js agent v2: Module V2 minimum Minimum before v2 express 4.6.0 2.0.0 mysql 2.0.0 0.9.0",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.940994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upgrade to Node.js agent <em>version</em> 8",
        "body": " for Node 8. Upgrade to Node.js agent <em>version</em> 5 Before upgrading to Node.js agent v5, review this information for major changes. Also see New Relic&#x27;s Node.js v5 migration guide on GitHub. Major changes with Node.js v5 agent Comments Removed deprecated <em>add</em>CustomParameter methods. v2 - v4: Starting"
      },
      "id": "6043d374e7b9d258435799e9"
    }
  ],
  "/build-apps/ab-test/nerdstorage": [
    {
      "image": "https://developer.newrelic.com/static/d2303a01613c5e0506712d9e593ec1db/ba3ac/nerdsletter-success.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/",
      "sections": [
        "Fetch data from a third-party service",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Fetch data from a third-party service",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92ddade6115ab659f26d62248a75ff9ec3ed7203",
      "document_type": "page",
      "popularity": 1,
      "info": "Fetch data from a third-party service",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 945.95715,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Fetch data <em>from</em> a third-party service",
        "sections": "Fetch data <em>from</em> a third-party service",
        "info": "Fetch data <em>from</em> a third-party service",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorage</em>Vault <em>from</em>"
      },
      "id": "6091fb4464441f43272f3724"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 601.26416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add, query, and mutate data using <em>NerdStorage</em>",
        "body": " <em>from</em> <em>your</em> account and add it to a dropdown menu in an application Add, query, and mutate data using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents <em>from</em> one session to the next. Add a time picker to <em>your</em> app"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "https://developer.newrelic.com/static/39196df35b3f160bf0ac9eeab116b112/ba3ac/real-table-chart-data.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Customize NRQL data",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "52491e06cfe78faf65a628e3a553720f3ce4d318",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize NRQL data",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 555.77466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Merge NRQL <em>from</em> multiple sources",
        "body": ", <em>your</em> demo application doesn&#x27;t create custom New Relic events when a user unsubscribes <em>from</em> <em>your</em> newsletter or you end an A&#x2F;B test. In the next lesson, you&#x27;ll learn how to use <em>Nerd</em>Graph and <em>NerdStorage</em> to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091faf228ccbcbadfa268f9"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-08-03T01:49:52Z",
      "title": "Access NerdStorageVault from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "d35788d1b5e58689f48c12aa4cbdc2f446550102",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorageVault from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.87357,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em>"
      },
      "id": "6091faf264441f1cbe2f36e1"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2021-08-03T01:40:57Z",
      "updated_at": "2021-05-21T01:41:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.4207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate data using <em>NerdStorage</em>",
        "sections": "Query data <em>from</em> <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document database <em>accessible</em> within New Relic One. It allows you to modify, save, and retrieve documents <em>from</em> one session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " the application’s .&#x2F;nerdlets&#x2F;use-<em>nerdstorage</em>-<em>nerdlet</em>&#x2F;index.js file in the text editor of <em>your</em> choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addTo<em>NerdStorage</em>, and you need to update it to add User<em>Storage</em>"
      },
      "id": "6091f9c8196a67648ed52a3c"
    }
  ],
  "/build-apps/ab-test/catalog": [
    {
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/",
      "sections": [
        "Publish your New Relic One application",
        "Course",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Publish your New Relic One application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "f17b8d1fc30a296e6c4f0b4ef06c28e36672b87b",
      "document_type": "page",
      "popularity": 1,
      "info": "Publish your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Describe your app for the catalog, before starting this one. In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the Nerdpack's root-level package.json file. Every time you modify code in your Nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 7 Change to the publish/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 7 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 7 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 7 Replace all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively. Step 6 of 7 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 7 of 7 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Subscribe to your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 767.5219,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Publish <em>your</em> New Relic One <em>application</em>",
        "sections": "View <em>your</em> <em>application</em> in <em>the</em> <em>catalog</em>",
        "info": "Publish <em>your</em> New Relic One <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Describe</em> <em>your</em> <em>app</em>"
      },
      "id": "6091fb45e7b9d2820a5068b9"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 578.6188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add navigation to <em>your</em> Nerdlet",
        "sections": "Add navigation to <em>your</em> Nerdlet",
        "info": "Add navigation to <em>your</em> Nerdlet",
        "body": " and subscribe to <em>your</em> New Relic One application so that it can run on our platform instead of <em>your</em> own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Describe</em> <em>your</em> <em>app</em> for the <em>catalog</em>."
      },
      "id": "6091faf128ccbcb641a268f9"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.52548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to <em>your</em> Nerdpack",
        "sections": "Update <em>your</em> Nerdpack&#x27;s <em>catalog</em> information",
        "info": "Share and use <em>the</em> Nerdpacks you build",
        "body": "Whether <em>your</em> Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, <em>describe</em>, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to <em>your</em> nerdpack Update <em>your</em> Nerdpack&#x27;s <em>catalog</em>"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.71487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a &quot;Hello, World!&quot; <em>application</em>",
        "sections": "Add details to <em>describe</em> <em>your</em> project",
        "info": "Build a &quot;Hello, World!&quot; <em>app</em> and publish it to New Relic One",
        "tags": "NR One <em>Catalog</em>",
        "body": ". When <em>your</em> new application opens, notice that it doesn&#x27;t display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to <em>describe</em> <em>your</em> project Now that <em>your</em> new application is in the New Relic One <em>catalog</em>, you can add details that help users"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terms/",
      "sections": [
        "Terms and conditions"
      ],
      "published_at": "2021-08-02T10:57:00Z",
      "title": "Terms and conditions",
      "updated_at": "2021-08-02T10:57:00Z",
      "type": "developer",
      "external_id": "5c260dc18b9f68a28114875ddc900a8935479040",
      "document_type": "page",
      "popularity": 1,
      "info": "Developer terms and conditions",
      "body": "New Relic Developer Terms Welcome to New Relic's developer program (\"Developer Program\")! We are excited that you're here. Our intent is to maintain a vibrant software development community. We require that all users that develop on the New Relic platform adhere to these terms. These terms (\"Terms\") apply to participation in the Developer Program and form a legal agreement between you (\"you\" or \"Developer\") and New Relic, Inc. (\"New Relic\", \"we\", \"our\" or \"us\"), so please read them carefully. If you are entering into these Terms on behalf of a company, organization or another legal entity, then \"you\" or \"Developer\" means that entity, and you represent and warrant that you have the authority to bind that entity to these Terms. Please ensure you have that authority, since otherwise you may not accept these Terms or use the Developer Resources. New Relic may modify these Terms from time to time, subject to Section 19 (Changes to Terms) below. By clicking \"I agree\" (or a similar button) or by accessing or using the Developer Resources, you agree to be bound by these Terms. Introduction. Our Developer Resources help you build apps, add-ons and features that extend, augment or complement the New Relic Service (\"Apps\"). The \"Developer Resources\" are the APIs, SDKs, sample code, Developer Accounts, command line interfaces, tokens, credentials and other resources we provide as part of the Developer Program, as described on the Developer Site. The \"New Relic Service\" is our SaaS offering and related software, which we provide under separate terms (\"New Relic Terms of Service\"). How These Terms Apply. These Terms apply if you use our Developer Resources to build or manage Apps. Any use of the New Relic Service itself (including our standard tools and APIs that help you configure usage or retrieve your data) remains subject to the New Relic Terms of Service, not these Terms. Registration. To access or use the Developer Resources, you need to complete any registration or credentialing requirements established by New Relic. Use of Developer Resources. Subject to these Terms, you may use the Developer Resources to enable your Apps to interface with the New Relic Service. Your use is subject to the developer documentation currently available on the Developer Site or otherwise provided by New Relic (\"Developer Documentation\"), which is considered part of the Developer Resources. Your rights are limited, non-exclusive, non-sublicensable and non-transferable. You may permit your agents and contractors to exercise your rights on your behalf, provided you remain responsible for their compliance with these Terms. Developer Account. New Relic may offer test or sandbox accounts as part of the Developer Program (\"Developer Accounts\"), which you may use only for internal development or testing of your Apps as part of your rights in Section 4 (Use of Developer Resources). Because Developer Accounts are for development or testing purposes only, you may not use personally identifiable or production data with Developer Accounts (and no End User Data). New Relic has no security, privacy or other responsibility for data contained in Developer Accounts and may access, modify or delete such data at any time for any reason. You may not provide access to your Developer Accounts to anyone else. Developer Accounts may be subject to additional usage restrictions as set forth from time to time in the Developer Documentation. Access Limits; Compliance. New Relic may (but is not required to) monitor your use of the Developer Resources and how your Apps interact with the New Relic Service, including to ensure your compliance with these Terms. You agree to cooperate with our reasonable inquiries and, upon request, provide us with proof that your use of the Developer Resources and your Apps comply with these Terms. From time to time New Relic may also place limits on access (e.g., limits on number of API calls). Restrictions. We expect all developers to respect New Relic, end users and other third parties. In using the Developer Resources, you must comply with New Relic's Acceptable Use Policy currently available here (\"Acceptable Use Policy\"). You will not (and will not permit anyone else to): (a) use the Developer Resources except with the New Relic Service as permitted in these Terms; (b) sublicense, sell, distribute or grant third parties access to the Developer Resources, other than your agents and contractors (see Section 4) or as permitted in the Developer Documentation (e.g., distributable elements of SDKs); (c) use the Developer Resources for competitive purposes, with Apps that substantially replicate features of the New Relic Service or to circumvent any intended limitations of the New Relic Service (e.g., payment of fees or user access structures); (d) reverse engineer, modify or create derivative works of the Developer Resources; (e) access the Developer Resources through means other than the tokens and credentials we provide; (f) make calls using an App not driven by bona fide end user requests (except for reasonable testing); (g) publish benchmarks or performance information regarding the Developer Resources; (h) test the performance, bandwidth or capacity of the Developer Resources or New Relic Service or disrupt their integrity or performance; (i) transmit any viruses, illegal content or other harmful materials to the Developer Resources or New Relic end users; or (j) take any action that would subject the Developer Resources or New Relic Service to any open source licenses or other third party terms. Use of New Relic Marks. Subject to these Terms, you may use the appropriate New Relic names, logos and trademarks designated in the New Relic Trademark Guidelines currently available here (\"New Relic Marks\") to promote your App's availability for use with the New Relic Service. Your use of New Relic Marks must comply with the New Relic Trademark Guidelines and (without limiting New Relic's other termination rights) you must promptly cease any use of New Relic Marks upon notice by New Relic. You receive no other rights to New Relic Marks under these Terms. All goodwill arising from use of New Relic Marks belongs to New Relic. Your Responsibilities. You and your Apps must meet important standards related to privacy, security, business practices and user experience, as set out below. a. Your Apps and End Users. You are solely responsible, at your own expense, for your Apps (including their operation, components, integrations and support) and your relationships and agreements with end users regarding your Apps. b. Support. You will provide end users with reasonable web-based and/or email support for your Apps. You will also provide New Relic with a current email address to which New Relic may direct end user inquiries about your Apps and designate a support contact (name and email address) for New Relic. c. End User Data. An end user may enable you or your App to access certain of its data, content or information within the New Relic Service (\"End User Data\"). You may access and process End User Data only to the extent enabled by the end user and as necessary to provide your Apps to that end user. You will ensure that all End User Data is collected, processed, transmitted, maintained and used in accordance with: (i) your agreement with the end user and a legally adequate privacy policy (\"End User Terms\"), and appropriate notices to and consents from end users, (ii) all laws, rules, regulations or orders, including those relating to data privacy, data transfer, international communications or the export of technical or personal data (\"Laws\") and (iii) industry-standard technical, administrative and physical security measures that protect the security and privacy of all End User Data. New Relic is not responsible for any regulatory action or claim to which you may be subject in connection with your Apps. New Relic is also not responsible for any transmission, disclosure, modification or deletion of End User Data in the New Relic Service by, through or resulting from an App. d. Security Breaches. In case of any suspected or actual security breach affecting your App or End User Data, you must immediately notify New Relic and cooperate with New Relic to remediate the issue and mitigate its effects. You must obtain New Relic's approval for any security breach notifications to end users that refer directly or indirectly to New Relic. e. New Relic Customer Terms. Use of the New Relic Service requires each end user to have a valid subscription subject to the New Relic Terms of Service. You will not facilitate or encourage any end user to violate the New Relic Terms of Service or Acceptable Use Policy. For clarity, if New Relic receives any data from you or your Apps on an end user's behalf, such data will be subject solely to the New Relic Terms of Service with the end user, and such data will no longer be subject to your own terms with the end user. f. Fees. You may not directly or indirectly charge end users for use of, or access to, the functionality of the Developer Resources. If you charge any fees for your Apps, you are solely responsible for collecting those fees independently from New Relic and the New Relic Catalog. You are also responsible for any related refunds or liabilities to end users and for any associated end user communications under Section 13.d (End User Communications). These Terms grant you no right to distribute or resell the Developer Resources or New Relic Service. g. Your Representations and Warranties. You represent and warrant that: (i) you have full power and authority to enter into and perform these Terms and to exploit your Apps without violating any other agreement; (ii) your Apps and their use will not violate any Laws or third party rights (including intellectual property rights, and rights of privacy or publicity), and you will notify New Relic if your Apps become subject to any claim or complaint regarding violation of Laws or third party rights; (iii) all information you provide to New Relic is and will be true, accurate and complete (and you will keep such information up-to-date); and (iv) you will not interfere with New Relic's business practices or the way in which it licenses or distributes the Developer Resources or New Relic Service. You agree not to: (A) suggest any affiliation with New Relic (including that New Relic sponsors, endorses or guarantees your Apps) except for the relationship expressly contemplated in these Terms or (B) make any representations, warranties or commitments on New Relic's behalf or regarding the Developer Resources or New Relic Service. h. Indemnification. You will indemnify, defend (at New Relic's request) and hold harmless New Relic and its affiliates and their respective directors, officers, employees, agents, contractors, end users and licensees from and against any regulatory actions, claims, losses, costs, expenses (including reasonable attorneys' fees), damages or liabilities based on or arising from (i) your Apps, (ii) your relationships or interactions with any end users or third parties in connection with your Apps, or (iii) your breach or alleged breach of these Terms. New Relic may, at its own expense, participate in the defense and settlement of any claim with its own counsel, and you may not settle a claim without New Relic's prior written consent (not to be unreasonably withheld). Listings. This Section 10 applies only if you choose to submit your App for listing in the New Relic Catalog. a. Submission. To submit your App for potential listing in the New Relic Catalog, you must follow New Relic's Listing Requirements and provide: i. Your App meeting the Listing Requirements, including regarding security and coding practices, ii. Listing information, trademarks and documentation (\"Listing Materials\"), iii. End User Terms for your App, and iv. Other related materials that we reasonably request. b. Approval. New Relic may approve or reject any submitted App in its sole discretion and reserves the right to test Apps against the Listing Requirements and other security and performance criteria. You remain solely responsible for your Apps despite any New Relic approval. c. New Relic Rights. If New Relic approves your submitted App, you hereby grant New Relic a license to: i. List your App in the New Relic Catalog; ii. Copy, distribute, publicly perform and display, and create derivative works of your Listing Materials, and screenshots of your App's use with the New Relic Service, in order to market and promote your App, the New Relic Catalog and the New Relic Service (but we will not change your trademarks except for sizing and formatting); and iii. Use, host, copy, distribute, publicly perform and display your App to permit your App to operate with the New Relic Service, including by permitting End Users to enable and deploy your App with their New Relic Service accounts. New Relic's license rights are worldwide, non-exclusive, royalty-free and fully paid-up and sublicensable through multiple tiers. New Relic retains sole discretion and control over the placement, look and feel of the New Relic Catalog. d. End User Deployment. If New Relic lists your App on the New Relic Catalog, interested end users may select and deploy your App with their New Relic Service accounts. New Relic does not guarantee any end users will search for or use your App. e. End User Terms. You are responsible for your End User Terms and how you present them to end users and obtain their agreement. Your End User Terms must be consistent with your rights and obligations in these Terms (including regarding End User Data and any termination, suspension or take-down of your App), and you agree your App will not be licensed under a Copyleft License. New Relic is not a party to your End User Terms and is not responsible for how end users use your App or for enforcing your End User Terms. \"Copyleft License\" means any OSS license that seeks to require any party that uses, modifies or distributes the licensed code to make such code (or modification or derivative work thereof) or any other code that may be combined with or linked to such code available in source code form or that may impose any other obligation or restriction with respect to such party's patent or other intellectual property rights (such as, for example purposes only, any version of the GPL or LGPL, Affero, CPL, CDDL, Eclipse or Mozilla licenses). f. Take-Downs. You may request that we take-down your App from the New Relic Catalog at any time by contacting opensource+nr1-catalog@newrelic.com. We will use commercially reasonable efforts to promptly remove your App from the New Relic Catalog following receipt of your request. In addition to its other rights, New Relic may temporarily or permanently take-down any App listed in the New Relic Catalog in its discretion, without notice to you. Section 13.c (Wind-Down) will apply following any take-down pursuant to this Section 10.f. g. New Relic Catalog. \"New Relic Catalog\" means (i) the New Relic One Catalog that New Relic makes available in connection with the New Relic Service and (ii) any other App listing or catalog that New Relic makes available through its own or third party products or websites. Ownership. New Relic does not claim ownership of your Apps (other than our own technology) and you reserve all rights not expressly granted in these Terms. New Relic and its licensors retain all ownership and other rights (including all intellectual property rights) in the Developer Resources, the New Relic Service and our related technology. Providing feedback, comments, or suggestions about the Developer Program or Developer Resources (\"Feedback\") to New Relic is wholly voluntary. New Relic may freely use Feedback for any purpose. Support; Changes. New Relic has no obligation to provide maintenance or support for the Developer Resources or your Apps, or to fix any errors or defects. New Relic may change the Developer Resources from time to time as our business changes and technology evolves, and future versions of the Developer Resources may not be compatible with Apps built using previous versions. We typically make these changes as part our overall Developer Program and are unable to provide notice of the changes to developers individually. New Relic will have no liability resulting from these changes. Termination and Suspension. These Terms remain in effect until terminated. a. By Developer. Developer may terminate these Terms at any time by ceasing all use of the Developer Resources. b. By New Relic. New Relic may terminate or suspend these Terms or your access to or right to use the Developer Resources (in whole or in part): (i) for no reason or any reason upon 15 days' notice to you, (ii) immediately (A) if you breach any provision of these Terms, (B) if New Relic is required to do so by Laws, (C) if New Relic ceases offering the Developer Resources, (D) in case of any security breach or other concern under Section 9.d (Security Breaches), or (E) if New Relic otherwise determines in its discretion that such action is necessary to avoid harm, liability or reputational damage to New Relic, the Developer Resources, the New Relic Service, or any end user. For clarity, suspension may include disabling your Apps. c. Wind-Down. Following any termination of these Terms, at New Relic's request (i) the parties will cooperate to effectuate an orderly wind-down and (ii) these Terms will continue in effect for up to 90 days to enable deployed end users to continue using your Apps. d. End User Communications. In the event of any termination, suspension or take-down under this Section 13 or Section 10.f (Take-Downs), Developer remains responsible for managing its own end user relationships and communications, including as relates to any transition to alternate Developer offerings or any impact on fees, refunds or commercial terms with end users. Developer will ensure that any such end user communications are accurate and conducted in a positive and professional manner, consistent with any guidelines New Relic may provide. e. Effect of Termination. Upon any termination, subject to Section 13.c (Wind-Down) (i) your rights to use the Developer Resources and New Relic Marks will immediately terminate and you will cease all such use, (ii) you will return or destroy all Confidential Information (as requested by New Relic) and (iii) Sections 9 (Your Responsibilities), 11 (Ownership) and 13 (Termination and Suspension) through 24 (General) will survive. After termination, you will have no further access to any data or content that you submitted to New Relic relating to the Developer Resources. f. No Obligation or Liability. New Relic will have no obligation or liability resulting from termination, suspension or take-down as described in this Section 13 or Section 10.f (Take-Downs). Disclaimer of Warranties. TO THE FULL EXTENT PERMITTED BY LAW, THE DEVELOPER RESOURCES ARE PROVIDED \"AS IS\" AND \"WITH ALL FAULTS\" AND NEW RELIC AND ITS THIRD-PARTY LICENSORS DISCLAIM ALL REPRESENTATIONS, WARRANTIES AND GUARANTEES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR ANY PURPOSE. NEW RELIC MAKES NO REPRESENTATION, WARRANTY OR GUARANTEE RELATED TO RELIABILITY, ACCURACY OR COMPLETENESS OF THE DEVELOPER RESOURCES, THAT NEW RELIC WILL CONTINUE TO OFFER THE DEVELOPER RESOURCES OR THAT USE OF THE DEVELOPER RESOURCES WILL BE SECURE, TIMELY, UNINTERRUPTED, ERROR-FREE OR MEET DEVELOPER'S REQUIREMENTS OR EXPECTATIONS. You may have other statutory rights, in which case the disclaimers above will apply to the full extent permitted by law. Limitations of Liability. TO THE FULL EXTENT PERMITTED BY LAW, IN NO EVENT WILL NEW RELIC BE LIABLE (i) FOR ANY LOSS OF USE, LOST DATA, FAILURE OF SECURITY MECHANISMS, INTERRUPTION OF BUSINESS OR ANY INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND (INCLUDING LOST PROFITS OR LOST DATA), EVEN IF INFORMED OF THE POSSIBILITY OF SUCH DAMAGES IN ADVANCE OR (ii) IN ANY EVENT, FOR ANY DAMAGES OR LIABILITIES EXCEEDING ONE HUNDRED U.S. DOLLARS (\\$100), ARISING FROM OR RELATING TO THESE TERMS, USE OF THE DEVELOPER RESOURCES, YOUR APPS OR THEIR COMBINATION OR INTERACTION WITH THE DEVELOPER RESOURCES OR NEW RELIC SERVICE. NOTWITHSTANDING ANYTHING TO THE CONTRARY, NEW RELIC HAS NO WARRANTY, INDEMNIFICATION OR OTHER OBLIGATION OR LIABILITY WITH RESPECT TO YOUR APPS OR THEIR COMBINATION, INTERACTION OR USE WITH THE DEVELOPER RESOURCES OR NEW RELIC SERVICE. You acknowledge and agree that this Section 15 reflects a reasonable allocation of risk and will apply regardless of the form of action or legal theory, whether in contract, tort (including negligence), strict liability or otherwise, and that New Relic would not enter into these Terms without these liability limitations. This Section will survive even if any limited remedy fails of its essential purpose. New Relic Confidential Information. Any non-public elements of the Developer Resources and any other information disclosed by New Relic that is marked as confidential or proprietary or that should reasonably be understood to be confidential or proprietary from the circumstances of disclosure is \"Confidential Information.\" Confidential Information does not include any information that: (i) is or becomes generally known to the public; (ii) was known to you before its disclosure by New Relic; or (iii) is received from a third party, in each case without breach of an obligation owed to New Relic or anyone else. You will (A) maintain Confidential Information in confidence (using at least the same measures as for your own confidential information, and no less than reasonable care) and not divulge it to any third party and (B) only use Confidential Information to fulfill your obligations under these Terms. If you are compelled by law to disclose Confidential Information, you must provide New Relic with prior notice of such compelled disclosure (to the extent legally permitted) and reasonable assistance if New Relic wishes to contest the disclosure. If you breach or threaten breach of this Section 16, it could cause substantial harm for which damages are inadequate and New Relic will have the right to seek injunctive relief in addition to other remedies. Independent Development; Information You Provide Not Confidential. New Relic develops a variety of offerings and works with many other developers and partners, and either New Relic or these third parties could in the future develop (or already have developed) products, services, concepts or features similar to yours. Nothing limits New Relic's right to do so, though this Section itself does not grant us any license under your intellectual property rights. Unless separately set forth in another agreement, New Relic has no confidentiality obligations for information you submit in connection with the Developer Program. Usage Data. In addition to New Relic's other rights, New Relic may collect certain data and information regarding your use of the Developer Site and Developer Resources, including data about your data pulls or requests, and your Apps (\"Usage Data\"). We may use and exploit Usage Data for any purpose in connection with operating, improving and supporting the Developer Program and Developer Resources. Changes to Terms. We may change these Terms from time to time as our business changes and technology evolves. New Relic will use reasonable efforts to notify you of changes to these Terms as provided in Section 22 (Notices). You may be required to click through the modified Terms to show your acceptance and in any event your continued use of the Developer Resources after the modification constitutes your acceptance to the modifications. If you do not agree to the modified Terms, your sole remedy is to terminate your use of the Developer Resources as described in Section 13 (Termination and Suspension). Open Source Software. Certain code in the Developer Resources (e.g., SDKs) may be licensed under or include components subject to \"open source\" software terms (\"OSS\"), as listed in the Developer Documentation. The OSS licenses may grant you additional rights to the OSS code itself and allow you to use the OSS outside of our Developer Program. To be clear, though, when you use the OSS as part of our Developer Program, you must comply with these Terms. Pre-Release Versions. New Relic may make available certain Developer Resources on a pre-release or early access basis (\"Pre-Release Versions\"). Use of Pre-Release Versions may be subject to additional terms designated by New Relic. Pre-Release Versions are optional and either party may terminate use at any time for any reason. If you choose to use a Pre-Release Version, you agree to provide Feedback at our reasonable request. Pre-Release Versions may be inoperable, incomplete or include features that New Relic may never release, and their features and performance information are New Relic's Confidential Information. Notices. New Relic may provide you with notices and communications at your email or physical address on file, through the Developer Site or other reasonable means. Any notices or communications to New Relic must be sent to legal@newrelic.com or New Relic, Inc., Attention: Legal Department - Developer Terms, 188 Spear Street, Suite 1200, San Francisco, CA 94105. Export. The Developer Resources may be subject to export restrictions by the United States government and import restrictions by certain foreign governments, and you agree to comply with all applicable export and import laws and regulations in your use of the Developer Resources. You represent and warrant that you are not located in a country subject to a U.S. Government embargo, or that has been designated by the U.S. Government as a \"terrorist supporting\" country, and that you are not listed on any U.S. Government list of prohibited or restricted parties. General. These Terms are the parties' entire agreement and supersede any prior or concurrent agreements relating to its subject matter. Except as set forth in Section 19 (Changes to Terms), all amendments or modifications must be in writing and signed by both parties. The words \"including\" and similar terms are to be construed without limitation. Failure to enforce any provision is not a waiver and all waivers must be in writing. If any provision is found to be unenforceable it (and related provisions) will be interpreted to best accomplish its intended purpose. Developer may not assign, transfer or delegate any right or obligations under these Terms and any non-permitted assignment is void. New Relic may assign these Terms and its rights and obligations to any of its affiliates or in connection with a merger, reorganization, acquisition or other transfer of all or substantially all of its assets or voting securities to which these Terms relate. The parties are independent contractors and these Terms do not create any agency, partnership or joint venture. These Terms will be governed by and construed under the laws of the State of California, as applied to agreements entered into and to be performed in California by California residents. The parties consent to the exclusive jurisdiction and venue of the courts located in and serving San Francisco, California. New Relic will not be liable to Developer for any delay or failure to perform any obligation under these Terms if the delay or failure is due to unforeseen events that are beyond its reasonable control. The Developer Resources include commercial computer software. If the user or licensee of such technology is an agency, department or other entity of the United States Government, the use, duplication, reproduction, release, modification, disclosure or transfer of such technology, or any related documentation of any kind, including technical data and manuals, is restricted by these Terms in accordance with Federal Acquisition Regulation 12.212 for civilian purposes and Defense Federal Acquisition Regulation Supplement 227.7202 for military purposes. The Developer Resources were developed fully at private expense. All other use is prohibited.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.82034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " consent (not to be unreasonably withheld). Listings. This Section 10 applies only if you choose to submit <em>your</em> <em>App</em> for listing in the New Relic <em>Catalog</em>. a. Submission. To submit <em>your</em> <em>App</em> for potential listing in the New Relic <em>Catalog</em>, you must follow New Relic&#x27;s Listing Requirements and provide: i"
      },
      "id": "6091f9c828ccbc0a1da26890"
    }
  ],
  "/build-apps/ab-test/chart-group": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add user interface components to your application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "ed894ca79a689bdfbf6cff8d64273d4921872e41",
      "document_type": "page",
      "popularity": 1,
      "info": "Add user interface components to your application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 768.4214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> user interface components to your <em>application</em>",
        "sections": "<em>Add</em> user interface components to your <em>application</em>",
        "info": "<em>Add</em> user interface components to your <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>chart</em> <em>group</em>, before"
      },
      "id": "6091fb4464441f44672f36fa"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-08-03T01:49:23Z",
      "title": "Add tables",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92a3d84ceeaa19bbf11078ee56dc0ce7baa85ae2",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tables",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 658.0007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> tables",
        "sections": "<em>Add</em> tables",
        "info": "<em>Add</em> tables",
        "body": " looking at a code sample. This practice will reinforce what you&#x27;ve learned in this lesson. If you need help, review the <em>add</em>-a-<em>chart</em>-<em>group</em> directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each <em>chart</em> you’ll <em>add</em>"
      },
      "id": "6091fb4464441f40c02f3741"
    },
    {
      "sections": [
        "Tutorial on user management tasks: access grants, custom roles, and adding users (New Relic One user model)",
        "Requirements",
        "Overview",
        "View available accounts",
        "Grant access to accounts and roles",
        "Create custom role",
        "Add users"
      ],
      "title": "Tutorial on user management tasks: access grants, custom roles, and adding users (New Relic One user model)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One user management"
      ],
      "external_id": "b1e5f303b6446f264c9d8c5020871a6990e052fd",
      "image": "https://docs.newrelic.com/static/a78dad5ff794da5deaaf3b514e334ea7/c1b63/new-relic-one-user-mgmt.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/tutorial-add-new-user-groups-roles-new-relic-one-user-model/",
      "published_at": "2021-08-02T13:23:30Z",
      "updated_at": "2021-08-02T13:23:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial will walk you through some common procedures for managing users on the New Relic One user model. Requirements Some notes on who this tutorial is for and requirements: This tutorial is for users on our New Relic One user model. Creating access grants requires Pro or Enterprise edition. For details, see user management requirements. Role requirements: Using the Organization and access UI to manage group access requires Authentication domain manager and Organization manager roles. Using the User management UI to add/edit users requires Authentication domain manager role. Overview Before using this tutorial, we first recommend reading these docs: Where to find the user management UI Understand what an access grant is This tutorial will walk you through how to: View available accounts How to grant groups access to roles and accounts How to create custom roles How to add users to groups View available accounts Understanding the accounts in your New Relic organization is important for creating access grants, because you must choose accounts to grant users access to. To view the accounts in your organization: go to the account dropdown, click Administration, click Organizations and access, and then click Accounts. Grant access to accounts and roles Groups are used to group your users and manage what your users are able to do in New Relic: by creating an access grant, you assign a group access to a) a specific role on b) a specific account. By default, organizations on the New Relic One user model have two available groups: Admin and User. These default groups automatically have access to specific standard roles and are assigned to the account in which they were initially added. To view existing access grants: from the account dropdown, click Administration, and then click Organization and access. Even if you haven't created any custom access grants, you will see the default-created grants there that are present for our default groups. This is what you might see when you go to the Organization and access UI and view groups. The default available groups of Admin and User have access grants automatically created that grant users in those groups access to the roles associated with those groups and to the initial account those users were added in. To create a new access grant that gives a user group access to a role and an account: From the Organization and access UI, click Group access. If you don't see that UI, it may be because you're logged in with an original user model record, or because you don't have the ability to manage users. For more on such factors, see Factors affecting access. Choose one of the following: Existing: If there is already a group you want to add an access grant to, you can use this. For example, if you want to gives users in the default Admin or User group access to new accounts, you might choose this and then select the Admin Default or Admin User role. New: If you need to create a new group, choose this. You'll also need to choose the authentication domain that group is inside of (for an explanation of what \"Default\" means, see Default groups. If your organization strategy requires a good amount of restrictions over access to accounts and access to roles, you'll probably need to create a good amount of access grants. Next, under Access grant, you'll choose one of following: Account: Choose this to be able to select from the roles that are account-scoped. These are the roles that have to do with using and configuring our platform features (and not about organization and user management). Organization: Choose this to be able to select from the roles that are organization-scoped. These are the roles that govern organization- and user management. (Note that these users must also already belong to an account-scoped role. This is true for most users but if it's not, you may see a message that the user doesn't belong to an organization.) Select the Role you want to assign. Roles are organization-wide, so regardless of the authentication domain you're in, you have access to our standard roles and any custom roles you've created. For tips on selecting roles, see the tips after these instructions. Select the Account you want to add access to from the dropdown. If you don't see an account that you'd expect to see, this may be for a few reasons. One is that you yourself don't have the proper permissions for that account. Another is that that account is not actually in your organization. For more information, see Factors affecting access. If you are still having problems, talk to your account representative. If you want to continue adding more grants for that same group, select Add another at the bottom before clicking Add access. When you're done, if your users are already in the group you've added the grant to, they should now have access. If your users are not yet in that group (which would be true if you just created an access grant with a new group), you'll need to go to the User management UI and add that group to those users. Some tips for using this UI: Note that if a user has the organization-scoped Organization manager and/or Authentication domain manager roles, which is true of users in the default Admin group, those users will always have those capabilities because those are organization-scoped abilities. This means that when you go to add those users to another account, you only have to add an account-scoped role, and not an organization-scoped role. In other words, once the users in a group have those organization-scoped roles, they will always have them in that organization unless removed. When selecting from amongst our standard roles, it's important to understand the difference between All product admin and Standard user. In short, All product admin is more popular a choice because it gives the ability to configure platform features. If you wanted to have your users be able to use platform features but not configure them, you'd choose Standard user. If your users are managed via automated user management, there are some restrictions that may apply. For example, you wouldn't be able to use the User management UI to add users to groups, because groups are managed and imported from your identity provider. If a group has basic users in it, their basic user status overrides any group-related restrictions. Create custom role When creating an access grant, you can use our standard roles, or you can create your own roles with unique sets of capabilities. To view existing roles: from the account dropdown, click Administration, then click Organization and access, and then click Roles. To create a custom role, click Add new custom role. Note that there are some hidden capabilities that are not available for adding to a custom role. For details, see Capabilities. To learn more about how roles and groups relate, see User management concepts. Add users If you've created a new group, you must make sure that the users are added to that group. If users don't have the group assigned, no access will be granted. To view or manage users: from the account dropdown, click Administration, and click User management. If you don’t see that option, review the requirements. Groups reside within the boundaries of an authentication domain. If your organization has more than one authentication domain, the domain switcher in the top left will show which one you’re in. To add a user, click Add user. Complete the prompts in the UI, including choosing the user type and group. Any custom groups you’ve added should be available from the group dropdown. If the custom group you choose has been granted access to a role and an account, once you add the user to that group, that user will now have access. To edit a user’s group or other details: click on the user you want to edit and make changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tutorial on user management tasks: <em>access</em> grants, custom roles, <em>and</em> <em>adding</em> users (New Relic One user model)",
        "sections": "Tutorial on user management tasks: <em>access</em> grants, custom roles, <em>and</em> <em>adding</em> users (New Relic One user model)",
        "tags": "<em>Accounts</em>",
        "body": ". For details, see user management requirements. Role requirements: Using the Organization and access UI to manage <em>group</em> access requires Authentication domain manager and Organization manager roles. Using the User management UI to <em>add</em>&#x2F;edit users requires Authentication domain manager role. Overview"
      },
      "id": "603e7d67196a671e26a83dc5"
    },
    {
      "sections": [
        "Outlier detection (NRQL alert)",
        "Important",
        "What is outlier detection?",
        "Tip",
        "Example use cases",
        "Notify if load-balanced servers have uneven workload",
        "Notify if load-balanced application has misbehaving instances",
        "Notify of changes in different environments",
        "Notify for timezone-related changes",
        "Create an outlier alert condition",
        "Rules and logic",
        "Details about alert condition logic",
        "NRQL query rules and limits",
        "Zero values for unreturned data"
      ],
      "title": "Outlier detection (NRQL alert)",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "d885dd3294ee7e40b1aac6d45feebb6fb85f490f",
      "image": "https://docs.newrelic.com/static/f235d0630576bc2010ff07adc7a69621/f73a1/NRQL_outlier_violations.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/outlier-detection-nrql-alert/",
      "published_at": "2021-08-02T23:55:46Z",
      "updated_at": "2021-08-02T23:55:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts offers NRQL conditions in three threshold types: static, baseline, and outlier. This document explains how the outlier threshold type works, gives some example use cases and NRQL queries, and explains how to create an outlier condition. Important NRQL alerts do not affect Alerts policies for a Synthetic monitor. For example, muting a NRQL alert will not mute a Synthetic monitor's alerts. What is outlier detection? In software development and operations, it is common to have a group consisting of members you expect to behave approximately the same. For example: for servers using a load balancer, the traffic to the servers may go up or down, but the traffic for all the servers should remain in a fairly tight grouping. The NRQL alert outlier detection feature parses the data returned by your faceted NRQL query and: Looks for the number of expected groups that you specify Looks for outliers (values deviating from a group) based on the sensitivity and time range you set Additionally, for queries that have more than one group, you can choose to be notified when groups start behaving the same. This visual aid will help you understand the types of situations that will trigger a violation and those that won't. For more on the rules and logic behind this calculation, see Outlier detection rules. Tip Note: this feature does not take into account the past behavior of the monitored values; it looks for outliers only in the currently reported data. For an alert type that takes into account past behavior, see Baseline alerting. Example use cases These use cases will help you understand when to use the outlier threshold type. Note that the outlier feature requires a NRQL query with a FACET clause. Notify if load-balanced servers have uneven workload A load balancer divides web traffic approximately evenly across five different servers. You can set a notification to be sent if any server starts getting significantly more or less traffic than the other servers. Example query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Notify if load-balanced application has misbehaving instances Application instances behind a load balancer should have similar throughput, error rates, and response times. If an instance is in a bad state, or a load balancer is misconfigured, this will not be the case. Detecting one or two bad app instances using aggregate metrics may be difficult if there is not a significant rise in the overall error rate of the application. You can set a notification for when an app instance’s throughput, error rate, or response time deviates too far from the rest of the group. Example query: SELECT average(duration) FROM Transaction WHERE appName = 'MY-APP-NAME' FACET host Copy Notify of changes in different environments An application is deployed in two different environments, with ten application instances in each. One environment is experimental and gets more errors than the other. But the instances that are in the same environment should get approximately the same number of errors. You can set a notification for when an instance starts getting more errors than the other instances in the same environment. Also, you can set a notification for when the two environments start to have the same number of errors as each other. Notify for timezone-related changes The number of logged in users for a company is about the same for each of four applications, but varies significantly by each of the three time zones the company operates in. You can set a notification for when any application starts getting more or less traffic from a certain timezone than the other applications. Sometimes the traffic from the different time zones are the same, so you would set up the alert condition to not be notified if the time zone groups overlap. For more details on how this feature works, see Outlier rules and logic. Create an outlier alert condition To create a NRQL alert that uses outlier detection: When creating a condition, under Select a product, select NRQL. For Threshold type, select Outlier. Create a NRQL query with a FACET clause that returns the values you want to alert on. Depending on how the returned values group together, set the Number of expected groups. Adjust the deviation from the center of the group(s) and the duration that will trigger a violation. Optional: Add a warning threshold and set its deviation. Set any remaining available options and save. Rules and logic Here are the rules and logic behind how outlier detection works: Details about alert condition logic After the condition is created, the query is run once every harvest cycle and the condition is applied. Unlike baseline alerts, outlier detection uses no historical data in its calculation; it's calculated using the currently collected data. Alerts will attempt to divide the data returned from the query into the number of groups selected during condition creation. For each group, the approximate average value is calculated. The allowable deviation you have chosen when creating the condition is centered around that average value. If a member of the group is outside the allowed deviation, it produces a violation. If Trigger when groups overlap has been selected, Alerts detects a convergence of groups. If the condition is looking for two or more groups, and the returned values cannot be separated into that number of distinct groups, then that will produce a violation. This type of “overlap” event is represented on a chart by group bands touching. Because this feature does not take past behavior into account, data is never considered to \"belong\" to a certain group. For example, a value that switches places with another value wouldn't trigger a violation. Additionally, an entire group that moves together also wouldn't trigger a violation. NRQL query rules and limits The NRQL query must be a faceted query. The number of unique values returned must be 500 or less. If the query returns more than this number of values, the condition won't be created. If the query later returns more than this number after being created, the alert will fail. Zero values for unreturned data When a query returns a set of values, only values that are actually returned are taken into account. If a value is not available for calculation (including if it goes from being collected one harvest cycle to not being collected), it is rendered as a zero and is not considered. In other words, the behavior of unreturned zero values will never trigger violations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.12541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Outlier detection (NRQL <em>alert</em>)",
        "sections": "Outlier detection (NRQL <em>alert</em>)",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> Intelligence",
        "body": " on. Depending on how the returned values <em>group</em> together, set the Number of expected groups. Adjust the deviation from the center of the <em>group</em>(s) and the duration that will trigger a violation. Optional: <em>Add</em> a warning threshold and set its deviation. Set any remaining available options and save. Rules"
      },
      "id": "604409a728ccbc11e42c607a"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-08-03T00:36:50Z",
      "updated_at": "2021-07-27T21:14:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also duplicate your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.08475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, <em>add</em>, <em>and</em> share dashboards <em>and</em> <em>charts</em>",
        "sections": "Import, export, <em>add</em>, <em>and</em> share dashboards <em>and</em> <em>charts</em>",
        "tags": "<em>Charts</em>",
        "body": " features. Also, in a given dashboard, to <em>add</em> content: Click the edit button at the top right corner, then create new content by clicking the <em>Add</em> widget button. <em>Add</em> a new <em>chart</em> using the query builder, or <em>add</em> text, images, or links using our markdown editor. Use the + <em>Add</em> to your dashboard button"
      },
      "id": "60e5877828ccbc77861881cc"
    }
  ],
  "/build-apps/ab-test/pie-charts": [
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-08-03T01:49:23Z",
      "title": "Add tables",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92a3d84ceeaa19bbf11078ee56dc0ce7baa85ae2",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tables",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 461.15625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> tables",
        "sections": "<em>Add</em> tables",
        "info": "<em>Add</em> tables",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>pie</em> <em>charts</em>, before"
      },
      "id": "6091fb4464441f40c02f3741"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/",
      "sections": [
        "Add your first chart",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add your first chart",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "292725b4d7883e56c1178913f21337d18b92133c",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your first chart",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart components to your A/B test application, before starting this one. In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add pie charts.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 436.94086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> your first <em>chart</em>",
        "sections": "<em>Add</em> your first <em>chart</em>",
        "info": "<em>Add</em> your first <em>chart</em>",
        "body": " for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another <em>chart</em> type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>pie</em> <em>charts</em>."
      },
      "id": "6091faf164441f0f032f3727"
    },
    {
      "sections": [
        "Use your charts",
        "Change the appearance of your chart",
        "Customize your charts",
        "Tip",
        "Format date and time",
        "Customize the Y axis",
        "Enable or disable the legend",
        "Remove the other groups facet",
        "More chart-specific features",
        "Chart share and view options"
      ],
      "title": "Use  your charts ",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Use charts"
      ],
      "external_id": "947a92d0243924f412fedb47bcb95dc40ec953fb",
      "image": "https://docs.newrelic.com/static/9bd74f30a31df0cb0ab112a325296b92/59415/crop-cb-chart-menu-tooltip_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/use-your-charts/",
      "published_at": "2021-08-03T00:43:02Z",
      "updated_at": "2021-07-21T13:02:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Once you've created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using the data explorer to specify data, the query builder analyzes your data and applies a chart type that fits your data. For some queries, you'll have several options of chart types to choose from. To change chart type, use the Chart type menu to the right of the current chart. Each type in the list has a tooltip with information about using that type. Example of the chart type menu, showing a tooltip. Customize your charts While we try our best to optimize how we display your data, sometimes you may have other needs. To this end, you can customize charts to display information at your convenience. Tip Customizations are available depending on the chart type. Format date and time Tip For table and billboard charts. Customize the date and time format for tables and billboards: for each type of data, you can select if you want to leave it as it is, or modify the format as Numeric or Date. If data is a timestamp, you can choose how to represent the date and time: For numbers, select if you want us to auto-format them, or chose the number of decimals you want to see. Customize the Y axis Tip For line and area charts. On line charts and area charts you can adjust the Y axis to display the data within certain values by setting a minimum and maximum value for the axis. If no customization option is selected, dashboards automatically displays the full Y axis from 0 to the top value plus a margin. Enable or disable the legend Tip For line and area charts, and histograms. For line charts, area charts, and histograms, you can disable or enable the legend. Remove the other groups facet Tip For bar and pie charts, and tables. When faceting on bar charts, pie charts, or tables, and if the number of faceting on queries is larger than 2,000, the Other groups facet aggregates the rest of facets. With this customization you can select whether to see Other groups, or remove it. More chart-specific features For more chart type-specific features, see Chart types. Chart share and view options Most charts have various options, including a chart-embed option, getting a chart as an image, and adding a chart to a dashboard. To read about general chart options, see Basic UI features.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.45459,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use  your <em>charts</em> ",
        "sections": "Use your <em>charts</em>",
        "tags": "Use <em>charts</em>",
        "body": "Once you&#x27;ve created a <em>chart</em>, you can customize the appearance of it to best present the data. You can share a <em>chart</em> in different formats and <em>add</em> a <em>chart</em> to a new or existing dashboard. Change the appearance of your <em>chart</em> When you run your query in advanced (NRQL) mode or view your <em>chart</em> while using"
      },
      "id": "603ec29a196a67ef5da83d82"
    },
    {
      "image": "https://docs.newrelic.com/static/36ca4a14c623097dc63387c4023720ad/c1b63/chart_area.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/chart-types/",
      "sections": [
        "Chart types",
        "Area chart",
        "Bar chart",
        "Billboard",
        "Tip",
        "Bullet chart",
        "Funnel",
        "Heat map",
        "Histogram",
        "JSON",
        "Line",
        "Pie chart",
        "Pie chart percentage problem",
        "Table"
      ],
      "published_at": "2021-08-03T00:41:56Z",
      "title": "Chart types",
      "updated_at": "2021-07-21T10:57:59Z",
      "type": "docs",
      "external_id": "09f7d709ab07ae6010d85b21deb2e63a56c9bca6",
      "document_type": "page",
      "popularity": 1,
      "body": "When building a query using the query builder, there are a variety of types of visualizations for presenting your data in the optimal format. This table contains all chart types. Whether a chart type is available for your query will be dependent on: The type of query (some query results don't match some chart types) The query mode (basic or advanced) Area chart An area chart shows a time series for a single attribute. The area chart type shows a time series for a single attribute. To enable an area chart, add a FACET to your query. You can use facet to add up to five attributes, separated by commas. Use the TIMESERIES function when you use a FACET in an NRQL query. Use an area chart when you want to View the measurement of a single attribute over a period of time that you specify. Avoid an area chart when you want to View a chart that contains more than a single attribute. The line chart type is a good option; you can view multiple attributes over a time range that you specify. The bar chart type gives you a comparison view between the attributes; it uses a total of each attribute for the time range you choose. Bar chart The bar chart shows comparisons among the categories returned in the query results. The bar chart compares a related set of values. To enable a bar chart, add a FACET clause to the query. You can use FACET with up to 5 different attributes, separated by commas. Use a bar chart when you want to Create a chart that reports the total count of the data for a category over the specified time range. With the bar chart format, you can easily see the differences between each category. Avoid a bar chart when you want to Include measurements over a period of time. This chart type is not available when using a TIMESERIES clause. The line chart type is a good option for this visualization. Billboard The billboard chart type presents results as a single, highly-visible value. It's an option when your query returns a single number, such as from this query: SELECT uniqueCount(session) FROM PageView since 1 day ago Copy A billboard chart is useful for single-stat queries like the Apdex function. Use billboards to monitor values at a glance. Billboards can also be used to compare a single value across states. For instance, use the COMPARE WITH clause to compare the same attribute across two different time frames. The billboard chart displays a single value in a large, easy to read font. To enable the data for a billboard chart, search for a single value. You can view multiple values by adding a facet from the dropdown. You can set Warning and Critical thresholds on billboards, which will highlight a chart in yellow or red. The threshold fields are on the right side of the chart edit pane, highlighted in yellow and red respectively. If you want to highlight a chart when a value falls below a given value rather than above it, set the Warning threshold higher than the Critical threshold. Tip Threshold fields will only be available for dashboards that present a single value. For instance, the use of a COMPARE WITH clause will disable the threshold settings in the edit pane. Use a billboard chart when you want to Monitor values, including thresholds for Critical and Warning states, in a large, easy-to-read font. Avoid a billboard chart type when You want to view data over a period of time. The line chart type is a better option for viewing data by time. Bullet chart Use the bullet chart type to represent progress to a target or goal, called the limit. To use this chart type, run a query that returns a single number, such as: SELECT uniqueCount(session) FROM PageView SINCE 1 day ago Copy The bullet chart displays a value compared against a limit. Bullet defaults to a limit that is twice the resulting query value. To adjust the limit, use the Limit field to enter another number. The bullet will adjust accordingly. Tip The bullet chart type can only be used for charts that present a single value. For example, a query using COMPARE WITH will not list bullet as an option. Use a bullet chart when you want to View a chart uses a large, easy-to-read font that helps you view the value quickly. Avoid a bullet chart when you want to View data that has more than a single value. Bar and line chart types may be better choices in this instance. Funnel Use funnels to evaluate a series of related data types that make up the steps toward a specified goal. A funnel allows you to ask, “Of the people that did (A), how many also did (B), and of the people that did (A) and (B), how many also completed (C)?” Sample funnel chart for a shopping site. In this example, you want to determine that of all the visitors that viewed the landing page, how many of them: Browsed the products. Then added one or more products to a shopping cart. And finally, purchased the item(s) in the shopping cart. Unlike other queries, you must use a SELECT funnel() statement in your query; the funnel chart type is not selectable from any other type of query. Additionally, the funnel chart type is only available for queries with eight steps or fewer. A funnel query that includes more than eight steps will only return the results as JSON. SELECT funnel(session, WHERE pageUrl like '%/index.html' AS 'Landing', WHERE pageUrl LIKE '%/browse/phones' AS 'Browse ', WHERE pageUrl LIKE '%/shoppingcart' AS 'Cart', WHERE pageUrl LIKE '%/checkout' AS 'Purchased') FROM PageView where appName = 'WebPortal' AND duration < 1 SINCE 1 week ago Copy Use a funnel when you want to You want to visually evaluate the paths that visitors take after they hit a page that you designate as a landing page. Avoid a funnel when you want to You only want counts for the attributes in the WHERE clause. You will not be able to choose funnel unless you use SELECT funnel in your query. Heat map The heat map displays data in a tabular format using color gradations to show frequency in specific time buckets. The heat map is a faceted distribution of values where color density represents the values displayed. To enable a heat map, use the Histogram() function with a numeric attribute and use FACET to add up to five attributes, separated by commas. See Histograms: View data distribution for more detailed information about histogram-based charts. Use a heat map when you want to View tabular data for multiple attributes over a period of time, with gradated colors instead of numerals. Avoid a heat map when you want to View the exact data for multiple attributes over a period of time. A line or bar chart may be an option. Histogram A histogram charts frequency across a series of value ranges. Use histograms to show the distribution of data across time buckets. See Histograms: View data distribution for more detailed information about histogram-based charts. Use a histogram when you want to Chart frequency of data over a series of values. Avoid a histogram when you want to View the same data as heat map or to view the data without the time buckets. JSON Use the returned JSON to review the raw data returned and to help develop integrations with New Relic. To implement integrations, use remote queries to return raw JSON as a service. To use this, select the Share menu and click Copy JSON. Example NRQL query: SELECT uniqueCount(name) FROM Transaction WHERE httpResponseCode = '200' TIMESERIES FACET appName LIMIT 10 SINCE 24 hours ago Copy Example JSON response: { \"metadata\": { \"contents\": { \"messages\": [], \"timeSeries\": { \"messages\": [], \"contents\": [ { \"function\": \"uniquecount\", \"attribute\": \"name\", \"simple\": true } ] }, \"bucketSizeMillis\": 1800000 }, \"eventTypes\": [ \"Transaction\" ], \"eventType\": \"Transaction\", \"openEnded\": true, \"messages\": [], \"beginTimeMillis\": 1556226069396, \"endTimeMillis\": 1556312469396, \"beginTime\": \"2019-04-25T21:01:09Z\", \"endTime\": \"2019-04-26T21:01:09Z\", \"guid\": \"5238a2c6-328d-a5ff-9185-7f3f04c42d1e\", \"routerGuid\": \"1aea2ec5-0be8-3a60-7554-851e1b016eb0\", \"rawSince\": \"24 HOURS AGO\", \"rawUntil\": \"NOW\", \"rawCompareWith\": \"\", \"facet\": \"appName\", \"offset\": 0, \"limit\": 10 }, \"facets\": [ { \"name\": \"RPM Combined Production\", \"beginTimeSeconds\": 0, \"endTimeSeconds\": 0, \"timeSeries\": [ { \"results\": [ { \"uniqueCount\": 415 } ], \"beginTimeSeconds\": 1556226069, \"endTimeSeconds\": 1556227869, \"inspectedCount\": 4589471 }, [ { \"uniqueCount\": 1714 } ], \"beginTimeSeconds\": 1556310669, \"endTimeSeconds\": 1556312469, \"inspectedCount\": 53341469 } ], \"total\": { \"results\": [ { \"uniqueCount\": 2651 } ], \"beginTimeSeconds\": 0, \"endTimeSeconds\": 0, \"inspectedCount\": 5053841114 } }, \"performanceStats\": { \"inspectedCount\": 6088068932, \"responseTime\": 8077 } } ... Copy Line A line chart is useful for spotting trends over time. The line chart plots a timeseries for an attribute. When working in basic query mode, select a single attribute you can plot over time. When using NRQL, SELECT one or more attributes you can plot over time and then use the TIMESERIES function. Use a line chart when you want to Create a chart that lets you easily view trends over a specified time frame. Avoid a line chart when you want to View your data using one or more attributes and see the values associated with each attribute. A bar or table chart is an option. Pie chart A pie chart is the graphic representation of the table. It appears as an option for some functions when the FACET clause is used. To use this chart type, run a query that returns one value for each of a set of attributes. The pie chart maps a set of values as a portion of a whole. To enable pie chart, add a FACET from the dropdown. You can add only one FACET in basic query mode. If you're using NRQL, you can use FACET to add up to 5 attributes, separated by commas, and also include the TIMESERIES function. Pie charts are unavailable for the following aggregator functions: average, apdex, min, max, percentage, and percentile. For uniqueCount, percentages may add up to more than 100%. Use a pie chart when you want to Create a chart that that graphically presents a set of values as they relate to a whole. A pie chart is effective for displaying values for a time period, for example. Avoid a pie chart when you want to Present data that does not use values as they related to a whole, such as with line charts. Pie chart percentage problem When using a pie chart with the uniqueCount aggregator function, the percentages can add up to more than 100%. This is because the attributes being uniquely counted may be present in multiple facets. For example, in the query SELECT uniqueCount(user) FROM PageView FACET appName, a single unique user may use multiple apps. Each of these users are included in the unique value for each of the appropriate facets (apps), but the total number of unique users won't change. To solve this, use a bar chart or table to provide a more accurate visualization of uniqueCount data. Table A table is the standard view for a set of values related to a specific attribute (for example, the count of all page views by user agent name). By default, all tables are sortable by any one column. If you are using the FACET clause, the results will normally be returned as a table. Other features of tables: You can use a table as a shortcut to other dashboards. If a table is faceted by attribute, selecting an entry takes you to an existing dashboard filtered by that attribute. You can export a table chart to a CSV file. Details on this functionality: If a filter is applied to a dashboard, the download will only include the subset of data based on the filter. If a specific fixed time range is selected, the CSV includes the data for that time period. If you query with multiple attributes, the export includes columns for all FACETs in the query. For charts with a time range dependent on the present moment (for example, since 30 minutes ago), the data in the CSV is generated from the present moment, not from when the chart was initially generated. The table chart type, with its tabular format, works well for dashboards, as well as sharing the data for use in reports, for example. Use a table when you want to Create a text-compatible table consisting of your data. This table can be shared and used in reports or imported into spreadsheets, for example. Avoid a table when you want to View your data in a graphical format.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.9931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Chart</em> types",
        "sections": "<em>Pie</em> <em>chart</em>",
        "body": " to a whole, such as with line <em>charts</em>. <em>Pie</em> <em>chart</em> percentage problem When using a <em>pie</em> <em>chart</em> with the uniqueCount aggregator function, the percentages can <em>add</em> up to more than 100%. This is because the attributes being uniquely counted may be present in multiple facets. For example, in the query SELECT"
      },
      "id": "6097bec5196a671044d52a6e"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-08-02T03:52:39Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.0856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "|legal|trophy|<em>pie</em>-<em>chart</em>|sliders|paper-plane|life-ring|heart&quot;, &quot;grid_column_count&quot;: 3|12, &quot;visibility&quot;: &quot;owner|all&quot;, &quot;editable&quot;: &quot;read_only|editable_by_owner|editable_by_all&quot;, &quot;filter&quot;: { &quot;event_types&quot;: [ &quot;Transaction&quot; ], &quot;attributes&quot;: [ &quot;appName&quot; ] }, &quot;widgets&quot;: [ { &quot;visualization&quot;: &quot;billboard|gauge"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    }
  ],
  "/build-apps/ab-test/demo-setup": [
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 790.4448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground <em>up</em>. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>"
      },
      "id": "6091faf1196a6714b4d52a39"
    },
    {
      "image": "https://developer.newrelic.com/static/1b7d6942b8c3c73de370700d4bcf1bbf/0086b/ab-test.png",
      "url": "https://developer.newrelic.com/ab-test/",
      "sections": [
        "Build an A/B test application",
        "Course"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Build an A/B test application",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "cd5dbe8eeef34d9b730fad359e6ffeed530ef310",
      "document_type": "page",
      "popularity": 1,
      "body": "Imagine you've developed a website and instrumented it with New Relic's Browser monitoring. New Relic's core feature set provides a lot of information, but you want something custom. You want to decide if a new design for your site will better engage your users. In other words, you want to A/B test a design and make a decision based on the data. For this task, you could create a New Relic One application, using React, the New Relic One software development kit, and the limitless power of modern web technologies. New Relic One applications are built with one of web development's most popular JavaScript libraries: React. Because you have freedom when writing React code, you can customize your app logic, design your own components, or take advantage of the abundance of open source component libraries. So, for your A/B test app, if you want to write custom logic to end the test based on results, you can do so. The New Relic One software development kit (SDK) allows you to create, serve, publish, and deploy applications to New Relic One. It also provides a host of React components for gathering data, presenting information, handling user interactions, and more. You use components like Button and Dropdown to create an interactive experience that looks and feels native to New Relic. You use Table and Chart components to display data from your New Relic account or elsewhere. When building your A/B test application, you'd use the SDK's NrqlQuery component to fetch Browser data from your account. With custom React code, SDK components, and the wide world of open source libraries, you can create your A/B test application in New Relic One. But before you create one for yourself, you might want to check the app catalog to see if someone has beaten you to it! If the catalog already had an app for that, you could add it to your account with a couple clicks, another benefit of creating apps in New Relic One. Throughout this course, you’re going to build a real-world New Relic One application for running and managing A/B tests. You’ll visualize Browser data for your competing designs, see historical data from past tests, and even choose a winning design and end the test, all from your New Relic One application! But before you get into the weeds of building charts and making http requests, you need to learn what New Relic One applications are made of. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the first lesson: Spin up your demo services.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 772.6972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is part of a course that teaches you how to build a New Relic One application from the ground <em>up</em>. Continue on to the first lesson: <em>Spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>."
      },
      "id": "6091faf1e7b9d24f885068c6"
    },
    {
      "sections": [
        "Docker container for infrastructure monitoring",
        "What you need",
        "Custom setup (recommended)",
        "Docker CLI",
        "Docker Compose",
        "Basic setup",
        "Required container privileges",
        "Next steps after install",
        "Inventory collected",
        "Container data",
        "Containerized agent image",
        "Check the source code"
      ],
      "title": "Docker container for infrastructure monitoring",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Install the infrastructure agent",
        "Linux installation"
      ],
      "external_id": "022f4fba474d662414d9542a107d4d8a30d24895",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/linux-installation/docker-container-infrastructure-monitoring/",
      "published_at": "2021-08-02T23:06:09Z",
      "updated_at": "2021-08-02T23:06:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The infrastructure monitoring agent for Linux supports Docker environments by default. If you're running a container OS or have restrictions that require deploying the agent as a container, you can run a containerized version of our infrastructure monitoring agent. This can monitor metrics for the container itself, as well as the underlying host. Using the custom (recommended) or basic setup allows the infrastructure agent to run inside a container environment. A host can only run one instance of the agent at a time, whether that's the containerized agent or the non-containerized version. What you need The containerized version of the infrastructure agent requires Docker 1.12 or higher. The container must run any of the Linux distributions and versions supported by our agent. The container image is available and supported on AMD64 and ARM64 architectures. The log forwarder is not included with the containerized agent. We recommend installing the agent on the underlying host which provides all capabilities. Custom setup (recommended) The following are basic instructions for creating a custom Docker image on Linux. This allows you to deploy the infrastructure agent as a container that can monitor its underlying host. Recommendation: Extend the newrelic/infrastructure image, and use your own newrelic-infra.yml agent config file. Once your image is built, you can easily spin up a container without having to provide more launch time configurations. Do not provide secrets using environment variables with Docker. Docker CLI Create the newrelic-infra.yml agent config file with your New Relic license key. For config option explanations, see configuration settings. license_key: YOUR_LICENSE_KEY Copy Create the Dockerfile extending the newrelic/infrastructure image, and add your config to /etc/newrelic-infra.yml: FROM newrelic/infrastructure:latest ADD newrelic-infra.yml /etc/newrelic-infra.yml Copy Build and tag your image: docker build -t YOUR_IMAGE_NAME . Copy Run the container from the image you built with the required required run flags: docker run \\ -d \\ --name newrelic-infra \\ --network=host \\ --cap-add=SYS_PTRACE \\ --privileged \\ --pid=host \\ -v \"/:/host:ro\" \\ -v \"/var/run/docker.sock:/var/run/docker.sock\" \\ YOUR_IMAGE_NAME Copy For potential next steps, like how to see data in the UI, see What's next? Docker Compose Create a folder to store the configuration files: mkdir ~/newrelic-infra-setup Copy Change directory to the one you've just created: cd ~/newrelic-infra-setup Copy Create the newrelic-infra.yml agent config file with your New Relic license key. For config option explanations, see configuration settings. echo \"license_key: YOUR_LICENSE_KEY\" > newrelic-infra.yml Copy Create the newrelic-infra.dockerfile extending the newrelic/infrastructure image, and add your config to /etc/newrelic-infra.yml: touch newrelic-infra.dockerfile Copy vim newrelic-infra.dockerfile #you can use any text editor Copy Put the following content in the file: FROM newrelic/infrastructure:latest ADD newrelic-infra.yml /etc/newrelic-infra.yml Copy Create docker-compose.yaml: touch docker-compose.yaml Copy vim docker-compose.yaml #you can use any text editor Copy Put following content in the file: version: '3' services: agent: container_name: newrelic-infra build: context: . dockerfile: newrelic-infra.dockerfile cap_add: - SYS_PTRACE network_mode: host pid: host privileged: true volumes: - \"/:/host:ro\" - \"/var/run/docker.sock:/var/run/docker.sock\" restart: unless-stopped Copy Build and start docker-compose: docker-compose -f docker-compose.yaml up -d Copy For potential next steps, like how to see data in the UI, see What's next? Basic setup To use the basic setup with a base New Relic infrastructure image: Docker CLI Run the container with the required run flags: docker run \\ -d \\ --name newrelic-infra \\ --network=host \\ --cap-add=SYS_PTRACE \\ --privileged \\ --pid=host \\ -v \"/:/host:ro\" \\ -v \"/var/run/docker.sock:/var/run/docker.sock\" \\ -e NRIA_LICENSE_KEY=YOUR_LICENSE_KEY \\ newrelic/infrastructure:latest Copy For potential next steps, like how to see data in the UI, see What's next? Docker Compose Create docker-compose.yaml: touch docker-compose.yaml Copy vim docker-compose.yaml #you can use any text editor Copy Put following content in the file: version: '3' services: agent: container_name: newrelic-infra image: newrelic/infrastructure:latest cap_add: - SYS_PTRACE network_mode: host pid: host privileged: true volumes: - \"/:/host:ro\" - \"/var/run/docker.sock:/var/run/docker.sock\" environment: NRIA_LICENSE_KEY: \"YOUR_LICENSE_KEY\" restart: unless-stopped Copy Build and start docker-compose: docker-compose -f docker-compose.yaml up -d Copy For potential next steps, like how to see data in the UI, see What's next? Required container privileges Due to resource isolation from the host and other containers via Linux namespaces, a container has a very restricted view and control of its underlying host's resources by default. Without these extra privileges, the infrastructure agent cannot monitor the host and its containers. The infrastructure agent collects data about its host using system files and system calls. For more information about how the infrastructure agent collects data, see our documentation about infrastructure monitoring and security. Required privileges include: Privilege Description --network=host Sets the container's network namespace to the host's network namespace. This allows the agent to collect the network metrics about the host. -v \"/:/host:ro\" Bind mounts the host's root volume to the container. This read-only access to the host's root allows the agent to collect process and storage metrics as well as Inventory data from the host. --cap-add=SYS_PTRACE Adds the Linux capability to trace system processes. This allows the agent to gather data about processes running on the host. Read more here. --privileged --pid=host -v \"/var/run/docker.sock:/var/run/docker.sock\" Bind mounts the host's Docker daemon socket to the container. This allows the agent to connect to the Engine API via the Docker daemon socket to collect the host's container data. Next steps after install For next steps after install is completed, see What's next? Inventory collected Inventory is collected from the infrastructure agent's built-in data collectors. The infrastructure agent collects this data for Linux systems running with containers. Category Source Data collected using metadata agent_config Agent's complete config file system uptime -s, /etc/redhat-release, /proc/cpuinfo, /etc/os-release, /proc/sys/kernel/random/boot_id, /proc/sys/kernel/osrelease, /sys/class/dmi/id/product_uuid, /sys/devices/virtual/dmi/id/sys_vendor, /sys/devices/virtual/dmi/id/product_name Container data Once the infrastructure agent is running in a Docker container, it can collect the same host compute data and event data that the infrastructure agent is capable of collecting when running natively on a host. For more information, see our documentation about how to view your Docker container data. Containerized agent image The containerized agent image is built from an Alpine base image. A CentOS base image is also available. Alpine is used as the base image since version 0.0.55. This is the one pointed by latest tag. Earlier versions used CentOS 7 as base image. In order to keep using that legacy image, some backports may be included there. To fetch the latest CentOS 7 based image, point to the latest-centos tag. Check the source code This integration is open source software. You can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.11515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " that can monitor its underlying host. Recommendation: Extend the newrelic&#x2F;infrastructure image, and use <em>your</em> own newrelic-infra.yml agent config file. Once <em>your</em> image is built, you can easily <em>spin</em> <em>up</em> a container without having to provide more launch time configurations. Do not provide secrets using"
      },
      "id": "6043ef6a28ccbce71b2c6062"
    },
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-08-03T01:40:49Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.938038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>your</em> <em>services</em>",
        "info": "Automatically <em>spin</em> <em>up</em> a microservice infrastructure, and use New Relic to diagnose its issues.",
        "tags": "<em>demo</em>",
        "body": " to investigate simulated issues in Telco Lite <em>services</em> Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in <em>your</em> <em>services</em>. To get <em>your</em> hands on more features of New Relic, pick another <em>demo</em> from the catalog and <em>spin</em> it <em>up</em> with the deployer!"
      },
      "id": "6091fa98e7b9d215455068c4"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/php-release-notes/php-agent-26544/",
      "sections": [
        "PHP agent v2.6.5.44",
        "Important",
        "Notes:"
      ],
      "published_at": "2021-08-02T15:08:01Z",
      "title": "PHP agent v2.6.5.44",
      "updated_at": "2021-03-11T08:36:56Z",
      "type": "docs",
      "external_id": "1c6078d5bc715c5d6d91f19fb738b761ce414fdd",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Important The end-of-life date for this agent version is July 29, 2019. To update to the latest agent version, see Update the agent. For more information, see End-of-life policy. Notes: There is an outstanding issue with the Zend View component where it kills the output buffer that auto-RUM relies on, so for this environment you will need to disable auto-RUM by setting newrelic.browser_monitoring.auto_instrument = 0 and doing manual instrumentation for the time being. Fixed a potential spin-loop that would cause the agent to consume 100% of the CPU if the underlying OS did not allow the daemon connection (even if the daemon was up and running). Only apply Real User Monitoring scripts to HTML content. Fix an issue if auto-RUM encountered content it couldn't parse, it would cause a segmentation violation and cause Apache to core-dump.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.64286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on, so for this environment you will need to disable auto-RUM by setting newrelic.browser_monitoring.auto_instrument = 0 and doing manual instrumentation for the time being. Fixed a potential <em>spin</em>-loop that would cause the agent to consume 100% of the CPU if the underlying OS did not allow"
      },
      "id": "6044eecd64441f84f2378ed1"
    }
  ],
  "/build-apps/ab-test/platform-state-context": [
    {
      "image": "https://developer.newrelic.com/static/d2303a01613c5e0506712d9e593ec1db/ba3ac/nerdsletter-success.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/",
      "sections": [
        "Fetch data from a third-party service",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Fetch data from a third-party service",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "92ddade6115ab659f26d62248a75ff9ec3ed7203",
      "document_type": "page",
      "popularity": 1,
      "info": "Fetch data from a third-party service",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 628.6957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on: <em>Platform</em> APIs. These will come in handy in improving the usability of <em>your</em> New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>PlatformStateContext</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091fb4464441f43272f3724"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 558.1813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " to <em>your</em> <em>nerdlet</em>, before starting this one. In the last lesson, you used <em>PlatformStateContext</em> from the New Relic One SDK to look up the time range that the user selected from the app&#x27;s time picker. Now, you&#x27;ll learn about another component that interacts with the New Relic <em>platform</em>: navigation"
      },
      "id": "6091faf128ccbcb641a268f9"
    },
    {
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "title": "Add a time picker",
      "type": "developer",
      "tags": [
        "time picker",
        "app",
        "helper method",
        "platformstatecontext"
      ],
      "external_id": "2602edf3077388ba4fded3a76208e5e0ae1be98f",
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-06-25T01:40:38Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a time picker to a sample application",
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the platformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(platformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(platformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the platformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(platformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(platformState) => { /* Taking a peek at the platformState */ console.log(platformState); const since = timeRangeToNrql(platformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.3193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a time picker",
        "sections": "<em>Add</em> the time <em>to</em> the queries",
        "info": "<em>Add</em> a time picker <em>to</em> a sample application",
        "tags": "<em>platformstatecontext</em>",
        "body": " Complete these steps: Step 1 of 5 In a text editor, open &#x2F;<em>add</em>-time-picker&#x2F;nerdlets&#x2F;nr1-howto-<em>add</em>-time-picker-<em>nerdlet</em>&#x2F;index.js. Step 2 of 5 <em>Add</em> the <em>PlatformStateContext</em> component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart"
      },
      "id": "6091f827196a672a2ed52a6f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/platform-state-context/",
      "sections": [
        "PlatformStateContext",
        "Usage",
        "Examples",
        "Props",
        "Methods",
        "PlatformStateContext.subscribe"
      ],
      "published_at": "2021-08-03T01:42:10Z",
      "title": "PlatformStateContext",
      "updated_at": "2021-06-25T01:42:52Z",
      "type": "developer",
      "external_id": "aa6b86b3dc0dcd7cd758b20655318b108875cce7",
      "document_type": "page",
      "popularity": 1,
      "body": "React context to access the platform URL state. Usage import { PlatformStateContext } from 'nr1' Copy Examples Props There are no props for this component. Methods PlatformStateContext.subscribe Methods to subscribe for context value updates. function ( subscriber : function // Function that will be called. )",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.2288,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PlatformStateContext</em>",
        "sections": "<em>PlatformStateContext</em>",
        "body": "React <em>context</em> to access the <em>platform</em> URL <em>state</em>. Usage import { <em>PlatformStateContext</em> } from &#x27;nr1&#x27; Copy Examples Props There are no props for this component. Methods <em>PlatformStateContext</em>.subscribe Methods to subscribe for <em>context</em> value updates. function ( subscriber : function &#x2F;&#x2F; Function that will be called. )"
      },
      "id": "6091f8ce196a67b795d52a6d"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: allows you to configure your Nerdlet and write to your Nerdlet's URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.4852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro <em>to</em> New Relic One SDK",
        "sections": "<em>Platform</em> APIs",
        "info": "Intro <em>to</em> New Relic One SDK",
        "tags": "<em>Platform</em> APIs",
        "body": ": <em>PlatformStateContext</em>: provides read access to the <em>platform</em> URL <em>state</em> variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new <em>Nerdlet</em>. <em>NerdletStateContext</em>: provides read access"
      },
      "id": "6091fa39196a67a4ead52a4b"
    }
  ],
  "/build-apps/ab-test/grid": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add user interface components to your application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "ed894ca79a689bdfbf6cff8d64273d4921872e41",
      "document_type": "page",
      "popularity": 1,
      "info": "Add user interface components to your application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 552.819,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> user interface components to your <em>application</em>",
        "sections": "<em>Add</em> user interface components to your <em>application</em>",
        "info": "<em>Add</em> user interface components to your <em>application</em>",
        "body": " functionality. First, you’ll use a <em>Grid</em> component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> headings to clarify what each chart represents. Third, you&#x27;ll <em>add</em> descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section"
      },
      "id": "6091fb4464441f44672f36fa"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add chart headings",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "01dece7fe0259e5d6ff3c32f2022c97034db7a5a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart headings",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 469.6549,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> chart headings",
        "sections": "<em>Add</em> chart headings",
        "info": "<em>Add</em> chart headings",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>grid</em>, before starting"
      },
      "id": "6091faf128ccbcdaa2a26895"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2021-08-03T01:40:57Z",
      "updated_at": "2021-05-21T01:41:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 283.32538,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em>, query, <em>and</em> mutate data using NerdStorage",
        "sections": "<em>Add</em>, query, <em>and</em> mutate data using NerdStorage",
        "info": "NerdStorage is <em>a</em> document database <em>accessible</em> within New Relic One. It <em>allows</em> you to modify, save, <em>and</em> retrieve documents from one session to the next.",
        "tags": "<em>add</em> data",
        "body": " of 2 <em>Add</em> a new <em>Grid</em>Item to the application immediately before the closing <em>Grid</em> tag. In the new <em>Grid</em>Item <em>add</em> the following code to display your new button: &lt;Button onClick={() =&gt; this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType"
      },
      "id": "6091f9c8196a67648ed52a3c"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-08-02T03:52:39Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.05001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Insights Dashboard <em>API</em>",
        "sections": "Insights Dashboard <em>API</em>",
        "tags": "Insights <em>API</em>",
        "body": " Comments CREATE POST &#x2F;v2&#x2F;dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To <em>add</em> more widgets to the dashboard, use the Insights UI. UPDATE PUT &#x2F;v2&#x2F;dashboards&#x2F;:id: Update"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    },
    {
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "title": "Add a time picker",
      "type": "developer",
      "tags": [
        "time picker",
        "app",
        "helper method",
        "platformstatecontext"
      ],
      "external_id": "2602edf3077388ba4fded3a76208e5e0ae1be98f",
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-06-25T01:40:38Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a time picker to a sample application",
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the platformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(platformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(platformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the platformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(platformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(platformState) => { /* Taking a peek at the platformState */ console.log(platformState); const since = timeRangeToNrql(platformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.02736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>a</em> time picker",
        "sections": "<em>Add</em> <em>a</em> time picker",
        "info": "<em>Add</em> <em>a</em> time picker to <em>a</em> sample <em>application</em>",
        "tags": "<em>app</em>",
        "body": " Complete these steps: Step 1 of 5 In a text editor, open &#x2F;<em>add</em>-time-picker&#x2F;nerdlets&#x2F;nr1-howto-<em>add</em>-time-picker-nerdlet&#x2F;index.js. Step 2 of 5 <em>Add</em> the PlatformStateContext component to the end of the import statement so it looks like this: import { <em>Grid</em>, <em>Grid</em>Item, HeadingText, AreaChart, TableChart"
      },
      "id": "6091f827196a672a2ed52a6f"
    }
  ],
  "/build-apps/ab-test/nrql-customizations": [
    {
      "image": "https://developer.newrelic.com/static/2df9afe07c6b32c8a1829a79d3096b53/ba3ac/nrql-query-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add NrqlQuery components to your Nerdlet",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "36c80e35fb841effd378c038e904ae1082a708fb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add NrqlQuery components to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.79837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>NrqlQuery</em> components to your Nerdlet",
        "sections": "Add <em>NrqlQuery</em> components to your Nerdlet",
        "info": "Add <em>NrqlQuery</em> components to your Nerdlet",
        "body": " to handle these differently than you did for the charts you&#x27;ve been dealing with because <em>NRQL</em> has no method for querying <em>data</em> from multiple sources. In the next lesson, you&#x27;ll learn how to supply <em>data</em> to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Customize</em> <em>NRQL</em> <em>data</em>."
      },
      "id": "6091faf2196a6723c0d52a32"
    },
    {
      "sections": [
        "Query infrastructure dimensional metrics with NRQL",
        "Why it matters",
        "Get started",
        "Where and how to query dimensional metrics",
        "Naming conventions for metrics and attributes",
        "Examples",
        "AWS EBS query example",
        "Azure Service bus query example",
        "Azure functions query example",
        "Azure VMs query example",
        "NGINX query example",
        "MySQL query example",
        "Known limitations"
      ],
      "title": "Query infrastructure dimensional metrics with NRQL",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "a131af1f3655ef8b78acfccf8be619c43cb2c51e",
      "image": "https://docs.newrelic.com/static/916ce526afc3e8c7d9ea1325f1fdb980/1b853/naming-convention.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/query-infrastructure-dimensional-metrics-nrql/",
      "published_at": "2021-08-03T00:48:13Z",
      "updated_at": "2021-08-03T00:48:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dimensional metrics are an industry standard for storing and querying metric data. All infrastructure metrics are stored as event data in New Relic, but you can also query them through dimensional metrics. In this page you can learn: The benefits of dimensional metrics. A few examples on how and where to use them. Known issues. Why it matters At New Relic we report metrics in several ways, including dimensional metrics, which are used by our metric API, Telemetry SDK, some open-source integrations, and our infrastructure services. This type of metric enables you to: Enjoy an improved query experience for Infrastructure data. Discover all your metrics in one place. Tap into more metric sources, such as Prometheus. For example, the query to get the maximum duration of your Lambda functions is simplified: Query with samples FROM ServerlessSample SELECT max(provider.duration.Maximum) WHERE provider = 'LambdaFunction' Copy Query with metrics FROM Metric SELECT max(aws.lambda.function.duration) Copy Get started No agent or integration updates are required to use these metrics. NRQL alerting based on dimensional metrics is also supported, except for data coming from cloud integrations (that is metrics from AWS polling integrations, GCP, and Azure). AWS CloudWatch Metric Streams metrics are ingested as dimensional metrics and NRQL alerts are recommended. Where and how to query dimensional metrics All current NRQL query features are supported. Queries can use WHERE, FACET, and time selection functions such as SINCE, UNTIL, and COMPARE WITH. The query builder in New Relic One supports metrics in both simple and advanced (NRQL) mode. Naming conventions for metrics and attributes All metric names and attributes for dimensional metrics follow the same naming convention in order to make them easy to find and use. Metric and attribute names are namespaced with dots: for example, the host. prefix is used for host metrics, the k8s. prefix is used for Kubernetes metrics, and aws. is used for AWS metrics. The graphic below shows how a ProcessSample that contains three metrics (cpuPercent, ioTotalReadBytes, and ioTotalWriteBytes) is split into three separate metrics. Note the updated naming of the metrics and the attributes. Dimensional metrics naming convention Examples Here are some examples of NQRL queries with and without dimensional metrics: AWS EBS query example Get the total write time by EBS Volume. Query with samples FROM BlockDeviceSample SELECT sum('provider.volumeTotalWriteTime.Sum') WHERE provider = 'EbsVolume' FACET entityName Copy Query with metrics FROM Metric SELECT sum(aws.ebs.volume.TotalWriteTime) FACET entity.name Copy Azure Service bus query example Maximum number of messages in an Azure Service Bus topic by resource group. Query with samples FROM AzureServiceBusTopicSample SELECT max(activeMessages.Maximum) FACET resourceGroupName Copy Query with metrics FROM Metric SELECT max(azure.servicebus.topic.activeMessages) FACET azure.resourceGroup Copy Azure functions query example Number of function executions Azure Functions over the past 6 hours by region over time. Query with samples FROM AzureFunctionsAppSample SELECT sum(functionExecutionCount.Total) FACET regionName TIMESERIES SINCE 6 hours ago Copy Query with metrics FROM Metric SELECT sum(azure.functions.app.functionExecutionCount) FACET azure.region TIMESERIES SINCE 6 hours ago Copy Azure VMs query example Compare the number of Azure VMs over the past thirty minutes with the same time a week ago. Query with samples FROM AzureVirtualMachineScaleSetSample SELECT uniqueCount(vMName) FACET name SINCE 30 MINUTES AGO COMPARE WITH 1 WEEK AGO Copy Query with metrics FROM Metric SELECT uniqueCount(azure.vms.vmName) FACET azure.resourceName WHERE azure.resourceType='Microsoft.Compute/virtualMachineScaleSets' SINCE 30 MINUTES AGO COMPARE WITH 1 WEEK AGO Copy NGINX query example The average number of NGINX requests per second over time. Query with samples FROM NginxSample SELECT average(net.requestsPerSecond) TIMESERIES Copy Query with metrics FROM Metric SELECT average(nginx.server.net.requestsPerSecond) TIMESERIES Copy MySQL query example The maximum number of used MySQL connections. Query with samples FROM MysqlSample SELECT max(net.maxUsedConnections) Copy Query with metrics FROM Metric SELECT max(mysql.node.net.maxUsedConnections) Copy Known limitations Metric queries with * do not return Infrastructure sample data (for example, SELECT * FROM Metric). In order to select attributes starting with tags. a metric name has to be provided. For example, SELECT uniques(tags.environment) FROM Metric WHERE metricName='aws.lambda.function.duration' does not work without the WHERE clause. Results may not be complete if the selection criteria matches too many samples. For example, SELECT uniqueCount(entity.guid) FROM Metric maps to all Infrastructure samples, and may return incomplete results. Initially there is no support for the newly introduced metric wildcarding feature (for example, SELECT average(host.swap%Bytes) FROM Metric).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.1831,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query infrastructure dimensional metrics with <em>NRQL</em>",
        "sections": "Query infrastructure dimensional metrics with <em>NRQL</em>",
        "tags": "Query your <em>data</em>",
        "body": " provider = &#x27;LambdaFunction&#x27; Copy Query with metrics FROM Metric SELECT max(aws.lambda.function.duration) Copy Get started No agent or integration updates are required to use these metrics. <em>NRQL</em> alerting based on dimensional metrics is also supported, except for <em>data</em> coming from cloud integrations"
      },
      "id": "603e95e8e7b9d286642a07fa"
    },
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-08-03T00:46:14Z",
      "updated_at": "2021-08-03T00:46:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.16948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> query examples for mobile monitoring",
        "sections": "<em>NRQL</em> query examples for mobile monitoring",
        "tags": "Query your <em>data</em>",
        "body": "There are several ways to query your <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "Facet non-matching data with OR",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Functions",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "capture(attribute, regular expression)",
        "capture() within a SELECT clause condition",
        "capture() within a FACET clause condition",
        "capture() within a WHERE clause condition",
        "capture() with a numeric cast",
        "Non-aggregator functions",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/static/507a44dd5750a7c536bee652e105179f/8c557/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-08-02T05:47:43Z",
      "updated_at": "2021-08-02T05:47:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute, and you can use the OR operator to facet results that don't match any of your specified cases. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy Facet non-matching data with OR This example uses the OR operator to facet results that didn't match any of your cases: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. See Use the time picker to adjust time settings for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE r'z.*|q.*'' hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*' z-app q-app ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Functions Here is a listing of the available functions in NRQL. The definitions below contain example NRQL queries. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT uniques(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy capture(attribute, regular expression) Use the capture() to extract values from an attribute using a regular expression. Uses RE2 syntax. It takes two arguments: Attribute name Regular expression with capture syntax. Regex expressions in NRQL use Python-like syntax, r'...'. When capturing, use the RE2 named-capture syntax ...(?P<name> pattern )... to capture the contained pattern, given the specified name. Currently, only 1 capture group is supported. Please see the examples below. capture() within a SELECT clause condition The following will select the domain name of the website, removing https:// and any paths following the .com SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago Copy The following will capture only the first word of the error message. SELECT capture(errorMessage, r'(?P<firstWord>\\S+)\\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null Copy capture() within a FACET clause condition The following will facet by the captured HTTP method. SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* \"(?P<httpMethod>[A-Z]+) .*') Copy capture() within a WHERE clause condition The following will filter the results based on Log events with message attribute that matches the regular expression where the captured job name is ExampleJob. SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago Copy capture() with a numeric cast The following will capture sum of CPU Time from log lines. You must explicitly cast to numeric to do mathematical operations. SELECT sum(numeric(capture(message, r'.*CpuTime:\\s(?P<cpuTime>\\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago Copy Non-aggregator functions Use non-aggregator functions for non-numerical data in NRQL queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from compound data types, such as metric data. It takes the following arguments: Metric type Supported fields summary count, total, max, min, type gauge count, total, max, min, latest, type distribution count, total, max, min, type counter count, type timeslice count, total, totalExclusive, min, and max Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.33505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>NRQL</em> syntax, clauses, and functions",
        "tags": "Query your <em>data</em>",
        "body": " <em>NRQL</em> is used for, what <em>data</em> you can query with it, and basic <em>NRQL</em> syntax Examine <em>NRQL</em> queries used to build New Relic charts Learn how to query the Metric <em>data</em> type Simulate SQL JOIN functions Use funnels to evaluate a series of related <em>data</em> Format <em>NRQL</em> for querying with the Event API Query"
      },
      "id": "604456c1196a678db8960f41"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-08-03T01:41:02Z",
      "updated_at": "2021-08-02T22:59:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Add muting rules to suppress notifications Manage notification channels Customize loss of signal and gap filling The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.90462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Use <em>NRQL</em> conditions Add muting rules to suppress notifications Manage notification channels <em>Customize</em> loss of signal and gap filling The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor"
      },
      "id": "6043fe3864441f2dd2378ee8"
    }
  ],
  "/build-apps/ab-test/confirmation-modal": [
    {
      "image": "https://developer.newrelic.com/static/e886dd8ae5b9e23c13d355abf15ea2b1/ba3ac/persist-selected-version-final.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/",
      "sections": [
        "Persist the selected version",
        "Course"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Persist the selected version",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "a1867dc5e8e1ba4771a570e3c41e3e05c15e1977",
      "document_type": "page",
      "popularity": 1,
      "info": "Persist the selected version",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a section to end your test, before starting this one. In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version/ab-test Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Present an end test confirmation modal.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1053.1178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is reflected in the menu. However, when you press <em>End</em> <em>test</em>, nothing happens. In the next lesson, you&#x27;ll create a <em>confirmation</em> dialog to protect yourself from prematurely ending your A&#x2F;B <em>test</em>. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Present</em> an <em>end</em> <em>test</em> <em>confirmation</em> <em>modal</em>."
      },
      "id": "6091fb4428ccbc0a06a268ab"
    },
    {
      "image": "https://developer.newrelic.com/static/2df9afe07c6b32c8a1829a79d3096b53/ba3ac/nrql-query-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add NrqlQuery components to your Nerdlet",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "36c80e35fb841effd378c038e904ae1082a708fb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add NrqlQuery components to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 775.00665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Present</em> an <em>end</em> <em>test</em>"
      },
      "id": "6091faf2196a6723c0d52a32"
    },
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-08-02T05:02:49Z",
      "updated_at": "2021-07-27T17:34:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Hover an element Navigate to a URL Secure a credential Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.808975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " monitor Provide a url and this monitor will <em>test</em> all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor Proactively ping your domain certificates based on a configurable threshold. Pair"
      },
      "id": "603e873864441f3e154e888f"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Access NerdStorage from your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "8c49cf33a6d954510f5c4b309a8a4d2f848fd68c",
      "document_type": "page",
      "popularity": 1,
      "info": "Access NerdStorage from your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.2445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Save <em>test</em> information to NerdStorage",
        "body": " value={&#x27;A&#x27;}&gt;Version A&lt;&#x2F;SelectItem&gt; &lt;SelectItem value={&#x27;B&#x27;}&gt;Version B&lt;&#x2F;SelectItem&gt; &lt;&#x2F;Select&gt; } } class <em>EndTest</em>Button extends React.Component { constructor() { super(...arguments); this.state = { <em>modal</em>Hidden: true, } this.show<em>Modal</em> = this.show<em>Modal</em>.bind(this); this.close<em>Modal</em> = this.close<em>Modal</em>"
      },
      "id": "6091faf1196a67250bd52a2b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/modal/",
      "sections": [
        "Modal",
        "Usage",
        "Examples",
        "Props"
      ],
      "published_at": "2021-08-03T01:50:24Z",
      "title": "Modal",
      "updated_at": "2021-06-25T01:50:51Z",
      "type": "developer",
      "external_id": "d0b0ddbfd4564c59b6711dcc5d6f9a17cdc5acd2",
      "document_type": "page",
      "popularity": 1,
      "body": "Modals are used for single-step create, add, edit, or delete actions. They are also used to display additional metadata about a screen or specific object on the screen. Usage import { Modal } from 'nr1' Copy Examples Props ariaLabelledBystring Pass the string of the text content which should better describe the purpose of the modal to be correctly announced by screen readers. childrennode Content to render inside the modal. classNamestring Appends class names to the component. hiddenboolean DEFAULT false If true, the modal is hidden. onCloserequiredfunction Callback fired when clicking on the Modal's close button. onHideEndfunction Callback fired when the Modal finishes the closing animation. Use this to unmount the Modal component. This ensures that the closing animation works properly. onHideStartfunction Callback fired when the Modal starts the closing animation. onShowEndfunction Callback fired when the Modal finishes the opening animation. onShowStartfunction Callback fired when the Modal starts the opening animation. styleobject Inline style for custom styling. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.602356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Modal</em>",
        "sections": "<em>Modal</em>",
        "body": " Callback fired when the <em>Modal</em> finishes the opening animation. onShowStartfunction Callback fired when the <em>Modal</em> starts the opening animation. styleobject Inline style for custom styling. <em>test</em>Idstring Adds a data-<em>test</em>-id attribute. Use it to target the component in unit and e2e tests."
      },
      "id": "6091f8ce28ccbc5e71a2689c"
    }
  ],
  "/build-apps/ab-test/install-nr1": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1827.8303,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Install</em> and <em>configure</em>"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "image": "https://developer.newrelic.com/static/555c6dd44f2ffbceff682f7fbc78e01c/ba3ac/demo-service.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/demo-setup/",
      "sections": [
        "Spin up your demo services",
        "Course",
        "Important"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Spin up your demo services",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "9485b737ad7e595a2e2354438b2532748e978b42",
      "document_type": "page",
      "popularity": 1,
      "info": "Spin up your demo services",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Before you build your New Relic One application, you need to spin up your demo services. This coursework depends on two important services: A web service that shows a newsletter signup form. The form's heading text alternates between two versions because you're performing an A/B test to determine which text leads to more high-quality subscriptions. A simulator service that sends steady traffic to the website so that you don't have to manually generate data To spin up your demo services, you first need to install Docker and Docker compose. Spin up your demo services Step 1 of 5 Clone the coursework repository from GitHub: bash Copy $ git clone https://github.com/newrelic-experimental/nru-programmability-course This repository contains code for creating NodeJS New Relic automations. It also contains a an app code directory for each lesson in the course. You'll use these directories to follow along with the course content. Step 2 of 5 Change to the demo directory, called ab-test-app: bash Copy $ cd nru-programmability-course/ab-test-app This directory contains configuration files and READMEs for using the demo. Step 3 of 5 Build and run the web service and simulator containers, using docker-compose: bash Copy $ NEW_RELIC_LICENSE_KEY=<your New Relic license key> docker-compose up -d Important Make sure you replace <your New Relic license key> with your actual license key. Once it's finished, view the website at localhost:3001: Step 4 of 5 Visit New Relic, and navigate to APM in the top navigation menu. Select Newsletter from the list of instrumented services: You may have to wait a minute or two for New Relic to recieve data from your demo services. Once it's ready, you'll see transaction data, such as performance, throughput, and an Apdex score: Step 5 of 5 To spin down your demo services, run docker-compose down from your ab-test-app directory: bash Copy $ docker-compose down Now you're ready to build your New Relic One application! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Install and configure the New Relic One CLI.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1623.9774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to build your <em>New</em> <em>Relic</em> <em>One</em> application! Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> application from the ground up. Continue on to the next lesson: <em>Install</em> and <em>configure</em> the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>."
      },
      "id": "6091faf164441f20702f36f0"
    },
    {
      "image": "https://developer.newrelic.com/static/a618501b792e17a063fb841a8dcaa2bb/0086b/nerdlet-attached-to-app.png",
      "url": "https://developer.newrelic.com/build-apps/attach-nerdlet-to-entities/",
      "sections": [
        "Attach your Nerdlet to entities",
        "Before you begin",
        "Create a Nerdpack",
        "Configure your entities context",
        "Specify an entity domain",
        "Specify an entity type",
        "Specify entity tags",
        "Combine filters"
      ],
      "published_at": "2021-08-03T01:41:57Z",
      "title": "Attach your Nerdlet to entities",
      "updated_at": "2021-05-21T01:41:19Z",
      "type": "developer",
      "external_id": "36b82245d4253dfcef63961f0e01669eac041be8",
      "document_type": "page",
      "popularity": 1,
      "info": "Attach your Nerdlet to entities",
      "body": "One way for users to access your Nerdlet is by creating a launcher. The launcher opens a Nerdlet from the Apps page in New Relic. You can also provide access to your Nerdlet from an entity in your account. In this guide, you'll learn how to attach your Nerdlet to your entities. Before you begin If you haven't already: Sign up for a New Relic account Install and configure the New Relic One CLI Create a Nerdpack Step 1 of 5 Update your CLI: bash Copy $ nr1 update Step 2 of 5 Create a Nerdpack with the CLI: bash Copy $ nr1 create --type nerdpack --name entity-nerdlet This results in a Nerdpack, called entity-nerdlet, which consists of a launcher, called entity-nerdlet-launcher, and a Nerdlet, called entity-nerdlet-nerdlet. Step 3 of 5 Serve your Nerdpack: bash Copy $ cd entity-nerdlet $ nr1 nerdpack:serve Step 4 of 5 Go to https://one.newrelic.com/?nerdpacks=local, and navigate to Apps: ?nerdpacks=local is required to enable your locally served Nerdpacks to load in New Relic. Step 5 of 5 Under Your apps, click your launcher to view your New Relic One application: Attach your Nerdlet to entities You've seen how you can access your Nerdlet from a launcher. Now, access your Nerdlet from your entities. Step 1 of 6 From inside your Nerdpack's root directory, open nerdlets/entity-nerdlet-nerdlet/nr1.json. This is your Nerdlet's metadata file. You'll use this file to attach your Nerdlet to entities. Step 2 of 6 Add a context object with an entities array: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [] 8 } 9 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy This tells New Relic that you want to surface your Nerdlet in an array of entity contexts. Step 3 of 6 Add an entity context: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [ 8 { 9 \"domain\": \"APM\", 10 \"type\": \"APPLICATION\" 11 } 12 ] 13 } 14 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy Here, you've attached your Nerdlet to all application entities in the APM domain. Step 4 of 6 Go to APM: Because you're serving your Nerdpack locally, remember that you must still specify the ?nerdpacks=local query string. Step 5 of 6 Choose any of your applications: Step 6 of 6 Scroll down to see your Nerdlet attached to the application: Click this menu option and see your Nerdlet the same way you did with the launcher. Configure your entities context The context.entities key in your Nerdlet's nr1.json file specifies which entities your Nerdlet should be attached to. Specify an entity domain Attach your Nerdlet to a certain entity domain by specifying the domain as one of the following values: APM: Application Performance Monitoring BROWSER: Browser INFRA: Infrastructure monitoring MOBILE: Mobile monitoring SYNTH: Synthetic monitoring For example, attach your Nerdlet to all entities in the APM domain: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }] } } Copy Attach your Nerdlet to all entities except those in a domain: { \"context\": { \"entities\": [{ \"domain\": \"!APM\" }] } } Copy Attach your Nerdlet to all entities in multiple domains: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }, { \"domain\": \"BROWSER\" }] } } Copy Specify an entity type Attach your Nerdlet to a certain entity type by specifying the type as one of the following values: APPLICATION HOST MONITOR For example, attach your Nerdlet to all entities of the APPLICATION type: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }] } } Copy Attach your Nerdlet to all entities except those of a specified type: { \"context\": { \"entities\": [{ \"type\": \"!APPLICATION\" }] } } Copy Attach your Nerdlet to every entity whose type matches one of an array of types: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }, { \"type\": \"MONITOR\" }] } } Copy Specify entity tags Attach your Nerdlet to entities that have a given tag. For example, attach your Nerdlet to the entity which has a particular GUID: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"guid\", \"values\": [\"<SOME ENTITY GUID>\"] } ] } ] } } Copy Attach your Nerdlet to every entity which has particular accountId and uses the Python programming language: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"accountId\", \"values\": [\"<SOME ACCOUNT ID>\"] }, { \"key\": \"language\", \"values\": [\"python\"] } ] } ] } } Copy Combine filters When you filter the entities to which your Nerdlet will be added, you can combine domain, type, and tags: { \"context\": { \"entities\": [ { \"domain\": \"APM\", \"type\": \"APPLICATION\", \"tags\": [ { \"key\": \"language\", \"values\": [\"python\"] } ] }, { \"domain\": \"SYNTH\", \"type\": \"MONITOR\" }, { \"domain\": \"BROWSER\" } ] } } Copy In this example, you've attached your Nerdlet to: All APM applications whose metadata tags specify the python language AND all Synthetic monitors AND all Browser entities",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1271.4443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Configure</em> your entities context",
        "body": " If you haven&#x27;t already: Sign up for a <em>New</em> <em>Relic</em> account <em>Install</em> and <em>configure</em> the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Create a Nerdpack Step 1 of 5 Update your <em>CLI</em>: bash Copy $ nr1 update Step 2 of 5 Create a Nerdpack with the <em>CLI</em>: bash Copy $ nr1 create --type nerdpack --name entity-nerdlet This results in a Nerdpack"
      },
      "id": "609c84b7e7b9d237155068d3"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.5148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help organize <em>and</em> find your data",
        "sections": "Use tags to help organize <em>and</em> find your data",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and labels that are defined in the cloud service. To add tags, you&#x27;d add them on the cloud-service-side. Automate tags with our <em>CLI</em> For a guide to automating tags using our <em>CLI</em> tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 330.06122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Workloads: Isolate <em>and</em> resolve incidents faster",
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a <em>New</em> <em>Relic</em> account for free! No credit card required. What is a workload in <em>New</em> <em>Relic</em>? <em>New</em> <em>Relic</em> monitors a wide range of entities and data, from client-side applications and backend APIs"
      },
      "id": "6043cb93196a67f988960f76"
    }
  ],
  "/build-apps/ab-test/end-test": [
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add version descriptions",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "13644740111a7835d4738836f19589a74c711e26",
      "document_type": "page",
      "popularity": 1,
      "info": "Add version descriptions",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 960.7078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> version descriptions",
        "sections": "<em>Add</em> version descriptions",
        "info": "<em>Add</em> version descriptions",
        "body": " <em>section</em> of <em>your</em> application from user interface components. This <em>section</em> will be used to <em>end</em> the A&#x2F;B <em>test</em> with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> a <em>section</em> to <em>end</em> <em>your</em> <em>test</em>."
      },
      "id": "6091fb44196a6744a7d52a81"
    },
    {
      "image": "https://developer.newrelic.com/static/e886dd8ae5b9e23c13d355abf15ea2b1/ba3ac/persist-selected-version-final.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/",
      "sections": [
        "Persist the selected version",
        "Course"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Persist the selected version",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "a1867dc5e8e1ba4771a570e3c41e3e05c15e1977",
      "document_type": "page",
      "popularity": 1,
      "info": "Persist the selected version",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a section to end your test, before starting this one. In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version/ab-test Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Present an end test confirmation modal.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 699.62555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>section</em> to <em>end</em> <em>your</em>"
      },
      "id": "6091fb4428ccbc0a06a268ab"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terms/",
      "sections": [
        "Terms and conditions"
      ],
      "published_at": "2021-08-02T10:57:00Z",
      "title": "Terms and conditions",
      "updated_at": "2021-08-02T10:57:00Z",
      "type": "developer",
      "external_id": "5c260dc18b9f68a28114875ddc900a8935479040",
      "document_type": "page",
      "popularity": 1,
      "info": "Developer terms and conditions",
      "body": "New Relic Developer Terms Welcome to New Relic's developer program (\"Developer Program\")! We are excited that you're here. Our intent is to maintain a vibrant software development community. We require that all users that develop on the New Relic platform adhere to these terms. These terms (\"Terms\") apply to participation in the Developer Program and form a legal agreement between you (\"you\" or \"Developer\") and New Relic, Inc. (\"New Relic\", \"we\", \"our\" or \"us\"), so please read them carefully. If you are entering into these Terms on behalf of a company, organization or another legal entity, then \"you\" or \"Developer\" means that entity, and you represent and warrant that you have the authority to bind that entity to these Terms. Please ensure you have that authority, since otherwise you may not accept these Terms or use the Developer Resources. New Relic may modify these Terms from time to time, subject to Section 19 (Changes to Terms) below. By clicking \"I agree\" (or a similar button) or by accessing or using the Developer Resources, you agree to be bound by these Terms. Introduction. Our Developer Resources help you build apps, add-ons and features that extend, augment or complement the New Relic Service (\"Apps\"). The \"Developer Resources\" are the APIs, SDKs, sample code, Developer Accounts, command line interfaces, tokens, credentials and other resources we provide as part of the Developer Program, as described on the Developer Site. The \"New Relic Service\" is our SaaS offering and related software, which we provide under separate terms (\"New Relic Terms of Service\"). How These Terms Apply. These Terms apply if you use our Developer Resources to build or manage Apps. Any use of the New Relic Service itself (including our standard tools and APIs that help you configure usage or retrieve your data) remains subject to the New Relic Terms of Service, not these Terms. Registration. To access or use the Developer Resources, you need to complete any registration or credentialing requirements established by New Relic. Use of Developer Resources. Subject to these Terms, you may use the Developer Resources to enable your Apps to interface with the New Relic Service. Your use is subject to the developer documentation currently available on the Developer Site or otherwise provided by New Relic (\"Developer Documentation\"), which is considered part of the Developer Resources. Your rights are limited, non-exclusive, non-sublicensable and non-transferable. You may permit your agents and contractors to exercise your rights on your behalf, provided you remain responsible for their compliance with these Terms. Developer Account. New Relic may offer test or sandbox accounts as part of the Developer Program (\"Developer Accounts\"), which you may use only for internal development or testing of your Apps as part of your rights in Section 4 (Use of Developer Resources). Because Developer Accounts are for development or testing purposes only, you may not use personally identifiable or production data with Developer Accounts (and no End User Data). New Relic has no security, privacy or other responsibility for data contained in Developer Accounts and may access, modify or delete such data at any time for any reason. You may not provide access to your Developer Accounts to anyone else. Developer Accounts may be subject to additional usage restrictions as set forth from time to time in the Developer Documentation. Access Limits; Compliance. New Relic may (but is not required to) monitor your use of the Developer Resources and how your Apps interact with the New Relic Service, including to ensure your compliance with these Terms. You agree to cooperate with our reasonable inquiries and, upon request, provide us with proof that your use of the Developer Resources and your Apps comply with these Terms. From time to time New Relic may also place limits on access (e.g., limits on number of API calls). Restrictions. We expect all developers to respect New Relic, end users and other third parties. In using the Developer Resources, you must comply with New Relic's Acceptable Use Policy currently available here (\"Acceptable Use Policy\"). You will not (and will not permit anyone else to): (a) use the Developer Resources except with the New Relic Service as permitted in these Terms; (b) sublicense, sell, distribute or grant third parties access to the Developer Resources, other than your agents and contractors (see Section 4) or as permitted in the Developer Documentation (e.g., distributable elements of SDKs); (c) use the Developer Resources for competitive purposes, with Apps that substantially replicate features of the New Relic Service or to circumvent any intended limitations of the New Relic Service (e.g., payment of fees or user access structures); (d) reverse engineer, modify or create derivative works of the Developer Resources; (e) access the Developer Resources through means other than the tokens and credentials we provide; (f) make calls using an App not driven by bona fide end user requests (except for reasonable testing); (g) publish benchmarks or performance information regarding the Developer Resources; (h) test the performance, bandwidth or capacity of the Developer Resources or New Relic Service or disrupt their integrity or performance; (i) transmit any viruses, illegal content or other harmful materials to the Developer Resources or New Relic end users; or (j) take any action that would subject the Developer Resources or New Relic Service to any open source licenses or other third party terms. Use of New Relic Marks. Subject to these Terms, you may use the appropriate New Relic names, logos and trademarks designated in the New Relic Trademark Guidelines currently available here (\"New Relic Marks\") to promote your App's availability for use with the New Relic Service. Your use of New Relic Marks must comply with the New Relic Trademark Guidelines and (without limiting New Relic's other termination rights) you must promptly cease any use of New Relic Marks upon notice by New Relic. You receive no other rights to New Relic Marks under these Terms. All goodwill arising from use of New Relic Marks belongs to New Relic. Your Responsibilities. You and your Apps must meet important standards related to privacy, security, business practices and user experience, as set out below. a. Your Apps and End Users. You are solely responsible, at your own expense, for your Apps (including their operation, components, integrations and support) and your relationships and agreements with end users regarding your Apps. b. Support. You will provide end users with reasonable web-based and/or email support for your Apps. You will also provide New Relic with a current email address to which New Relic may direct end user inquiries about your Apps and designate a support contact (name and email address) for New Relic. c. End User Data. An end user may enable you or your App to access certain of its data, content or information within the New Relic Service (\"End User Data\"). You may access and process End User Data only to the extent enabled by the end user and as necessary to provide your Apps to that end user. You will ensure that all End User Data is collected, processed, transmitted, maintained and used in accordance with: (i) your agreement with the end user and a legally adequate privacy policy (\"End User Terms\"), and appropriate notices to and consents from end users, (ii) all laws, rules, regulations or orders, including those relating to data privacy, data transfer, international communications or the export of technical or personal data (\"Laws\") and (iii) industry-standard technical, administrative and physical security measures that protect the security and privacy of all End User Data. New Relic is not responsible for any regulatory action or claim to which you may be subject in connection with your Apps. New Relic is also not responsible for any transmission, disclosure, modification or deletion of End User Data in the New Relic Service by, through or resulting from an App. d. Security Breaches. In case of any suspected or actual security breach affecting your App or End User Data, you must immediately notify New Relic and cooperate with New Relic to remediate the issue and mitigate its effects. You must obtain New Relic's approval for any security breach notifications to end users that refer directly or indirectly to New Relic. e. New Relic Customer Terms. Use of the New Relic Service requires each end user to have a valid subscription subject to the New Relic Terms of Service. You will not facilitate or encourage any end user to violate the New Relic Terms of Service or Acceptable Use Policy. For clarity, if New Relic receives any data from you or your Apps on an end user's behalf, such data will be subject solely to the New Relic Terms of Service with the end user, and such data will no longer be subject to your own terms with the end user. f. Fees. You may not directly or indirectly charge end users for use of, or access to, the functionality of the Developer Resources. If you charge any fees for your Apps, you are solely responsible for collecting those fees independently from New Relic and the New Relic Catalog. You are also responsible for any related refunds or liabilities to end users and for any associated end user communications under Section 13.d (End User Communications). These Terms grant you no right to distribute or resell the Developer Resources or New Relic Service. g. Your Representations and Warranties. You represent and warrant that: (i) you have full power and authority to enter into and perform these Terms and to exploit your Apps without violating any other agreement; (ii) your Apps and their use will not violate any Laws or third party rights (including intellectual property rights, and rights of privacy or publicity), and you will notify New Relic if your Apps become subject to any claim or complaint regarding violation of Laws or third party rights; (iii) all information you provide to New Relic is and will be true, accurate and complete (and you will keep such information up-to-date); and (iv) you will not interfere with New Relic's business practices or the way in which it licenses or distributes the Developer Resources or New Relic Service. You agree not to: (A) suggest any affiliation with New Relic (including that New Relic sponsors, endorses or guarantees your Apps) except for the relationship expressly contemplated in these Terms or (B) make any representations, warranties or commitments on New Relic's behalf or regarding the Developer Resources or New Relic Service. h. Indemnification. You will indemnify, defend (at New Relic's request) and hold harmless New Relic and its affiliates and their respective directors, officers, employees, agents, contractors, end users and licensees from and against any regulatory actions, claims, losses, costs, expenses (including reasonable attorneys' fees), damages or liabilities based on or arising from (i) your Apps, (ii) your relationships or interactions with any end users or third parties in connection with your Apps, or (iii) your breach or alleged breach of these Terms. New Relic may, at its own expense, participate in the defense and settlement of any claim with its own counsel, and you may not settle a claim without New Relic's prior written consent (not to be unreasonably withheld). Listings. This Section 10 applies only if you choose to submit your App for listing in the New Relic Catalog. a. Submission. To submit your App for potential listing in the New Relic Catalog, you must follow New Relic's Listing Requirements and provide: i. Your App meeting the Listing Requirements, including regarding security and coding practices, ii. Listing information, trademarks and documentation (\"Listing Materials\"), iii. End User Terms for your App, and iv. Other related materials that we reasonably request. b. Approval. New Relic may approve or reject any submitted App in its sole discretion and reserves the right to test Apps against the Listing Requirements and other security and performance criteria. You remain solely responsible for your Apps despite any New Relic approval. c. New Relic Rights. If New Relic approves your submitted App, you hereby grant New Relic a license to: i. List your App in the New Relic Catalog; ii. Copy, distribute, publicly perform and display, and create derivative works of your Listing Materials, and screenshots of your App's use with the New Relic Service, in order to market and promote your App, the New Relic Catalog and the New Relic Service (but we will not change your trademarks except for sizing and formatting); and iii. Use, host, copy, distribute, publicly perform and display your App to permit your App to operate with the New Relic Service, including by permitting End Users to enable and deploy your App with their New Relic Service accounts. New Relic's license rights are worldwide, non-exclusive, royalty-free and fully paid-up and sublicensable through multiple tiers. New Relic retains sole discretion and control over the placement, look and feel of the New Relic Catalog. d. End User Deployment. If New Relic lists your App on the New Relic Catalog, interested end users may select and deploy your App with their New Relic Service accounts. New Relic does not guarantee any end users will search for or use your App. e. End User Terms. You are responsible for your End User Terms and how you present them to end users and obtain their agreement. Your End User Terms must be consistent with your rights and obligations in these Terms (including regarding End User Data and any termination, suspension or take-down of your App), and you agree your App will not be licensed under a Copyleft License. New Relic is not a party to your End User Terms and is not responsible for how end users use your App or for enforcing your End User Terms. \"Copyleft License\" means any OSS license that seeks to require any party that uses, modifies or distributes the licensed code to make such code (or modification or derivative work thereof) or any other code that may be combined with or linked to such code available in source code form or that may impose any other obligation or restriction with respect to such party's patent or other intellectual property rights (such as, for example purposes only, any version of the GPL or LGPL, Affero, CPL, CDDL, Eclipse or Mozilla licenses). f. Take-Downs. You may request that we take-down your App from the New Relic Catalog at any time by contacting opensource+nr1-catalog@newrelic.com. We will use commercially reasonable efforts to promptly remove your App from the New Relic Catalog following receipt of your request. In addition to its other rights, New Relic may temporarily or permanently take-down any App listed in the New Relic Catalog in its discretion, without notice to you. Section 13.c (Wind-Down) will apply following any take-down pursuant to this Section 10.f. g. New Relic Catalog. \"New Relic Catalog\" means (i) the New Relic One Catalog that New Relic makes available in connection with the New Relic Service and (ii) any other App listing or catalog that New Relic makes available through its own or third party products or websites. Ownership. New Relic does not claim ownership of your Apps (other than our own technology) and you reserve all rights not expressly granted in these Terms. New Relic and its licensors retain all ownership and other rights (including all intellectual property rights) in the Developer Resources, the New Relic Service and our related technology. Providing feedback, comments, or suggestions about the Developer Program or Developer Resources (\"Feedback\") to New Relic is wholly voluntary. New Relic may freely use Feedback for any purpose. Support; Changes. New Relic has no obligation to provide maintenance or support for the Developer Resources or your Apps, or to fix any errors or defects. New Relic may change the Developer Resources from time to time as our business changes and technology evolves, and future versions of the Developer Resources may not be compatible with Apps built using previous versions. We typically make these changes as part our overall Developer Program and are unable to provide notice of the changes to developers individually. New Relic will have no liability resulting from these changes. Termination and Suspension. These Terms remain in effect until terminated. a. By Developer. Developer may terminate these Terms at any time by ceasing all use of the Developer Resources. b. By New Relic. New Relic may terminate or suspend these Terms or your access to or right to use the Developer Resources (in whole or in part): (i) for no reason or any reason upon 15 days' notice to you, (ii) immediately (A) if you breach any provision of these Terms, (B) if New Relic is required to do so by Laws, (C) if New Relic ceases offering the Developer Resources, (D) in case of any security breach or other concern under Section 9.d (Security Breaches), or (E) if New Relic otherwise determines in its discretion that such action is necessary to avoid harm, liability or reputational damage to New Relic, the Developer Resources, the New Relic Service, or any end user. For clarity, suspension may include disabling your Apps. c. Wind-Down. Following any termination of these Terms, at New Relic's request (i) the parties will cooperate to effectuate an orderly wind-down and (ii) these Terms will continue in effect for up to 90 days to enable deployed end users to continue using your Apps. d. End User Communications. In the event of any termination, suspension or take-down under this Section 13 or Section 10.f (Take-Downs), Developer remains responsible for managing its own end user relationships and communications, including as relates to any transition to alternate Developer offerings or any impact on fees, refunds or commercial terms with end users. Developer will ensure that any such end user communications are accurate and conducted in a positive and professional manner, consistent with any guidelines New Relic may provide. e. Effect of Termination. Upon any termination, subject to Section 13.c (Wind-Down) (i) your rights to use the Developer Resources and New Relic Marks will immediately terminate and you will cease all such use, (ii) you will return or destroy all Confidential Information (as requested by New Relic) and (iii) Sections 9 (Your Responsibilities), 11 (Ownership) and 13 (Termination and Suspension) through 24 (General) will survive. After termination, you will have no further access to any data or content that you submitted to New Relic relating to the Developer Resources. f. No Obligation or Liability. New Relic will have no obligation or liability resulting from termination, suspension or take-down as described in this Section 13 or Section 10.f (Take-Downs). Disclaimer of Warranties. TO THE FULL EXTENT PERMITTED BY LAW, THE DEVELOPER RESOURCES ARE PROVIDED \"AS IS\" AND \"WITH ALL FAULTS\" AND NEW RELIC AND ITS THIRD-PARTY LICENSORS DISCLAIM ALL REPRESENTATIONS, WARRANTIES AND GUARANTEES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR ANY PURPOSE. NEW RELIC MAKES NO REPRESENTATION, WARRANTY OR GUARANTEE RELATED TO RELIABILITY, ACCURACY OR COMPLETENESS OF THE DEVELOPER RESOURCES, THAT NEW RELIC WILL CONTINUE TO OFFER THE DEVELOPER RESOURCES OR THAT USE OF THE DEVELOPER RESOURCES WILL BE SECURE, TIMELY, UNINTERRUPTED, ERROR-FREE OR MEET DEVELOPER'S REQUIREMENTS OR EXPECTATIONS. You may have other statutory rights, in which case the disclaimers above will apply to the full extent permitted by law. Limitations of Liability. TO THE FULL EXTENT PERMITTED BY LAW, IN NO EVENT WILL NEW RELIC BE LIABLE (i) FOR ANY LOSS OF USE, LOST DATA, FAILURE OF SECURITY MECHANISMS, INTERRUPTION OF BUSINESS OR ANY INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND (INCLUDING LOST PROFITS OR LOST DATA), EVEN IF INFORMED OF THE POSSIBILITY OF SUCH DAMAGES IN ADVANCE OR (ii) IN ANY EVENT, FOR ANY DAMAGES OR LIABILITIES EXCEEDING ONE HUNDRED U.S. DOLLARS (\\$100), ARISING FROM OR RELATING TO THESE TERMS, USE OF THE DEVELOPER RESOURCES, YOUR APPS OR THEIR COMBINATION OR INTERACTION WITH THE DEVELOPER RESOURCES OR NEW RELIC SERVICE. NOTWITHSTANDING ANYTHING TO THE CONTRARY, NEW RELIC HAS NO WARRANTY, INDEMNIFICATION OR OTHER OBLIGATION OR LIABILITY WITH RESPECT TO YOUR APPS OR THEIR COMBINATION, INTERACTION OR USE WITH THE DEVELOPER RESOURCES OR NEW RELIC SERVICE. You acknowledge and agree that this Section 15 reflects a reasonable allocation of risk and will apply regardless of the form of action or legal theory, whether in contract, tort (including negligence), strict liability or otherwise, and that New Relic would not enter into these Terms without these liability limitations. This Section will survive even if any limited remedy fails of its essential purpose. New Relic Confidential Information. Any non-public elements of the Developer Resources and any other information disclosed by New Relic that is marked as confidential or proprietary or that should reasonably be understood to be confidential or proprietary from the circumstances of disclosure is \"Confidential Information.\" Confidential Information does not include any information that: (i) is or becomes generally known to the public; (ii) was known to you before its disclosure by New Relic; or (iii) is received from a third party, in each case without breach of an obligation owed to New Relic or anyone else. You will (A) maintain Confidential Information in confidence (using at least the same measures as for your own confidential information, and no less than reasonable care) and not divulge it to any third party and (B) only use Confidential Information to fulfill your obligations under these Terms. If you are compelled by law to disclose Confidential Information, you must provide New Relic with prior notice of such compelled disclosure (to the extent legally permitted) and reasonable assistance if New Relic wishes to contest the disclosure. If you breach or threaten breach of this Section 16, it could cause substantial harm for which damages are inadequate and New Relic will have the right to seek injunctive relief in addition to other remedies. Independent Development; Information You Provide Not Confidential. New Relic develops a variety of offerings and works with many other developers and partners, and either New Relic or these third parties could in the future develop (or already have developed) products, services, concepts or features similar to yours. Nothing limits New Relic's right to do so, though this Section itself does not grant us any license under your intellectual property rights. Unless separately set forth in another agreement, New Relic has no confidentiality obligations for information you submit in connection with the Developer Program. Usage Data. In addition to New Relic's other rights, New Relic may collect certain data and information regarding your use of the Developer Site and Developer Resources, including data about your data pulls or requests, and your Apps (\"Usage Data\"). We may use and exploit Usage Data for any purpose in connection with operating, improving and supporting the Developer Program and Developer Resources. Changes to Terms. We may change these Terms from time to time as our business changes and technology evolves. New Relic will use reasonable efforts to notify you of changes to these Terms as provided in Section 22 (Notices). You may be required to click through the modified Terms to show your acceptance and in any event your continued use of the Developer Resources after the modification constitutes your acceptance to the modifications. If you do not agree to the modified Terms, your sole remedy is to terminate your use of the Developer Resources as described in Section 13 (Termination and Suspension). Open Source Software. Certain code in the Developer Resources (e.g., SDKs) may be licensed under or include components subject to \"open source\" software terms (\"OSS\"), as listed in the Developer Documentation. The OSS licenses may grant you additional rights to the OSS code itself and allow you to use the OSS outside of our Developer Program. To be clear, though, when you use the OSS as part of our Developer Program, you must comply with these Terms. Pre-Release Versions. New Relic may make available certain Developer Resources on a pre-release or early access basis (\"Pre-Release Versions\"). Use of Pre-Release Versions may be subject to additional terms designated by New Relic. Pre-Release Versions are optional and either party may terminate use at any time for any reason. If you choose to use a Pre-Release Version, you agree to provide Feedback at our reasonable request. Pre-Release Versions may be inoperable, incomplete or include features that New Relic may never release, and their features and performance information are New Relic's Confidential Information. Notices. New Relic may provide you with notices and communications at your email or physical address on file, through the Developer Site or other reasonable means. Any notices or communications to New Relic must be sent to legal@newrelic.com or New Relic, Inc., Attention: Legal Department - Developer Terms, 188 Spear Street, Suite 1200, San Francisco, CA 94105. Export. The Developer Resources may be subject to export restrictions by the United States government and import restrictions by certain foreign governments, and you agree to comply with all applicable export and import laws and regulations in your use of the Developer Resources. You represent and warrant that you are not located in a country subject to a U.S. Government embargo, or that has been designated by the U.S. Government as a \"terrorist supporting\" country, and that you are not listed on any U.S. Government list of prohibited or restricted parties. General. These Terms are the parties' entire agreement and supersede any prior or concurrent agreements relating to its subject matter. Except as set forth in Section 19 (Changes to Terms), all amendments or modifications must be in writing and signed by both parties. The words \"including\" and similar terms are to be construed without limitation. Failure to enforce any provision is not a waiver and all waivers must be in writing. If any provision is found to be unenforceable it (and related provisions) will be interpreted to best accomplish its intended purpose. Developer may not assign, transfer or delegate any right or obligations under these Terms and any non-permitted assignment is void. New Relic may assign these Terms and its rights and obligations to any of its affiliates or in connection with a merger, reorganization, acquisition or other transfer of all or substantially all of its assets or voting securities to which these Terms relate. The parties are independent contractors and these Terms do not create any agency, partnership or joint venture. These Terms will be governed by and construed under the laws of the State of California, as applied to agreements entered into and to be performed in California by California residents. The parties consent to the exclusive jurisdiction and venue of the courts located in and serving San Francisco, California. New Relic will not be liable to Developer for any delay or failure to perform any obligation under these Terms if the delay or failure is due to unforeseen events that are beyond its reasonable control. The Developer Resources include commercial computer software. If the user or licensee of such technology is an agency, department or other entity of the United States Government, the use, duplication, reproduction, release, modification, disclosure or transfer of such technology, or any related documentation of any kind, including technical data and manuals, is restricted by these Terms in accordance with Federal Acquisition Regulation 12.212 for civilian purposes and Defense Federal Acquisition Regulation Supplement 227.7202 for military purposes. The Developer Resources were developed fully at private expense. All other use is prohibited.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.88545,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Terms <em>and</em> conditions",
        "sections": "Terms <em>and</em> conditions",
        "info": "Developer terms <em>and</em> conditions",
        "body": " refunds or liabilities to <em>end</em> users and for any associated <em>end</em> user communications under <em>Section</em> 13.d (<em>End</em> User Communications). These Terms grant you no right to distribute or resell the Developer Resources or New Relic Service. g. <em>Your</em> Representations and Warranties. You represent and warrant"
      },
      "id": "6091f9c828ccbc0a1da26890"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/python-release-notes/python-agent-228026/",
      "sections": [
        "Python agent v2.28.0.26",
        "Important",
        "Notes",
        "New Features"
      ],
      "published_at": "2021-08-02T17:40:14Z",
      "title": "Python agent v2.28.0.26",
      "updated_at": "2021-08-02T17:40:13Z",
      "type": "docs",
      "external_id": "5939ea369bf0e1728bf83f949cd66a7524a1b6d0",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Important The end-of-life date for this agent version is July 29, 2019. To update to the latest agent version, see Update the agent. For more information, see End-of-life policy. Notes This release of the Python agent improves data collection with the Django web framework. These improvements include better-targeted web transaction naming with the Django REST framework, better coverage of Django template inclusion tags, and better background task monitoring for Django management commands. The agent can be installed using easy_install/pip/distribute via the Python Package Index or can be downloaded directly from our download site. For a list of known issues with the Python agent see Status of the Python agent. New Features Improved Django REST Framework naming Previously, when using the Django REST framework, web transactions were being named after the class based view that implemented the Django REST framework resources. Now, where such a view provides custom handler methods for different HTTP request method types or actions, the web transaction will be named after that custom handler method rather than the class as a whole. A new function breakdown metric will also be added for the custom handler method. This change will allow web requests using different HTTP request method types to be viewed separately. Django inclusion tag monitoring Usage of inclusion tags in Django templates can now be monitored and will appear in the transaction breakdown table, charts and sample transaction traces. Due to the possibility that a large range of custom inclusion tags might be used and that they may be invoked a large number of times in tight loops, tracking of all inclusion tags may not be practical or may not produce worthwhile results in the transaction breakdown or sample transaction traces. As a result, monitoring of inclusion tags is off by default, with the preferred approach being that specific inclusion tags of interest be individually enabled through the agent configuration file. To enable monitoring of specific inclusion tags, a new section called import-hook:django should be added to the agent configuration: [import-hook:django] instrumentation.templates.inclusion_tag = prepopulated_fields_js date_hierarchy Copy The instrumentation.templates.inclusion_tag setting within that section should then be set to a space separated list of the names of the inclusion tags to monitor. If there is any confusion over the identity of the inclusion tag, the full name of the inclusion tag function, with module name, can instead be listed. For example, data_hierarchy can also be identified using django.contrib.admin.templatetags.admin_list:date_hierarchy. In addition to specifying the names of the specific inclusion tags, it is also possible to specify * for instrumentation.templates.inclusion_tag in order to have usage of all inclusion tags be monitored: [import-hook:django] instrumentation.templates.inclusion_tag = * Copy Enabling monitoring of all inclusion tags in this way is only recommended in development or test environments so as to get an initial idea of what inclusion tags are worth tracking. Once identified, the specific inclusion tags of interest should thereafter be listed individually in a production environment. Better monitoring of Django management commands Previously, the Python agent required you to manually set up the instrumentation for each specific Django management command in the agent configuration file. We have now made that easier by integrating the functionality as part of the agent itself. Due to the limitations on what Django management commands can be monitored, you will still need to list explicitly the commands you want monitored, but it can now be done in a single location as a space separated list under the setting instrumentation.scripts.django_admin of the import-hook:django section: [import-hook:django] instrumentation.scripts.django_admin = syncdb sqlflush Copy By default, we automatically specify the startup timeout to be 10.0 seconds when monitoring the Django management commands. If you need to override the startup timeout, you can set the instrumentation.background_task.startup_timeout setting within the same import-hook:django configuration section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.830635,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Python <em>agent</em> v2.28.0.26",
        "sections": "Python <em>agent</em> v2.28.0.26",
        "body": "Important The <em>end</em>-of-life date for this agent version is July 29, 2019. To update to the latest agent version, see Update the agent. For more information, see <em>End</em>-of-life policy. Notes This release of the Python agent improves data collection with the Django web framework. These improvements"
      },
      "id": "603ec5b9196a67efb4a83dce"
    },
    {
      "sections": [
        "Activate Azure integrations",
        "Requirements",
        "Step 1: Get Azure subscription and tenant IDs",
        "Step 2: Register your app and get ID",
        "Step 3: Create a client secret in Azure",
        "Step 4: Provide permissions to services",
        "Step 5: Add app to New Relic",
        "Update application details and rotate client secrets",
        "Explore app data in New Relic Infrastructure's UI"
      ],
      "title": "Activate Azure integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "Microsoft Azure integrations",
        "Get started"
      ],
      "external_id": "f65679179e13aa1b503b4b95010e296cbe269c29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/get-started/activate-azure-integrations/",
      "published_at": "2021-08-02T13:06:07Z",
      "updated_at": "2021-08-02T13:06:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure integrations allow you to report data from specific systems and supplement infrastructure's default, automatic monitoring. The Microsoft Azure integrations report data from various Azure platform services to your New Relic account. This document explains how to activate Azure integrations. Requirements The Azure integration activation process requires you to: A New Relic account. Don't have one? Sign up for free! No credit card required. Create a New Relic application and key in Azure. Grant this application access to the Azure services you want to monitor. Place required information in the New Relic's Integrations UI. To use these integration activation instructions directly from the Infrastructure UI, go to one.newrelic.com > Infrastructure > Azure > Add an Azure account. Step 1: Get Azure subscription and tenant IDs To get your Azure account's subscription id and tenantId, use your local terminal if you have Azure's tools installed, or use Azure's Cloud Shell terminal in the Azure portal. Open a terminal with access to your Azure account. Type the following: az account show Copy Copy and save the subscription id and tenantID from the output response for later use. The response should look similar to the response below. The subscription id and tenantID are highlighted. @Azure:~$ az account show { \"environmentName\": \"AzureCloud\", \"id\": \"9ffe9512-f4a2-42dd-1230-518aec34be21\" , \"isDefault\": true, \"name\": \"Beyond Team Sandbox\", \"state\": \"Enabled\", \"tenantId\": \"ac6692da-1231-422f-22a8-9eed6dbe83f1\" , \"user\": { \"name\": \"youremail@domain\", \"type\": \"user\" } Copy Step 2: Register your app and get ID You must have Azure permissions to register your application and copy its Application ID. To register your app in Azure: Sign in to the Azure portal and go to the Azure Active Directory. From Manage, select App registrations > New registration. Enter a name for the application. We recommend that you name your app NewRelic-Integrations. In Redirect URI select Weband add https://www.newrelic.com as the sign-on URI. Create the application by clicking Register. From the Overview of your app, copy the Application (client) ID, and save it for later use. Step 3: Create a client secret in Azure To create a client secret associated with your application: In Azure, under the application you've just created, select Certificates & secrets. Under Client secrets, click on New client secret and then on Add. Copy the value of Client Secret and save it for later use. Step 4: Provide permissions to services Your app must provide Reader permissions for each Azure service you want New Relic to monitor: In the Azure Subscriptions section, select the subscriptions that you want New Relic to monitor. Select Access control (IAM) > Add > Add role assignment. From the Role dropdown, select Reader. From the Select dropdown, select the app's name; for example, NewRelic-Integrations. From Selected members, verify your app name appears, then select Save. Some Azure services, including Azure CosmosDB and Azure VMs, require additional steps. See the Azure integration documentation for the services you want to enable. Step 5: Add app to New Relic Now you can activate the Azure integration in the Infrastructure UI. The UI will require the information you have saved in the previous steps, including: Your Azure account's subscription id and tenantId The application's application ID The application's client secret To add your Azure app to New Relic: Go to one.newrelic.com > Infrastructure > Azure and select the Azure Service you wish to add. Follow the steps in the UI to activate the integration in New Relic. If you have already completed the Azure account steps, skip to the end of the steps to fill out the form. (For Azure account name, enter the name you want to use to identify the account in your Integrations dashboard.) Update application details and rotate client secrets It's possible to update the application's name and authentication credentials using the Infrastructure UI or the Cloud Integrations API at any time. Follow these steps to rotate the Azure client secret in the Infratructure UI: Go to one.newrelic.com > Infrastructure > Azure and click on Manage Services on the Azure account you wish to edit. Select the edit action next to Account Name to see and edit any application value. Edit the Client Secret field with the new value and confirm with Save Changes. Explore app data in New Relic Infrastructure's UI After you activate an Azure integration, New Relic will start monitoring your Azure data at regular polling intervals. To find and use your data, use the data explorer or go to one.newrelic.com > Infrastructure > Azure",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.27655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Activate</em> <em>Azure</em> integrations",
        "sections": "Step 5: <em>Add</em> <em>app</em> <em>to</em> New Relic",
        "tags": "Microsoft <em>Azure</em> integrations",
        "body": " secrets, click on New client secret and then on <em>Add</em>. Copy the value of Client Secret and save it for later use. Step 4: Provide permissions to services <em>Your</em> app must provide Reader permissions for each Azure service you want New Relic to monitor: In the Azure Subscriptions <em>section</em>, select"
      },
      "id": "6044e5a9196a671bfa960f79"
    }
  ],
  "/build-apps/ab-test/table-charts": [
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add pie charts",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "cd10196320620683a525a97cc3770662466e5134",
      "document_type": "page",
      "popularity": 1,
      "info": "Add pie charts",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.96759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> pie charts",
        "sections": "<em>Add</em> pie charts",
        "info": "<em>Add</em> pie charts",
        "body": " application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>tables</em>."
      },
      "id": "6091fb44e7b9d280165068d6"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add a chart group",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6ad93629eaf632d87125194995d2b7caa432f548",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a chart group",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 210.46675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a chart group",
        "sections": "<em>Add</em> a chart group",
        "info": "<em>Add</em> a chart group",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>tables</em>, before starting"
      },
      "id": "6091faf1196a6726c2d52a20"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-05-21T01:40:23Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 update $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component. Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows. As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells. The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.38498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>tables</em> to your New Relic One application",
        "sections": "<em>Add</em> <em>tables</em> to your New Relic One application",
        "info": "<em>Add</em> a <em>table</em> to your New Relic One app.",
        "tags": "<em>table</em> in app",
        "body": " <em>Add</em> some action to your table! <em>Tables</em> are great, but interactive <em>tables</em> can be better: As a last update, you are going to allow users to act on each data row. <em>Add</em> the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns"
      },
      "id": "6091f7cae7b9d209f45068a1"
    },
    {
      "sections": [
        "Use your charts",
        "Change the appearance of your chart",
        "Customize your charts",
        "Tip",
        "Format date and time",
        "Customize the Y axis",
        "Enable or disable the legend",
        "Remove the other groups facet",
        "More chart-specific features",
        "Chart share and view options"
      ],
      "title": "Use  your charts ",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Use charts"
      ],
      "external_id": "947a92d0243924f412fedb47bcb95dc40ec953fb",
      "image": "https://docs.newrelic.com/static/9bd74f30a31df0cb0ab112a325296b92/59415/crop-cb-chart-menu-tooltip_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/use-your-charts/",
      "published_at": "2021-08-03T00:43:02Z",
      "updated_at": "2021-07-21T13:02:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Once you've created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using the data explorer to specify data, the query builder analyzes your data and applies a chart type that fits your data. For some queries, you'll have several options of chart types to choose from. To change chart type, use the Chart type menu to the right of the current chart. Each type in the list has a tooltip with information about using that type. Example of the chart type menu, showing a tooltip. Customize your charts While we try our best to optimize how we display your data, sometimes you may have other needs. To this end, you can customize charts to display information at your convenience. Tip Customizations are available depending on the chart type. Format date and time Tip For table and billboard charts. Customize the date and time format for tables and billboards: for each type of data, you can select if you want to leave it as it is, or modify the format as Numeric or Date. If data is a timestamp, you can choose how to represent the date and time: For numbers, select if you want us to auto-format them, or chose the number of decimals you want to see. Customize the Y axis Tip For line and area charts. On line charts and area charts you can adjust the Y axis to display the data within certain values by setting a minimum and maximum value for the axis. If no customization option is selected, dashboards automatically displays the full Y axis from 0 to the top value plus a margin. Enable or disable the legend Tip For line and area charts, and histograms. For line charts, area charts, and histograms, you can disable or enable the legend. Remove the other groups facet Tip For bar and pie charts, and tables. When faceting on bar charts, pie charts, or tables, and if the number of faceting on queries is larger than 2,000, the Other groups facet aggregates the rest of facets. With this customization you can select whether to see Other groups, or remove it. More chart-specific features For more chart type-specific features, see Chart types. Chart share and view options Most charts have various options, including a chart-embed option, getting a chart as an image, and adding a chart to a dashboard. To read about general chart options, see Basic UI features.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.02799,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Once you&#x27;ve created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and <em>add</em> a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using"
      },
      "id": "603ec29a196a67ef5da83d82"
    },
    {
      "sections": [
        "MySQL monitoring integration",
        "Compatibility and requirements",
        "Important",
        "Quick start",
        "Install and activate",
        "ECS",
        "Kubernetes",
        "Linux",
        "Windows",
        "Configuration",
        "Activate remote monitoring",
        "Environment variable passthroughs",
        "HOSTNAME",
        "PORT",
        "USERNAME",
        "PASSWORD",
        "DATABASE",
        "EXTENDED_METRICS",
        "EXTENDED_INNODB_METRICS",
        "EXTENDED_MY_ISAM_METRICS",
        "Find and use data",
        "Metric data",
        "Default metrics",
        "Extended metrics",
        "Extended innodb metrics",
        "Extended myisam metrics",
        "Extended slave cluster metrics",
        "Inventory",
        "System metadata",
        "Source code"
      ],
      "title": "MySQL monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "50b118a06500c42ca8f26ce475d00f70c6fda148",
      "image": "https://docs.newrelic.com/static/6bf45ccf002250f7ebaa69cbe3ff706c/c1b63/guided-install-cli.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/mysql-monitoring-integration/",
      "published_at": "2021-08-03T01:45:18Z",
      "updated_at": "2021-07-30T01:55:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our MySQL integration collects and sends inventory and metrics from your MySQL database to our platform, where you can see the health of your database server and analyze metric data so that you can easily find the source of any problems. Read on to install the integration, and to see what data we collect. Compatibility and requirements Our integration is compatible with MySQL version 5.6 or higher. Before installing the integration, make sure that you meet the following requirements: A New Relic account. Don't have one? Sign up for free! No credit card required. If MySQL is not running on Kubernetes or Amazon ECS, you can install the infrastructure agent on a Linux or Windows OS host. Otherwise: If running on Kubernetes, see these requirements. If running on ECS, see these requirements. Important For MySQL v8.0 and higher we do not support the following metrics: cluster.slaveRunning, db.qCacheFreeMemoryBytes, db.qCacheHitRatio, db.qCacheNotCachedPerSecond. Quick start Instrument your MySQL database quickly and send your telemetry data with guided install. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click one of these button to try it out. Guided install EU Guided install Our guided install uses the infrastructure agent to set up the MySQL integration. Not only that, it discovers other applications and log sources running in your environment and then recommends which ones you should instrument. The guided install works with most setups. But if it doesn't suit your needs, you can find other methods below to get started monitoring your MySQL database. Install and activate To install the MySQL integration, follow the instructions for your environment: ECS See Monitor service running on ECS. Kubernetes See Monitor service running on Kubernetes. Linux Follow the instructions for installing an integration, using the file name nri-mysql. From the command line, create a user with replication and select privileges: This command creates a user newrelic@localhost with a specific password. sudo mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'YOUR_SELECTED_PASSWORD' WITH MAX_USER_CONNECTIONS 5;\" Copy sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost';\" Copy Gives replication privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Gives select privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Change the directory to the integration's folder. cd /etc/newrelic-infra/integrations.d Copy Copy the sample configuration file: sudo cp mysql-config.yml.sample mysql-config.yml Copy Edit the configuration file mysql-config.yml as explained in the next section. Restart the infrastructure agent. Windows Download the nri-mysql .MSI installer image from: https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mysql/nri-mysql-amd64.msi To install from the Windows command prompt, run: msiexec.exe /qn /i PATH\\TO\\nri-mysql-amd64.msi Copy In the Integrations directory, C:\\Program Files\\New Relic\\newrelic-infra\\integrations.d\\, create a copy of the sample configuration file by running: cp mysql-config.yml.sample mysql-config.yml Copy Edit the mysql-config.yml file as described in the configuration settings. Restart the infrastructure agent. Additional notes: Advanced: Integrations are also available in tarball format to allow for install outside of a package manager. On-host integrations do not automatically update. For best results, regularly update the integration package and the infrastructure agent. Configuration An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference. There are several ways to configure the integration, depending on how it was installed: If enabled via Kubernetes: see Monitor services running on Kubernetes. If enabled via Amazon ECS: see Monitor services running on ECS. If installed on-host: edit the config in the integration's YAML config file, mysql-config.yml. The configuration provides a single command, status, that captures the metrics and all the config options. It accepts these arguments: hostname: the MySQL hostname. port: the port where the MySQL server is listening. username: the user connected to the MySQL server. If you used the CREATE USER command in the activation instructions, this should be set to newrelic. password: the password for the user specified above. extended_metrics: captures an extended set of metrics. Disabled by default. Set to 1 to enable. This also enables the capture of slave metrics. extended_innodb_metrics: captures additional innodb metrics. Disabled by default. Set to 1 to enable. extended_myisam_metrics: captures additional MyISAM metrics. Disabled by default. Set to 1 to enable. Optional: labels field. For example, the env label controls the environment inventory data. The default value is production. Optional: metrics field. Set to 1 to disable the collection of inventory. See a sample of a configuration file. Activate remote monitoring The remote_monitoring parameter enables remote monitoring and multi-tenancy for this integration. This parameter is enabled by default and should not be changed unless you require it in your custom environment. Activating remote_monitoring may change some attributes and/or affect your configured alerts. For more information, see remote monitoring in on-host integrations. Important Infrastructure agent version 1.2.25 or higher is required to use remote_monitoring. Environment variable passthroughs Environment variables can be used to control config settings, and are then passed through to the infrastructure agent. For instructions on how to use this feature, see Configure the infrastructure agent. Important With secrets management, you can configure on-host integrations with New Relic infrastructure's agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file. For more information, see Secrets management. HOSTNAME Specifies the hostname or IP where MySQL is running. Type String Default localhost Example: HOSTNAME='MySQL DB' Copy PORT Port on which MySQL server is listening. Type Integer Default 3306 Example: PORT=6379 Copy USERNAME The user connected to the MySQL server. Type String Default (none) Example: USERNAME='DBAdmin' Copy PASSWORD Password for the given user. Type String Default (none) Example: PASSWORD='Hh7$(uvRt' Copy DATABASE Name of the database to be monitored. Type String Default (none) Example: DATABASE='My MySQL DB' Copy EXTENDED_METRICS Captures an extended set of metrics. This also enables the capture of slave metrics. Type Boolean Default false Example: EXTENDED_METRICS=true Copy EXTENDED_INNODB_METRICS Captures additional innodb metrics. Type Boolean Default false Example: EXTENDED_INNODB_METRICS=true Copy EXTENDED_MY_ISAM_METRICS Captures additional MyISAM metrics. Type Boolean Default false Example: EXTENDED_MY_ISAM_METRICS=true Copy For more about the general structure of on-host integration configuration, see Configuration. Find and use data Data from this service is reported to an integration dashboard. Metrics are attached to the MysqlSample event type. You can query this data for troubleshooting purposes or to create custom charts and dashboards. For more on how to find and use your data, see Understand integration data. Metric data The MySQL integration collects the following metrics: Default metrics These metrics are captured by default: Name Description cluster.slaveRunning Boolean. 1 if this server is a replication slave that is connected to a replication master, and both the I/O and SQL threads are running; otherwise, it is 0. For metrics reported if enabled, see replication slave metrics. db.handlerRollbackPerSecond Rate of requests for a storage engine to perform a rollback operation, per second. db.innodb.bufferPoolPagesData Number of pages in the InnoDB buffer pool containing data. db.innodb.bufferPoolPagesFree Number of free pages in the InnoDB buffer pool. db.innodb.bufferPoolPagesTotal Total number of pages of the InnoDB buffer pool. db.innodb.dataReadBytesPerSecond Rate at which data is read from InnoDB tables in bytes per second. db.innodb.dataWrittenBytesPerSecond Rate at which data is written to InnoDB tables in bytes per second. db.innodb.logWaitsPerSecond Number of times that the log buffer was too small and a wait was required for it to be flushed before continuing, in waits per second. db.innodb.rowLockCurrentWaits Number of row locks currently being waited for by operations on InnoDB tables. db.innodb.rowLockTimeAvg Average time to acquire a row lock for InnoDB tables, in milliseconds. db.innodb.rowLockWaitsPerSecond Number of times operations on InnoDB tables had to wait for a row lock per second. db.openedTablesPerSecond Number of files that have been opened with my_open() (a mysys library function) per second. Parts of the server that open files without using this function do not increment the count. db.openFiles Number of files that are open. This count includes regular files opened by the server. It does not include other types of files such as sockets or pipes. db.openTables Number of tables that are open. db.qCacheFreeMemoryBytes Amount of free memory in bytes for the query cache. db.qCacheHitRatio Percentage of queries that are retrieved from the cache. db.qCacheNotCachedPerSecond Number of noncached queries (not cacheable, or not cached due to the query_cache_type setting) per second. db.qCacheUtilization Percentage of query cache memory that is being used. db.tablesLocksWaitedPerSecond Number of times per second that a request for a table lock could not be granted immediately and a wait was needed. net.abortedClientsPerSecond Number of connections per second that were aborted because the client died without closing the connection properly. net.abortedConnectsPerSecond Number of failed attempts to connect to the MySQL server, per second. net.bytesReceivedPerSecond Byte throughput received from all clients, per second. net.bytesSentPerSecond Byte throughput sent to all clients, per second. net.connectionErrorsMaxConnectionsPerSecond Rate per second at which connections were refused because the server max_connections limit was reached. net.connectionsPerSecond Number of connection attempts per second. net.maxUsedConnections Maximum number of connections that have been in use simultaneously since the server started. net.threadsConnected Number of currently open connections. net.threadsRunning Number of threads that are not sleeping. query.comCommitPerSecond Number of COMMIT statements executed per second. query.comDeletePerSecond Number of DELETE statements executed per second. query.comDeleteMultiPerSecond Number of DELETE statements that use the multiple-table syntax executed per second. query.comInsertPerSecond Number of INSERT statements executed per second. query.comInsertSelectPerSecond Number of INSERT SELECT statements executed per second. query.comReplaceSelectPerSecond Number of REPLACE SELECT statements executed per second. query.comRollbackPerSecond Number of ROLLBACK statements executed per second. query.comSelectPerSecond Number of SELECT statements executed per second. query.comUpdateMultiPerSecond Number of UPDATE statements that use the multiple-table syntax executed per second. query.comUpdatePerSecond Number of UPDATE statements executed per second. query.preparedStmtCountPerSecond Current number of prepared statements per second. (The maximum number of statements is given by the max_prepared_stmt_count system variable.) query.queriesPerSecond Total number of statements executed by the server per second, including statements executed within stored programs. query.questionsPerSecond Number of statements executed by the server per second, limited to only those sent by clients. query.slowQueriesPerSecond Number of queries per second that have taken more than long_query_time seconds. This counter increments regardless of whether the slow query log is enabled. Extended metrics Additional metrics captured when extended_metrics is enabled (set to 1 in the configuration file): Name Description db.createdTmpDiskTablesPerSecond Number of internal on-disk temporary tables created per second by the server while executing statements. db.createdTmpFilesPerSecond Number of temporary files created per second by mysqld. db.createdTmpTablesPerSecond Number of internal temporary tables created per second by the server while executing statements. db.handlerDeletePerSecond Number of times per second that rows have been deleted from tables. db.handlerReadFirstPerSecond Number of times per second the first entry in an index was read. db.handlerReadKeyPerSecond Number of requests per second to read a row based on a key. db.handlerReadRndNextPerSecond Number of requests per second to read the next row in the data file. db.handlerReadRndPerSecond Number of requests per second to read a row based on a fixed position. db.handlerUpdatePerSecond Number of requests per second to update a row in a table. db.handlerWritePerSecond Number of requests per second to insert a row in a table. db.maxExecutionTimeExceededPerSecond Number of SELECT statements per second for which the execution timeout was exceeded. db.qCacheFreeBlocks Number of free memory blocks in the query cache. db.qCacheHitsPerSecond Number of query cache hits per second. db.qCacheInserts Number of queries added to the query cache. db.qCacheLowmemPrunesPerSecond Number of queries per second that were deleted from the query cache because of low memory. db.qCacheQueriesInCachePerSecond Number of queries per second registered in the query cache. db.qCacheTotalBlocks Total number of blocks in the query cache. db.selectFullJoinPerSecond Number of joins that perform table scans because they do not use indexes, per second. db.selectFullJoinRangePerSecond Number of joins per second that used a range search on a reference table. db.selectRangeCheckPerSecond Number of joins per second without keys that check for key usage after each row. db.selectRangePerSecond Number of joins per second that used ranges on the first table. db.sortMergePassesPerSecond Number of merge passes that the sort algorithm has had to do, per second. db.sortRangePerSecond Number of sorts per second that were done using ranges. db.sortRowsPerSecond Number of sorted rows per second. db.sortScanPerSecond Number of sorts that were done by scanning the table, per second. db.tableOpenCacheHitsPerSecond Number of hits per second for open tables cache lookups. db.tableOpenCacheMissesPerSecond Number of misses per second for open tables cache lookups. db.tableOpenCacheOverflowsPerSecond Number of overflows per second for the open tables cache. db.threadCacheMissRate Percent of threads that need to be created to handle new connections because there are not enough threads available in the cache. db.threadsCached Number of threads in the thread cache. db.threadsCreatedPerSecond Number of threads per second created to handle connections. Extended innodb metrics Additional metrics captured when extended_innodb_metrics is enabled (set to 1 in the configuration file): Name Description db.innodb.bufferPoolPagesDirty Current number of dirty pages in the InnoDB buffer pool. db.innodb.bufferPoolPagesFlushedPerSecond Number of requests per second to flush pages from the InnoDB buffer pool. db.innodb.bufferPoolReadAheadEvictedPerSecond Number of pages per second read into the InnoDB buffer pool by the read-ahead background thread that were subsequently evicted without having been accessed by queries. db.innodb.bufferPoolReadAheadPerSecond Number of pages per second read into the InnoDB buffer pool by the read-ahead background thread. db.innodb.bufferPoolReadAheadRndPerSecond Number of “random” read-aheads per second initiated by InnoDB. This happens when a query scans a large portion of a table but in random order. db.innodb.bufferPoolReadRequestsPerSecond Number of logical read requests per second. db.innodb.bufferPoolReadsPerSecond Number of logical reads that InnoDB could not satisfy from the buffer pool, and had to read directly from disk, per second. db.innodb.bufferPoolWaitFreePerSecond Number of times per second a read or write to InnoDB had to wait because there were not clean pages available in the buffer pool. db.innodb.bufferPoolWriteRequestsPerSecond Number of writes per second done to the InnoDB buffer pool. db.innodb.dataFsyncsPerSecond Number of fsync() operations per second. db.innodb.dataPendingFsyncs Current number of pending fsync() operations. db.innodb.dataPendingReads Current number of pending reads. db.innodb.dataPendingWrites Current number of pending writes. db.innodb.dataReadsPerSecond Number of data reads (OS file reads) per second. db.innodb.dataWritesPerSecond Number of data writes per second. db.innodb.logWriteRequestsPerSecond Number of write requests for the InnoDB redo log per second. db.innodb.logWritesPerSecond Number of physical writes per second to the InnoDB redo log file. db.innodb.numOpenFiles Number of files InnoDB currently holds open. db.innodb.osLogFsyncsPerSecond Number of fsync() writes per second done to the InnoDB redo log files. db.innodb.osLogPendingFsyncs Number of pending fsync() operations for the InnoDB redo log files. db.innodb.osLogPendingWrites Number of pending writes per second to the InnoDB redo log files. db.innodb.osLogWrittenBytesPerSecond rate Number of bytes written per second to the InnoDB redo log files. db.innodb.pagesCreatedPerSecond The number of pages created per second by operations on InnoDB tables. db.innodb.pagesReadPerSecond Number of pages read per second from the InnoDB buffer pool by operations on InnoDB tables. db.innodb.pagesWrittenPerSecond Number of pages written per second by operations on InnoDB tables. db.innodb.rowsDeletedPerSecond Number of rows deleted per second from InnoDB tables. db.innodb.rowsInsertedPerSecond Number of rows per second inserted into InnoDB tables. db.innodb.rowsReadPerSecond Number of rows per second read from InnoDB tables. db.innodb.rowsUpdatedPerSecond Number of rows per second updated in InnoDB tables. Extended myisam metrics Additional metrics captured when extended_myisam_metrics is enabled in the configuration file: Name Description db.myisam.keyBlocksNotFlushed Number of key blocks in the MyISAM key cache that have changed but have not yet been flushed to disk. db.myisam.keyCacheUtilization Percentage of the key cache that is being used. db.myisam.keyReadRequestsPerSecond Number of requests to read a key block from the MyISAM key cache, per second. db.myisam.keyReadsPerSecond Number of physical reads of a key block from disk into the MyISAM key cache, per second. db.myisam.keyWriteRequestsPerSecond Number of requests per second to write a key block to the MyISAM key cache. db.myisam.keyWritesPerSecond Number of physical writes of a key block from the MyISAM key cache to disk, per second. Extended slave cluster metrics Additional metrics captured when the extended metrics flag is enabled in the configuration file and the cluster.slaveRunning metric is returning a value of 1. Check the MySQL Documentation for more details. Name Description db.relayLogSpace Total combined number of bytes for all existing relay log files. cluster.lastIOErrno Error number of the most recent error that caused the I/O thread to stop. cluster.lastIOError Error message of the most recent error that caused the I/O thread to stop. cluster.lastSQLErrno Error number of the most recent error that caused the SQL thread to stop. cluster.lastSQLError Error message of the most recent error that caused the SQL thread to stop. cluster.slaveIORunning Status of whether the I/O thread is started and has connected successfully to the master. The values can be Yes, No, or Connecting. cluster.slaveSQLRunning Status of whether the SQL thread is started. The values can be Yes or No. cluster.secondsBehindMaster Difference in seconds between the slave’s clock time and the timestamp of the query when it was recorded in the master’s binary log. When the slave is not correctly connected to the master, this metric won’t be reported. cluster.masterLogFile Name of the master binary log file from which the I/O thread is currently reading. cluster.readMasterLogPos Position in the current master binary log file up to which the I/O thread has read. cluster.relayMasterLogFile Name of the master binary log file containing the most recent event executed by the SQL thread. cluster.execMasterLogPos Position in the current master binary log file to which the SQL thread has read and executed, marking the start of the next transaction or event to be processed. Inventory The MySQL integration captures the configuration parameters of the MySQL node returned by SHOW GLOBAL VARIABLES. The data is available on the Inventory page, under the config/mysql source. System metadata The MySQL integration collects the following metadata attributes about your MySQL system: Name Description software.edition software.edition takes the value of the MySQL version_comment variable. software.version The MySQL server version. cluster.nodeType Either master or slave, depending on the role of the MySQL node being monitored. Source code The MySQL integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.98285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " pool. db.innodb.bufferPoolPagesTotal Total number of pages of the InnoDB buffer pool. db.innodb.dataReadBytesPerSecond Rate at which data is read from InnoDB <em>tables</em> in bytes per second. db.innodb.dataWrittenBytesPerSecond Rate at which data is written to InnoDB <em>tables</em> in bytes per second"
      },
      "id": "6043a211e7b9d294bc5799d1"
    }
  ],
  "/build-apps/ab-test/publish": [
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 819.59784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "sections": "Subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "info": "Subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Publish</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "6091fb4464441f42962f3737"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-08-03T01:49:22Z",
      "title": "Describe your app for the catalog",
      "updated_at": "2021-05-05T01:53:28Z",
      "type": "developer",
      "external_id": "afe457b61d3ba06f63401c3e10b925e5362330dc",
      "document_type": "page",
      "popularity": 1,
      "info": "Describe your app for the catalog",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 695.421,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Describe <em>your</em> app for the catalog",
        "sections": "Describe <em>your</em> app for the catalog",
        "info": "Describe <em>your</em> app for the catalog",
        "body": " nerdlet, before starting this <em>one</em>. In the last lesson, you finished the A&#x2F;B test <em>application</em> you&#x27;ve been building throughout this course. Now, it&#x27;s time to prepare it for publication. When you <em>publish</em> <em>your</em> app to the <em>New</em> <em>Relic</em> <em>One</em> catalog, users can view it and subscribe to it. You can help <em>your</em> users"
      },
      "id": "6091fa9864441fdae82f3726"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.70532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help organize and find <em>your</em> data",
        "sections": "Use tags to help organize and find <em>your</em> data",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.36444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and storage. A browser <em>application</em> and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here&#x27;s a workload: <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in <em>your</em> workload"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.44104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in <em>your</em> solution, its alert status, and how the entities are connected, at a glance. See all <em>your</em> workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how <em>your</em> system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/ab-test/subscribe": [
    {
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/",
      "sections": [
        "Publish your New Relic One application",
        "Course",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Publish your New Relic One application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "f17b8d1fc30a296e6c4f0b4ef06c28e36672b87b",
      "document_type": "page",
      "popularity": 1,
      "info": "Publish your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Describe your app for the catalog, before starting this one. In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the Nerdpack's root-level package.json file. Every time you modify code in your Nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 7 Change to the publish/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 7 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 7 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 7 Replace all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively. Step 6 of 7 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 7 of 7 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Subscribe to your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 502.05246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Publish <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "sections": "Publish <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "info": "Publish <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": " accounts unless those apps are added to the public <em>New</em> <em>Relic</em> <em>One</em> catalog. Now that <em>your</em> app is published and its metadata is submitted, you can <em>subscribe</em> <em>your</em> account to the app from the catalog. In the next lesson, you&#x27;ll learn the ways to <em>subscribe</em> and unsubscribe to <em>your</em> <em>new</em> <em>application</em>. Course"
      },
      "id": "6091fb45e7b9d2820a5068b9"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.5148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags <em>to</em> help organize and find <em>your</em> data",
        "sections": "Use tags <em>to</em> help organize and find <em>your</em> data",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.44794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add navigation <em>to</em> <em>your</em> Nerdlet",
        "sections": "Add navigation <em>to</em> <em>your</em> Nerdlet",
        "info": "Add navigation <em>to</em> <em>your</em> Nerdlet",
        "body": " and <em>subscribe</em> to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> so that it can run on our platform instead of <em>your</em> own local server. Second, is to learn how to deal with some common issues you might see in <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> development. Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. Continue on to the next lesson: Describe <em>your</em> app for the catalog."
      },
      "id": "6091faf128ccbcb641a268f9"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 330.06122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and storage. A browser <em>application</em> and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here&#x27;s a workload: <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in <em>your</em> workload"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.12265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in <em>your</em> solution, its alert status, and how the entities are connected, at a glance. See all <em>your</em> workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how <em>your</em> system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/ab-test/serve-app": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/",
      "sections": [
        "Add chart components to your A/B test application",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add chart components to your A/B test application",
      "updated_at": "2021-05-05T01:53:29Z",
      "type": "developer",
      "external_id": "02161afd9e7762a927a1e95b6119f5b5fa6f7b9a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart components to your A/B test application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Serve your New Relic One application, before starting this one. The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add your first chart.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 936.3634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add chart components to <em>your</em> A&#x2F;B test <em>application</em>",
        "sections": "Add chart components to <em>your</em> A&#x2F;B test <em>application</em>",
        "info": "Add chart components to <em>your</em> A&#x2F;B test <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Serve</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "6091fa99e7b9d20804506901"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 914.4817,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a&#x2F;an Nerdlet Nerdpack item inside <em>your</em> Nerdpack. launcher catalog visualization In the next lesson, you&#x27;ll learn how to <em>serve</em> <em>your</em> Nerdpack locally and see <em>your</em> app in action! Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. Continue on to the next lesson: <em>Serve</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>."
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-08-02T10:05:18Z",
      "updated_at": "2021-08-02T10:05:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.70532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help organize and find <em>your</em> data",
        "sections": "Use tags to help organize and find <em>your</em> data",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-08-03T01:49:36Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.36444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and storage. A browser <em>application</em> and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here&#x27;s a workload: <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; (selected workload): The workloads UI provides a curated view of how the entities in <em>your</em> workload"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-08-02T10:04:13Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.44104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, <em>services</em>, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, <em>services</em>, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", not just the symptoms. Gain extensive visibility of each entity in <em>your</em> solution, its alert status, and how the entities are connected, at a glance. See all <em>your</em> workloads, and create a <em>new</em> <em>one</em> in a click. Get a high level view of how <em>your</em> system’s doing with the <em>New</em> <em>Relic</em> Navigator. Quickly grasp"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/ab-test/create-nerdpack": [
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 997.8668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to present that data, you might need to <em>create</em> something entirely unique. With the New Relic One SDK, we&#x27;ve provided you all the tools you&#x27;ll need to <em>create</em> your own visualizations. Build your custom visualization With the New Relic One SDK, you can <em>create</em> a <em>Nerdpack</em>, which houses your visualization code"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 590.40936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>advanced</em> configurations for your <em>Nerdpack</em>",
        "sections": "Enable <em>advanced</em> configurations for your <em>Nerdpack</em>",
        "info": "Enable <em>advanced</em> configurations for your <em>Nerdpack</em>",
        "body": ", and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 <em>create</em> --type <em>nerdpack</em> --name new-<em>nerdpack</em> RequestError: Error: self signed certificate in certificate chain Node uses its own"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    },
    {
      "image": "https://developer.newrelic.com/static/a618501b792e17a063fb841a8dcaa2bb/0086b/nerdlet-attached-to-app.png",
      "url": "https://developer.newrelic.com/build-apps/attach-nerdlet-to-entities/",
      "sections": [
        "Attach your Nerdlet to entities",
        "Before you begin",
        "Create a Nerdpack",
        "Configure your entities context",
        "Specify an entity domain",
        "Specify an entity type",
        "Specify entity tags",
        "Combine filters"
      ],
      "published_at": "2021-08-03T01:41:57Z",
      "title": "Attach your Nerdlet to entities",
      "updated_at": "2021-05-21T01:41:19Z",
      "type": "developer",
      "external_id": "36b82245d4253dfcef63961f0e01669eac041be8",
      "document_type": "page",
      "popularity": 1,
      "info": "Attach your Nerdlet to entities",
      "body": "One way for users to access your Nerdlet is by creating a launcher. The launcher opens a Nerdlet from the Apps page in New Relic. You can also provide access to your Nerdlet from an entity in your account. In this guide, you'll learn how to attach your Nerdlet to your entities. Before you begin If you haven't already: Sign up for a New Relic account Install and configure the New Relic One CLI Create a Nerdpack Step 1 of 5 Update your CLI: bash Copy $ nr1 update Step 2 of 5 Create a Nerdpack with the CLI: bash Copy $ nr1 create --type nerdpack --name entity-nerdlet This results in a Nerdpack, called entity-nerdlet, which consists of a launcher, called entity-nerdlet-launcher, and a Nerdlet, called entity-nerdlet-nerdlet. Step 3 of 5 Serve your Nerdpack: bash Copy $ cd entity-nerdlet $ nr1 nerdpack:serve Step 4 of 5 Go to https://one.newrelic.com/?nerdpacks=local, and navigate to Apps: ?nerdpacks=local is required to enable your locally served Nerdpacks to load in New Relic. Step 5 of 5 Under Your apps, click your launcher to view your New Relic One application: Attach your Nerdlet to entities You've seen how you can access your Nerdlet from a launcher. Now, access your Nerdlet from your entities. Step 1 of 6 From inside your Nerdpack's root directory, open nerdlets/entity-nerdlet-nerdlet/nr1.json. This is your Nerdlet's metadata file. You'll use this file to attach your Nerdlet to entities. Step 2 of 6 Add a context object with an entities array: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [] 8 } 9 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy This tells New Relic that you want to surface your Nerdlet in an array of entity contexts. Step 3 of 6 Add an entity context: nr1.json 1 { 2 \"schemaType\": \"NERDLET\", 3 \"id\": \"entity-nerdlet-nerdlet\", 4 \"displayName\": \"EntityNerdletNerdlet\", 5 \"description\": \"\", 6 \"context\": { 7 \"entities\": [ 8 { 9 \"domain\": \"APM\", 10 \"type\": \"APPLICATION\" 11 } 12 ] 13 } 14 } nerdlets/entity-nerdlet-nerdlet/nr1.json Copy Here, you've attached your Nerdlet to all application entities in the APM domain. Step 4 of 6 Go to APM: Because you're serving your Nerdpack locally, remember that you must still specify the ?nerdpacks=local query string. Step 5 of 6 Choose any of your applications: Step 6 of 6 Scroll down to see your Nerdlet attached to the application: Click this menu option and see your Nerdlet the same way you did with the launcher. Configure your entities context The context.entities key in your Nerdlet's nr1.json file specifies which entities your Nerdlet should be attached to. Specify an entity domain Attach your Nerdlet to a certain entity domain by specifying the domain as one of the following values: APM: Application Performance Monitoring BROWSER: Browser INFRA: Infrastructure monitoring MOBILE: Mobile monitoring SYNTH: Synthetic monitoring For example, attach your Nerdlet to all entities in the APM domain: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }] } } Copy Attach your Nerdlet to all entities except those in a domain: { \"context\": { \"entities\": [{ \"domain\": \"!APM\" }] } } Copy Attach your Nerdlet to all entities in multiple domains: { \"context\": { \"entities\": [{ \"domain\": \"APM\" }, { \"domain\": \"BROWSER\" }] } } Copy Specify an entity type Attach your Nerdlet to a certain entity type by specifying the type as one of the following values: APPLICATION HOST MONITOR For example, attach your Nerdlet to all entities of the APPLICATION type: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }] } } Copy Attach your Nerdlet to all entities except those of a specified type: { \"context\": { \"entities\": [{ \"type\": \"!APPLICATION\" }] } } Copy Attach your Nerdlet to every entity whose type matches one of an array of types: { \"context\": { \"entities\": [{ \"type\": \"APPLICATION\" }, { \"type\": \"MONITOR\" }] } } Copy Specify entity tags Attach your Nerdlet to entities that have a given tag. For example, attach your Nerdlet to the entity which has a particular GUID: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"guid\", \"values\": [\"<SOME ENTITY GUID>\"] } ] } ] } } Copy Attach your Nerdlet to every entity which has particular accountId and uses the Python programming language: { \"context\": { \"entities\": [ { \"tags\": [ { \"key\": \"accountId\", \"values\": [\"<SOME ACCOUNT ID>\"] }, { \"key\": \"language\", \"values\": [\"python\"] } ] } ] } } Copy Combine filters When you filter the entities to which your Nerdlet will be added, you can combine domain, type, and tags: { \"context\": { \"entities\": [ { \"domain\": \"APM\", \"type\": \"APPLICATION\", \"tags\": [ { \"key\": \"language\", \"values\": [\"python\"] } ] }, { \"domain\": \"SYNTH\", \"type\": \"MONITOR\" }, { \"domain\": \"BROWSER\" } ] } } Copy In this example, you've attached your Nerdlet to: All APM applications whose metadata tags specify the python language AND all Synthetic monitors AND all Browser entities",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 579.7817,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Attach</em> your Nerdlet to entities",
        "sections": "<em>Create</em> <em>a</em> <em>Nerdpack</em>",
        "info": "<em>Attach</em> your Nerdlet to entities",
        "body": " If you haven&#x27;t already: Sign up for a New Relic account Install and configure the New Relic One CLI <em>Create</em> a <em>Nerdpack</em> Step 1 of 5 Update your CLI: bash Copy $ nr1 update Step 2 of 5 <em>Create</em> a <em>Nerdpack</em> with the CLI: bash Copy $ nr1 <em>create</em> --type <em>nerdpack</em> --name entity-nerdlet This results in a <em>Nerdpack</em>"
      },
      "id": "609c84b7e7b9d237155068d3"
    },
    {
      "image": "https://developer.newrelic.com/static/c1fd6182602c7dbc74bf14b13dc1a4c0/0086b/dev-terms-and-conditions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Install and configure the New Relic One CLI",
      "updated_at": "2021-05-21T01:46:56Z",
      "type": "developer",
      "external_id": "a09ffc1a2296796669ad9d026d6c16937b23a3d4",
      "document_type": "page",
      "popularity": 1,
      "info": "Install and configure the New Relic One CLI",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 5 Go to the Build on New Relic quick start. Step 2 of 5 Get your API key: Once you install the CLI, you'll use this key to create a user profile that's associated with your account. The CLI uses this profile to manage entities within your account. Step 3 of 5 Read and accept the New Relic developer terms and conditions: Even if you install the CLI, you won't be able to use it without first accepting these terms and conditions. Step 4 of 5 Choose your operating system and click Download installer: Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version If you already had the CLI, update it: bash Copy $ nr1 update Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 5 of 5 Copy the command to save your credentials: This command has a profile name, your region, and your API key baked in. Run the command in your terminal: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you can exit the Build on New Relic quick start. You’re ready to build an application with the New Relic One CLI! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 548.90356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>and</em> configure the New Relic One CLI",
        "sections": "Install <em>and</em> configure the New Relic One CLI",
        "info": "Install <em>and</em> configure the New Relic One CLI",
        "body": ", before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To <em>create</em> a <em>Nerdpack</em> , you&#x27;ll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its <em>create</em> command. Install and configure the CLI Step 1"
      },
      "id": "6091faf1196a6714b4d52a39"
    },
    {
      "image": "https://developer.newrelic.com/static/fcc5c48e25ec18cb8ddf8518059586bb/0086b/new-message.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:21Z",
      "title": "Serve your New Relic One application",
      "updated_at": "2021-05-13T01:54:25Z",
      "type": "developer",
      "external_id": "79f6532d0c9e836788ebd0958c1158f062f0fd95",
      "document_type": "page",
      "popularity": 1,
      "info": "Locally serve your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Tip Here, you've seen how to access your Nerdlet from a launcher. If you want your Nerdlet closer to your data, you can also attach your Nerdlet to New Relic entities. Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 462.107,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve your New Relic One <em>application</em>",
        "sections": "Serve your New Relic One <em>application</em>",
        "info": "Locally serve your New Relic One <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Create</em> a <em>Nerdpack</em>, before"
      },
      "id": "6091fb4428ccbcfe3fa268f1"
    }
  ],
  "/build-apps/ab-test/navigation": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-08-03T01:49:22Z",
      "title": "Describe your app for the catalog",
      "updated_at": "2021-05-05T01:53:28Z",
      "type": "developer",
      "external_id": "afe457b61d3ba06f63401c3e10b925e5362330dc",
      "document_type": "page",
      "popularity": 1,
      "info": "Describe your app for the catalog",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 935.505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Describe <em>your</em> app for the catalog",
        "sections": "Describe <em>your</em> app for the catalog",
        "info": "Describe <em>your</em> app for the catalog",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>navigation</em> to <em>your</em>"
      },
      "id": "6091fa9864441fdae82f3726"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 665.86664,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>navigation</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.24048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a time picker <em>to</em> <em>your</em> app",
        "body": " 20 min <em>Add</em> a time picker to a sample application Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack <em>Add</em> <em>your</em> custom visualization to a dashboard 10 min <em>Add</em> <em>your</em> custom visualization to a New Relic dashboard Attach <em>your</em> <em>Nerdlet</em> to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.6886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdlets</em>",
        "body": " launcher for <em>your</em> Nerdpack and called it &quot;ab-test-launcher&quot;. Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher&#x27;s metadata file Use &quot;A&#x2F;B Test Launcher&quot; for the launcher&#x27;s displayName and &quot;Open the A&#x2F;B test <em>Nerdlet</em>"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.57031,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> details <em>to</em> describe <em>your</em> project",
        "info": "Build a &quot;Hello, World!&quot; app and publish it <em>to</em> New Relic One",
        "body": " default class MyAwesomeNerdpack<em>NerdletNerdlet</em> extends React.Component { render() { return &lt;h1&gt;&quot;Hello, World!&quot;&lt;&#x2F;h1&gt;; } } Copy Step 4 of 9 As an optional step, you can <em>add</em> a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in <em>your</em> new"
      },
      "id": "6091f9c864441f70d82f36c4"
    }
  ],
  "/build-apps/ab-test/add-charts": [
    {
      "image": "https://developer.newrelic.com/static/fcc5c48e25ec18cb8ddf8518059586bb/0086b/new-message.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:21Z",
      "title": "Serve your New Relic One application",
      "updated_at": "2021-05-13T01:54:25Z",
      "type": "developer",
      "external_id": "79f6532d0c9e836788ebd0958c1158f062f0fd95",
      "document_type": "page",
      "popularity": 1,
      "info": "Locally serve your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Tip Here, you've seen how to access your Nerdlet from a launcher. If you want your Nerdlet closer to your data, you can also attach your Nerdlet to New Relic entities. Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2755.653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve <em>your</em> New Relic One <em>application</em>",
        "sections": "Serve <em>your</em> New Relic One <em>application</em>",
        "info": "Locally serve <em>your</em> New Relic One <em>application</em>",
        "body": "&gt;; } } nerdlets&#x2F;ab-<em>test</em>-nerdlet&#x2F;index.js Copy <em>Your</em> app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. Continue on to the next lesson: <em>Add</em> <em>chart</em> <em>components</em> to <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>."
      },
      "id": "6091fb4428ccbcfe3fa268f1"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/",
      "sections": [
        "Add your first chart",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add your first chart",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "292725b4d7883e56c1178913f21337d18b92133c",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your first chart",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart components to your A/B test application, before starting this one. In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add pie charts.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1692.9829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>your</em> first <em>chart</em>",
        "sections": "<em>Add</em> <em>your</em> first <em>chart</em>",
        "info": "<em>Add</em> <em>your</em> first <em>chart</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>chart</em> <em>components</em> to <em>your</em>"
      },
      "id": "6091faf164441f0f032f3727"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.25742,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Build</em> <em>apps</em>",
        "sections": "<em>Add</em> the NerdGraphQuery <em>component</em> <em>to</em> <em>an</em> <em>application</em>",
        "body": " building apps, and dive into our library of <em>components</em>. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps <em>Add</em> the NerdGraphQuery component to an <em>application</em> 20 minutes The NerdGraphQuery component allows you to query data"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add pie charts",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "cd10196320620683a525a97cc3770662466e5134",
      "document_type": "page",
      "popularity": 1,
      "info": "Add pie charts",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.89116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> pie <em>charts</em>",
        "sections": "<em>Add</em> pie <em>charts</em>",
        "info": "<em>Add</em> pie <em>charts</em>",
        "body": " starting this one. You’ve begun building <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>. So far, it consists of a single line <em>chart</em>, which represents the number of subscriptions <em>your</em> newsletter receives from each version of <em>your</em> website. To understand what you’ll build in this lesson, review the design guide"
      },
      "id": "6091fb44e7b9d280165068d6"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add user interface components to your application",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "ed894ca79a689bdfbf6cff8d64273d4921872e41",
      "document_type": "page",
      "popularity": 1,
      "info": "Add user interface components to your application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.59688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> user interface <em>components</em> <em>to</em> <em>your</em> <em>application</em>",
        "sections": "<em>Add</em> user interface <em>components</em> <em>to</em> <em>your</em> <em>application</em>",
        "info": "<em>Add</em> user interface <em>components</em> <em>to</em> <em>your</em> <em>application</em>",
        "body": " for ending <em>your</em> A&#x2F;<em>B</em> <em>test</em>. Before you <em>add</em> user any UI <em>components</em> to <em>your</em> <em>application</em>, remind yourself of how <em>your</em> <em>application</em> will look when you finish: In the next lesson, you arrange <em>your</em> charts to look like they do in <em>your</em> design guide. Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> a grid."
      },
      "id": "6091fb4464441f44672f36fa"
    }
  ],
  "/build-apps/ab-test/first-chart": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/",
      "sections": [
        "Add chart components to your A/B test application",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add chart components to your A/B test application",
      "updated_at": "2021-05-05T01:53:29Z",
      "type": "developer",
      "external_id": "02161afd9e7762a927a1e95b6119f5b5fa6f7b9a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart components to your A/B test application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Serve your New Relic One application, before starting this one. The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add your first chart.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 732.15765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>chart</em> components to <em>your</em> A&#x2F;B test application",
        "sections": "<em>Add</em> <em>chart</em> components to <em>your</em> A&#x2F;B test application",
        "info": "<em>Add</em> <em>chart</em> components to <em>your</em> A&#x2F;B test application",
        "body": " to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>your</em> <em>first</em> <em>chart</em>."
      },
      "id": "6091fa99e7b9d20804506901"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add pie charts",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "cd10196320620683a525a97cc3770662466e5134",
      "document_type": "page",
      "popularity": 1,
      "info": "Add pie charts",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 542.0757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> pie <em>charts</em>",
        "sections": "<em>Add</em> pie <em>charts</em>",
        "info": "<em>Add</em> pie <em>charts</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>your</em> <em>first</em> <em>chart</em>, before"
      },
      "id": "6091fb44e7b9d280165068d6"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.74507,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Your</em> <em>first</em> visualization",
        "body": "When you create a dashboard, you <em>add</em> a variety of charts to visualize <em>your</em> New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in <em>your</em> dashboard Update their names, display options, and underlying data queries"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "sections": [
        "Micrometer metrics registry",
        "Find your data"
      ],
      "title": "Micrometer metrics registry",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "Micrometer"
      ],
      "external_id": "2311ecf33c1893da033f0513244d4fc6cb24a004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry/",
      "published_at": "2021-08-02T09:05:50Z",
      "updated_at": "2021-08-02T09:05:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Micrometer provides a simple facade over the instrumentation clients for the most popular monitoring systems, allowing you to instrument your JVM-based application code without vendor lock-in. New Relic's Micrometer metrics registry sends your Micrometer telemetry data to your New Relic account. Don't have one? Sign up for free. No credit card required. Resources for our Micrometer integration: README Integration specs Find your data To find your data, go to one.newrelic.com and go to Your applications > Explorer. From the Entities screen, search for your service by name. New Relic provides an out-of-the-box overview that includes charts for some of the most useful metrics provided by Micrometer Spring Boot instrumentation. You can use the out-of-the-box overview as a starting point to build your own dashboards. Click on the ... icon in a chart to add that chart to a dashboard or view the query behind the chart to modify it and it add it to your dashboard. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.23685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find <em>your</em> data",
        "body": " an out-of-the-box overview that includes charts for some of the most useful metrics provided by Micrometer Spring Boot instrumentation. You can use the out-of-the-box overview as a starting point to build <em>your</em> own dashboards. Click on the ... icon in a <em>chart</em> to <em>add</em> that <em>chart</em> to a dashboard or view"
      },
      "id": "603e81b528ccbcb3b7eba763"
    },
    {
      "sections": [
        "Garbage collection",
        "Important",
        "Enable garbage collection instrumentation",
        "View app-wide GC statistics",
        "View detailed GC metrics",
        "For more help"
      ],
      "title": "Garbage collection",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Features"
      ],
      "external_id": "9981cf22973c76aec7d8d0ac31c2793e04a42e48",
      "image": "https://docs.newrelic.com/static/e2fdc5c35adef00b9a2646a1ec6589c9/c1b63/garbage_collection_overview.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/features/garbage-collection/",
      "published_at": "2021-08-02T08:38:44Z",
      "updated_at": "2021-08-02T08:38:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Garbage collection (GC) finds unused data objects and reclaims that memory space for use by another process. The New Relic Ruby agent can collect information about how much time is spent in garbage collection for applications running on MRI 1.9.2 or higher or Ruby Enterprise Edition, but you must explicitly enable this feature in your application. Important Avoid using garbage collection in production for long periods of time, as it increases overhead. Enable garbage collection instrumentation To activate the feature, add the appropriate call in your application initialization. MRI 1.9.2 or higher: GC::Profiler.enable Ruby Enterprise Edition: GC.enable_stats For Rails applications, you can either add this call to an initializer in config/initializers, or add it directly to your config/application.rb file. View app-wide GC statistics To view overall garbage collection statistics: Log into New Relic, select a Ruby app, and go to Summary. From the APM Summary page, look for GC Execution statistics on the Web transactions time chart. one.newrelic.com > APM > (select a Ruby app) > Summary: On the Web transactions time chart, garbage collection statistics are labeled GC Execution. View detailed GC metrics To view garbage collection metrics on a per-transaction basis, go to one.newrelic.com > APM > (select a Ruby app) > Transactions > (select a transaction). You can then view the amount of time spent in GC, and the average number of times GC is called for each transaction. Hide other labels for a detailed view of garbage collection. one.newrelic.com > APM > (select a Ruby app) > Transactions > (select a transaction): Select an individual transaction to view detailed GC metrics, including average time and average number of calls. Detailed information includes: Garbage collection details Comments Trend of garbage collection time Garbage collection usually takes a small amount of time, and therefore the trend line may not be visible in your charts. To view the trend in garbage collection time, navigate to the overview chart or to detailed transaction metrics. Then, hide every chart label except GC Execution by selecting each label. Average number of calls To view the average number of garbage collection calls for each controller action: From your APM Summary page, select Transaction. Then select a controller action and view the App Server Breakdown. For more help Additional documentation resources include: APM Summary page (features and drill-down details when using the APM Summary page) Transactions page (features and drill-down details for transactions) Ruby agent configuration (update procedures and configuration file values, including general, proxy, transaction traces, and error collector)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.28525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " explicitly enable this feature in <em>your</em> application. Important Avoid using garbage collection in production for long periods of time, as it increases overhead. Enable garbage collection instrumentation To activate the feature, <em>add</em> the appropriate call in <em>your</em> application initialization. MRI 1.9.2"
      },
      "id": "603eba3a28ccbcb144eba7aa"
    }
  ],
  "/build-apps/ab-test/add-ui": [
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add a chart group",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6ad93629eaf632d87125194995d2b7caa432f548",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a chart group",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1210.7433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a chart group",
        "sections": "<em>Add</em> a chart group",
        "info": "<em>Add</em> a chart group",
        "body": " that teaches you how to build a New Relic One <em>application</em> from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>user</em> <em>interface</em> <em>components</em> to <em>your</em> <em>application</em>."
      },
      "id": "6091faf1196a6726c2d52a20"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add a grid",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "fab1a23ddf5003cd0fb8189b903f3707a97d66e5",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a grid",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1189.6365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> a grid",
        "sections": "<em>Add</em> a grid",
        "info": "<em>Add</em> a grid",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>user</em> <em>interface</em>"
      },
      "id": "6091faf228ccbcbfe2a268f2"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.7922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> the NerdGraphQuery <em>component</em> <em>to</em> an <em>application</em>",
        "body": " building apps, and dive into our library of <em>components</em>. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps <em>Add</em> the NerdGraphQuery component to an <em>application</em> 20 minutes The NerdGraphQuery component allows you to query data"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Connect Google Cloud Platform services to New Relic",
        "Requirements",
        "Authorization options",
        "Service account (recommended)",
        "User account",
        "Connect GCP to New Relic infrastructure monitoring",
        "Tip",
        "Explore app data in New Relic",
        "Link multiple Google projects",
        "Unlink your GCP integrations"
      ],
      "title": "Connect Google Cloud Platform services to New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Google Cloud Platform integrations",
        "Get started"
      ],
      "external_id": "05934d2b03ec1ac5fa43298b21a06dc2e0f8c3b9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/google-cloud-platform-integrations/get-started/connect-google-cloud-platform-services-new-relic/",
      "published_at": "2021-08-02T12:39:29Z",
      "updated_at": "2021-08-02T12:39:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To start receiving Google Cloud Platform (GCP) data with New Relic GCP integrations, connect your Google project to New Relic infrastructure monitoring. If you don't have one already, create a New Relic account. It's free, forever. Requirements These are the requirements for the authorization: GCP integration requirements Comments Monitoring In the GCP project API & Services Library settings, you must enable Google Stackdriver Monitoring API. Authorization For service account authorization (recommended): A user with Project IAM Admin role is needed to add the service account ID as a member in your GCP project. In the GCP project IAM & admin, the service account must have the Project Viewer role and the Service Usage Consumer role or, alternatively, a custom role. For user account authorization: The New Relic user that will integrate the GCP project must have a Google account and must be able to view the GCP project that New Relic will monitor. In the GCP project IAM & admin, the user must have the Project Viewer role. Please note that this authorization method will not allow New Relic to collect labels and other inventory attributes that can be useful for narrowing down your NRQL queries, dashboards and alerts. You can migrate the authorization method from user account to service account from the Manage services link in New Relic's user interface. Project name As part of the online setup process, you must identify Project name of the projects you want to monitor with New Relic. The UI workflow automatically lists active projects you can select. Permissions (only for user account authorization) New Relic requires a specific set of read-only permissions exclusively; this means that, for certain integrations, only partial inventory data will be available. Keep in mind that New Relic doesn't inherit your Google account's permissions and therefore is not authorized to perform any changes in the project. For more information about the API permissions that New Relic uses, see the Google documentation about scopes. Authorization options Integrating your GCP project with New Relic requires you to authorize New Relic to fetch monitoring data from your GCP project. You can choose between two authorization methods: Service accounts or User accounts. Service account (recommended) The service account authorization is recommended. If you authorize New Relic to fetch data through a service account, we will call your GCP project APIs using a service account ID and its associated public/private key pair. New Relic manages a specific Google service account for your New Relic account; you do not need to create it or manage the associated private key. Just add the service account ID as a member with viewing permissions in your project. This authorization method is recommended, especially if your GCP project is managed by a team. It also guarantees that New Relic will collect labels and inventory attributes whenever possible. User account If you authorize New Relic to fetch data through a user account, New Relic will access your GCP project monitoring data on behalf of a particular Google user. The authorization process is achieved through an OAuth workflow, which redirects you from the New Relic UI to a Google authorization interface. However, since the authorization is linked to a particular Google user, this method is not recommended for GCP projects that are managed by large teams. Connect GCP to New Relic infrastructure monitoring To connect your Google account to New Relic with user account authorization: Go to one.newrelic.com > Infrastructure > GCP. At the top of Infrastructure's Google Cloud Services integrations page, select Add a GCP account. Choose Authorization Method: Select either Authorize a Service Account or Authorize a User Account, and follow the instructions in the UI to authorize New Relic. Add projects: Select the projects that you want New Relic to receive data from. Select services: From the list of available services for your GCP account, select the individual services you want New Relic to receive data from, or select all of the services. Tip These services will be enabled for all of the projects that you selected in the previous step. Once the setup process is finished, you can fine-tune the services that you want monitored for each project individually. To complete the setup process, select Finish. If you see API authentication errors, follow the troubleshooting procedures. Explore app data in New Relic After you authorize New Relic to integrate one or more of your Google project's services, New Relic starts monitoring your GCP data at regular polling intervals. After a few minutes, data will appear in the New Relic UI. To find and use your data, including links to dashboards and alert settings, go to one.newrelic.com > Infrastructure > GCP. Link multiple Google projects For your convenience, the setup process allows you to select more than one project at a time. After the first setup, if you need to monitor additional GCP projects with New Relic, you can repeat the procedure to connect your GCP services as many times as you need. Unlink your GCP integrations You can disable any of your GCP integrations any time and still keep your Google project connected to New Relic. If you want to... Do this Disable a GCP service monitoring To disconnect individual GCP services but keep the integration with New Relic for other GCP services in your Google account: Go to one.newrelic.com > Infrastructure > GCP and select Manage services. From your GCP account page, make changes to the checkbox options for available services and select Save changes. Unlink your project monitoring To uninstall all of your GCP services completely from New Relic Integrations, unlink your Google account: Go to one.newrelic.com > Infrastructure > GCP and select Manage services. From your GCP account page, select Unlink account and select Save changes. Clean your GCP Projects after unlinking New Relic To clean your GCP project after unlinking, follow these steps if you were using a service account: Open the GCP IAM Console. Select the project you want to unlink from New Relic and click Open. Select the service account that is used by New Relic. Click the Remove icon. Or follow these steps if you were using a user account: Open your Google user account settings. Open the Apps with access to your account section. Choose New Relic application. Choose Remove Access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.01813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Connect Google Cloud Platform services <em>to</em> New Relic",
        "sections": "<em>User</em> account",
        "body": " to fetch data through a <em>user</em> account, New Relic will access <em>your</em> GCP project monitoring data on behalf of a particular Google <em>user</em>. The authorization process is achieved through an OAuth workflow, which redirects you from the New Relic UI to a Google authorization <em>interface</em>. However, since"
      },
      "id": "603e8309196a67fc4fa83da7"
    },
    {
      "sections": [
        "Compatibility and requirements for Browser Monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for Browser Monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-08-03T08:10:03Z",
      "updated_at": "2021-08-03T08:10:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the browser agent, make sure your system meets these requirements. Want to try out our browser monitoring? Create a New Relic account for free! No credit card required. Basic requirements To report data to browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the browser agent for apps monitored by APM, or you can deploy the browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying browser for an app using APM, make sure your agent supports browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use our SPA monitoring features, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with browser. In all cases, the browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our Pro+SPA agent due to the way this library wraps promises. If you're using this library, we recommend selecting the Pro agent type. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organization’s standard procedures in order to install the browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.90323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " card required. Basic requirements To report data to browser, <em>your</em> <em>application</em> must at a minimum meet two basic requirements: The traffic to the <em>application</em> must be from clients able to load and execute browser JavaScript code and set cookies. Clients accessing the <em>application</em> must be able to send"
      },
      "id": "603ed6b664441f4a784e883f"
    }
  ],
  "/build-apps/ab-test/nrql": [
    {
      "image": "https://developer.newrelic.com/static/39196df35b3f160bf0ac9eeab116b112/ba3ac/real-table-chart-data.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Customize NRQL data",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "52491e06cfe78faf65a628e3a553720f3ce4d318",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize NRQL data",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 536.85504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize <em>NRQL</em> data",
        "sections": "Customize <em>NRQL</em> data",
        "info": "Customize <em>NRQL</em> data",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>NrqlQuery</em> <em>components</em>"
      },
      "id": "6091faf228ccbcbadfa268f9"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-08-03T01:47:21Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 327.49786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure <em>your</em> custom visualization",
        "sections": "Configure <em>your</em> custom visualization",
        "info": "Configure <em>your</em> custom visualization",
        "body": "} data={data} &gt; &lt;RadialBar background dataKey=&#x27;val&#x27; &#x2F;&gt; &lt;Legend layout=&#x27;vertical&#x27; verticalAlign=&#x27;middle&#x27; align=&quot;right&quot; iconType={iconType} &#x2F;&gt; &lt;&#x2F;RadialBarChart&gt; ) } } index.js Copy <em>nrql</em> A <em>nrql</em> property is rendered in the UI as a text box and represents a <em>NRQL</em> <em>query</em>. You can use the <em>NrqlQuery</em> component"
      },
      "id": "6091fa3a64441fa2172f3714"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Present an end test confirmation modal",
      "updated_at": "2021-05-05T01:54:59Z",
      "type": "developer",
      "external_id": "d304e6d4f2b5f3ca8465df20913b58f4360652d7",
      "document_type": "page",
      "popularity": 1,
      "info": "Present an end test confirmation modal",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. The modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Go back to https://one.newrelic.com?nerdpacks=local, and view your changes. Select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 314.64087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Show and hide <em>your</em> confirmation modal",
        "body": " lesson, you&#x27;ll replace the mocked data in <em>your</em> charts with real data from <em>your</em> backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>NrqlQuery</em> <em>components</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6091faf428ccbcbe03a268f3"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add PlatformStateContext to your Nerdlet",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "6edbd6af98a61e096299b62128857adddcdf37eb",
      "document_type": "page",
      "popularity": 1,
      "info": "Add PlatformStateContext to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 297.58368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " }) =&gt; { return &lt;LineChart data={data} fullWidth &#x2F;&gt;; } } &lt;&#x2F;<em>NrqlQuery</em>&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js Copy Important Make sure you replace &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; with <em>your</em> actual New Relic account ID. Notice that <em>NrqlQuery</em> uses"
      },
      "id": "6091fb44196a674b77d52a53"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course",
        "Important",
        "Tip"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Add navigation to your Nerdlet",
      "updated_at": "2021-05-05T01:54:57Z",
      "type": "developer",
      "external_id": "6aff1895474c7986c2be108531ec00ba088a11cc",
      "document_type": "page",
      "popularity": 1,
      "info": "Add navigation to your Nerdlet",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps. Click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.6931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "info": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": "} &gt; { ({ data }) =&gt; { return &lt;LineChart data={data} fullWidth &#x2F;&gt;; } } &lt;&#x2F;<em>NrqlQuery</em>&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js Copy Important Make sure you replace &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; and &lt;<em>YOUR</em> NEW RELIC ENTITY GUID&gt; with <em>your</em> actual New Relic"
      },
      "id": "6091faf128ccbcb641a268f9"
    }
  ],
  "/build-apps/add-visualizations-to-dashboard": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 533.66565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-08-03T01:43:03Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.81927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build your first custom <em>visualization</em>",
        "sections": "Build your first custom <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " <em>One</em> <em>catalog</em> Add your visualization to a dashboard Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create a new visualization Use <em>nr1</em> to generate the boilerplate for a new visualization"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with configuration options",
        "Course",
        "Tip",
        "Add a new configuration option",
        "Replace your SegmentedControl with the configurable property",
        "Summary"
      ],
      "title": "Customize your visualization with configuration options",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9028e58f383ea362d2c9d3a7ecd6404dbfeac87c",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/customize-visualizations-with-configuration/",
      "published_at": "2021-08-03T01:40:51Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization using configuration",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Custom visualizations and the New Relic One SDK, before starting this one. In the previous lesson, you built a custom visualization that shows queried data in one of two chart types: RadarChart Treemap You used a SegmentedControl to switch between the two chart types in the visualization UI. This implementation takes up space in the visualization, but it offers your users the choice to switch between two chart types even after you've created an instance of your chart. But what if you only need to be able to select an option once, when initializing the visualization? In this lesson you'll learn how to add a configuration option to your visualization which replaces the SegmentedControl. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Add a new configuration option Step 1 of 8 In your visualization's nr1.json file, add an enum configuration object for selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve If you're still serving your Nerdpack from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to nr1.json. Step 4 of 8 Go to https://one.newrelic.com/?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from the local server. Step 5 of 8 Open the Apps page: Step 6 of 8 Go to Custom Visualizations, which is favorited by default: Step 7 of 8 In Custom Visualizations, find and click your visualization: Step 8 of 8 Notice the new Select chart configuration option: Selecting a chart type doesn't effect your visualization. This is because you first need to introduce the selectedChart property to the visualization component. Then, you use selectedChart to determine the chart type to render. Replace your SegmentedControl with the configurable property Step 1 of 5 Open your visualization's index.js file. You'll be working here for the rest of the guide. Step 2 of 5 In render(), include selectedChart as a constant you get from destructuring props, and remove your component's state: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now that you're using selectedChart from the configuration options instead of component state, you can select a chart in the configuration panel and watch the visualization change. Unfortunately, there's a bug. The default chart option is Radar, but the initial render shows a Treemap. Step 3 of 5 Update your ternary expression to account for the case where there is no selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now, your data is rendered in a RadarChart if you haven't yet configured the option. Step 4 of 5 Remove SegmentedControl from render(): index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 Spinner, 18 } from 'nr1'; 19 20 const CHART_TYPES = { 21 'Radar': 'radar', 22 'Treemap': 'treemap' 23 } 24 25 export default class RadarOrTreemapVisualization extends React.Component { 26 // Custom props you wish to be configurable in the UI must also be defined in 27 // the nr1.json file for the visualization. See docs for more details. 28 static propTypes = { 29 /** 30 * A fill color to override the default fill color. This is an example of 31 * a custom chart configuration. 32 */ 33 fill: PropTypes.string, 34 35 /** 36 * A stroke color to override the default stroke color. This is an example of 37 * a custom chart configuration. 38 */ 39 stroke: PropTypes.string, 40 /** 41 * An array of objects consisting of a nrql `query` and `accountId`. 42 * This should be a standard prop for any NRQL based visualizations. 43 */ 44 nrqlQueries: PropTypes.arrayOf( 45 PropTypes.shape({ 46 accountId: PropTypes.number, 47 query: PropTypes.string, 48 }) 49 ), 50 }; 51 52 /** 53 * Restructure the data for a non-time-series, facet-based NRQL query into a 54 * form accepted by the Recharts library's RadarChart. 55 * (https://recharts.org/api/RadarChart). 56 */ 57 transformData = (rawData) => { 58 return rawData.map((entry) => ({ 59 name: entry.metadata.name, 60 // Only grabbing the first data value because this is not time-series data. 61 value: entry.data[0].y, 62 })); 63 }; 64 65 /** 66 * Format the given axis tick's numeric value into a string for display. 67 */ 68 formatTick = (value) => { 69 return value.toLocaleString(); 70 }; 71 72 render() { 73 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 74 75 const nrqlQueryPropsAvailable = 76 nrqlQueries && 77 nrqlQueries[0] && 78 nrqlQueries[0].accountId && 79 nrqlQueries[0].query; 80 81 if (!nrqlQueryPropsAvailable) { 82 return <EmptyState />; 83 } 84 85 return ( 86 <AutoSizer> 87 {({width, height}) => ( 88 <NrqlQuery 89 query={nrqlQueries[0].query} 90 accountId={parseInt(nrqlQueries[0].accountId)} 91 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 92 > 93 {({data, loading, error}) => { 94 if (loading) { 95 return <Spinner />; 96 } 97 98 if (error) { 99 return <ErrorState />; 100 } 101 102 const transformedData = this.transformData(data); 103 104 return ( 105 <React.Fragment> 106 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 107 <RadarChart 108 width={width} 109 height={height} 110 data={transformedData} 111 > 112 <PolarGrid /> 113 <PolarAngleAxis dataKey=\"name\" /> 114 <PolarRadiusAxis tickFormatter={this.formatTick} /> 115 <Radar 116 dataKey=\"value\" 117 stroke={stroke || '#51C9B7'} 118 fill={fill || '#51C9B7'} 119 fillOpacity={0.6} 120 /> 121 </RadarChart> 122 ) : ( 123 <Treemap 124 width={width} 125 height={height} 126 data={transformedData} 127 dataKey=\"value\" 128 ratio={4 / 3} 129 stroke={stroke || '#000000'} 130 fill={fill || '#51C9B7'} 131 /> 132 )} 133 </React.Fragment> 134 ); 135 }} 136 </NrqlQuery> 137 )} 138 </AutoSizer> 139 ); 140 } 141 } 142 143 const EmptyState = () => ( 144 <Card className=\"EmptyState\"> 145 <CardBody className=\"EmptyState-cardBody\"> 146 <HeadingText 147 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 148 type={HeadingText.TYPE.HEADING_3} 149 > 150 Please provide at least one NRQL query & account ID pair 151 </HeadingText> 152 <HeadingText 153 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 154 type={HeadingText.TYPE.HEADING_4} 155 > 156 An example NRQL query you can try is: 157 </HeadingText> 158 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 159 </CardBody> 160 </Card> 161 ); 162 163 const ErrorState = () => ( 164 <Card className=\"ErrorState\"> 165 <CardBody className=\"ErrorState-cardBody\"> 166 <HeadingText 167 className=\"ErrorState-headingText\" 168 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 169 type={HeadingText.TYPE.HEADING_3} 170 > 171 Oops! Something went wrong. 172 </HeadingText> 173 </CardBody> 174 </Card> 175 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 5 of 5 Serve your Nerdpack locally, and view it in the Custom Visualizations app in New Relic. Select a chart type from the dropdown in the configuration sidebar, and see your visualization update to show the matching chart type: Summary Congratulations on completing this lesson! You've learned how to customize your visualization using nr1.json configuration. Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Add custom visualizations to your dashboards.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.44388,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with configuration options",
        "sections": "Customize your <em>visualization</em> with configuration options",
        "info": "Customize your <em>visualization</em> using configuration",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": "&quot;: &quot;Stroke color&quot;, 51 &quot;description&quot;: &quot;A stroke color to override the default stroke color&quot;, 52 &quot;type&quot;: &quot;string&quot; 53 } 54 ] 55 } <em>visualizations</em>&#x2F;radar-or-treemap&#x2F;<em>nr1</em>.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ <em>nr1</em>"
      },
      "id": "6091fa3ae7b9d2df595068c1"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-08-03T01:40:59Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.6973,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize your <em>visualization</em> with SDK components",
        "sections": "Customize your <em>visualization</em> with SDK components",
        "info": "Customize your <em>visualization</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the steps in the <em>nr1</em> quick start to install and configure the <em>CLI</em> Create your visualization Step <em>1</em> of 2 Ensure you&#x27;re working with the latest version of the New Relic <em>One</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 283.59103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Most of the time, the <em>nr1</em> <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, Nerdlets, launchers, and <em>visualizations</em> without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    }
  ],
  "/explore-docs/custom-viz": [
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-08-03T01:47:21Z",
      "title": "Configure your custom visualization",
      "updated_at": "2021-07-30T01:54:31Z",
      "type": "developer",
      "external_id": "0e003f6969afc000081b6fd8119850c013d3fd60",
      "document_type": "page",
      "popularity": 1,
      "info": "Configure your custom visualization",
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack items all have nr1.json metadata files. The schemaType describes the item's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.31625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure your <em>custom</em> <em>visualization</em>",
        "sections": "Configure your <em>custom</em> <em>visualization</em>",
        "info": "Configure your <em>custom</em> <em>visualization</em>",
        "body": ": <em>Nerdpack</em> items all have <em>nr1</em>.json metadata files. The schemaType describes the item&#x27;s schema. For all <em>visualizations</em>, schemaType is VISUALIZATION. id: Your visualization&#x27;s string identifier. This must be unique within a given <em>Nerdpack</em>, but it doesn&#x27;t need to be unique across all Nerdpacks. displayName"
      },
      "id": "6091fa3a64441fa2172f3714"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 239.8299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " the New Relic One CLI, before starting this one. A <em>Nerdpack</em> is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a <em>Nerdpack</em>, use the New Relic One CLI: bash Copy $ <em>nr1</em> create --type"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.75354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nr1</em> cli",
        "body": " is up-to-date: bash Copy $ <em>nr1</em> update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your <em>Nerdpack</em>. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-08-03T01:41:57Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.48726,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your <em>custom</em> <em>visualization</em> to a dashboard",
        "sections": "Add your <em>custom</em> <em>visualization</em> to a dashboard",
        "info": "Add your <em>custom</em> <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>nr1</em> cli",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your <em>custom</em> visualization to a dashboard Step <em>1</em> of 7 From the root directory of your <em>Nerdpack</em>, publish and subscribe to your visualization: bash Copy $ <em>nr1</em> <em>nerdpack</em>:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "sections": [
        "Serve your Nerdpack",
        "Update your CLI",
        "Serve your Nerdpack locally",
        "Tip",
        "Resolve issues with accessing your local Nerdpack",
        "Debug your application",
        "Show locally served Nerdpacks",
        "Check your local profile",
        "Access your proxy browser",
        "Further reading"
      ],
      "title": "Serve your Nerdpack",
      "type": "developer",
      "tags": [
        "nerdpack",
        "serve"
      ],
      "external_id": "68265f2e6bd7aa212121268ee10ff068272663ec",
      "image": "https://developer.newrelic.com/static/4560bce9c6a1165799e6eaf9d10f4868/0086b/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/serve/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-05-21T01:47:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to serve your Nerdpack locally",
      "body": "Serve your Nerdpack locally when it's still in development and you're not ready to share it with others. You'll use your own machine's resources, but you'll see the Nerdpack in the New Relic platform as you would if it were published. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Serve your Nerdpack locally Step 1 of 5 In the root folder of your Nerdpack, run the nerdpack:serve command: bash Copy $ nr1 nerdpack:serve If you've successfully served your Nerdpack, you should see some success output, including: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! While your Nerdpack is being served locally, the server will automatically reload your Nerdpack when it detects that you've modified a file. This doesn't include the metadata file nr1.json or the styles file styles.css. If you update those files, you need to stop your local server with CTRL+C and restart it with nr1 nerdpack:serve. Step 2 of 5 Go to https://one.newrelic.com/?nerdpacks=local: New Relic requires the ?nerdpacks=local query string to load locally served Nerdpacks. Step 3 of 5 Navigate to Apps: Whether you're creating a New Relic One application or a custom visualization, you'll find your project under Apps. Step 4 of 5 If you're serving a Nerdpack with a launcher and a Nerdlet, you'll find your local app under Your apps: If you're serving a Nerdpack with a visualization, go to Favorite apps > Custom Visualizations: Tip If Custom Visualizations isn't favorited, you can find it under Your apps. From Custom Visualizations, you'll see your visualization: Whether you're serving a Nerdpack for an app or a visualization, you'll see a </> Local indicator on its UI tile. Use this to distinguish between published Nerdpacks and locally served Nerdpacks. Step 5 of 5 When you're ready to stop serving your Nerdpack locally, type CTRL+C into your terminal where the server is running. Resolve issues with accessing your local Nerdpack Sometimes, when you serve your Nerdpack locally, you may come across issues. You may be unable to serve your Nerdpack because of bugs in your code. Or, you may successfully serve your Nerdpack but be unable to find it in New Relic. Consider some common solutions for resolving these issues. Debug your application When you attempt to serve your Nerdpack locally, carefully read the output of your nr1 command. You may receive success output, including: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! However, the output may show some errors in your Nerdpack instead. It may also help you to view more verbose output. Use the --verbose command to show more content: bash Copy $ nr1 nerdpack:serve --verbose Show locally served Nerdpacks If you don't find your Nerdpack in New Relic, make sure you're using the ?nerdpacks=local query string. If you're not, New Relic won't load your locally served Nerdpack on the platform. Check your local profile With nr1, you can set a default New Relic profile. This profile is used for all commands unless otherwise specified with the command's --profile option. When you serve your Nerdpack with nr1 nerdpack:serve, you must be signed into the same profile in New Relic that you're serving with locally. So, if you don't find your Nerdpack in New Relic and you're using the correct query string, compare your local profile with the profile you're using in the browser to make sure they're the same. Access your proxy browser Generally, you don't need to know how your application code is loaded in New Relic. But understanding how it works can help you resolve issues with your local server. When you run nr1 nerdpack:serve, your code is served by your local machine using an nr-local.net subdomain. This domain points to 127.0.0.1, and uses a variety of ports to connect, including 9973. To load a Nerdpack into the platform, whether it's locally served or published to the app catalog, New Relic uses an <IFRAME> and a separate domain (a subdomain of nr-ext.net), relying on same-domain policy to sandbox the code. So, if you don't find your Nerdpack in New Relic, you're using the correct query string, and you're using the correct profile, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where <UserId> is a 32-hexadecimal character identifier that is unique to the user logged into the platform. You can use [0-9a-f]{32} to discriminate it. Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where <NerdpackUuid> is the UUID assigned to your package, and <NerdpackGid> is zero, or a positive integer. You can use 0|[1-9]\\d+ to discriminate it. Further reading Read the nr1 nerdpack:serve documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 nerdpack:serve --help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.73918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve your <em>Nerdpack</em>",
        "sections": "Serve your <em>Nerdpack</em>",
        "info": "Learn to serve your <em>Nerdpack</em> locally",
        "tags": "<em>nerdpack</em>",
        "body": " have the latest version of the CLI: bash Copy $ <em>nr1</em> update Serve your <em>Nerdpack</em> locally Step <em>1</em> of 5 In the root folder of your <em>Nerdpack</em>, run the <em>nerdpack</em>:serve command: bash Copy $ <em>nr1</em> <em>nerdpack</em>:serve If you&#x27;ve successfully served your <em>Nerdpack</em>, you should see some success output, including: bash Copy"
      },
      "id": "6091fb4464441f53fd2f36d0"
    }
  ],
  "/explore-docs/custom-viz/configuration-options": [
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-08-03T01:43:03Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 449.47342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>your</em> first <em>custom</em> <em>visualization</em>",
        "sections": "Build <em>your</em> first <em>custom</em> <em>visualization</em>",
        "info": "Create a <em>custom</em> data view and add it to a dashboard",
        "tags": "Subscribe <em>visualizations</em>",
        "body": " for <em>your</em> <em>visualization</em>. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the <em>Configure</em> <em>your</em> <em>custom</em> <em>visualization</em> article. index.js defines the React component that receives"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "image": "https://developer.newrelic.com/static/3ed141add1fead9eec2fce6cc5dec70e/0086b/nerdgraph-create-dashboard-with-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/add-to-dashboard-nerdgraph/",
      "sections": [
        "Add your custom visualization to a dashboard with NerdGraph",
        "Before you begin",
        "Create and publish your Nerdpack",
        "Further reading",
        "Describe your visualization options with JSON",
        "Tip",
        "Create a new dashboard with your visualization",
        "Important",
        "Add your visualization to an existing dashboard",
        "Send your request to NerdGraph",
        "NerdGraph API explorer",
        "Explore",
        "cURL",
        "New Relic CLI",
        "View your new dashboard",
        "Summary"
      ],
      "published_at": "2021-08-03T01:53:21Z",
      "title": "Add your custom visualization to a dashboard with NerdGraph",
      "updated_at": "2021-05-14T01:52:47Z",
      "type": "developer",
      "external_id": "c1743c0bb9cb85cc6802bc32616495fddb281e8b",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a dashboard with NerdGraph",
      "body": "Add your custom visualization to a new or existing dashboard, programmatically, with New Relic's GraphQL API, NerdGraph. Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the first four steps in the nr1 quick start to install and configure the CLI Create and publish your Nerdpack Create a Nerdpack with a visualization. You'll add this visualization to a dashboard using NerdGraph. Further reading Because this guide is about using visualizations, not creating and publishing them, it breezes over these topics. If you're unfamiliar with visualizations or would like a thorough explanation of dealing with visualization Nerdpacks, check out the following resources: Introduction to custom visualizations Build your first custom visualization If you already have a visualization you'd like to add to a dashboard, you can skip this section. But don't forget to make the necessary code adjustments to reference your visualization instead of the one this guide uses, called my-awesome-visualization. Step 1 of 4 Update your nr1 CLI: bash Copy $ nr1 update Now, you have the latest version. Step 2 of 4 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create -t visualization -n my-awesome-visualization ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" When you build a visualization with nr1 create, you get a default visualization. You'll use this default visualization throughout this course. Step 3 of 4 Navigate to your new Nerdpack: bash Copy $ cd my-awesome-nerdpack From here, you can run nr1 nerdpack commands. Step 4 of 4 Publish and subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Now, that your account is subscribed to your visualization, you can describe your app configurations with JSON and add it to a dashboard with NerdGraph. Describe your visualization options with JSON Whether you're adding your visualization to a new dashboard or an existing one, you need to send your configuration to NerdGraph. Your custom visualization JSON object represents a dashboard widget and consists of the following fields: Field Type Description title String Title for your dashboard widget visualization JSON The metadata for your visualization visualization.id String Your visualization's ID rawConfiguration JSON A full configuration of your widget Tip You can also add other types of widgets to dashboards with the steps in this guide, but the fields described here are specific to custom visualization widgets. For other widget types, you need to supply different data. Explore the API on your own with our NerdGraph explorer! Step 1 of 5 Start with a JSON template based on the fields you need to describe your custom visualization: { \"title\": \"\", \"visualization\": { \"id\": \"\" }, \"rawConfiguration\": {} } Copy Step 2 of 5 Give your visualization widget a title: { \"title\": \"My Awesome Visualization\", \"visualization\": { \"id\": \"\" }, \"rawConfiguration\": {} } Copy Step 3 of 5 Look up your Nerdpack ID from my-awesome-nerdpack/nr1.json: { \"schemaType\": \"NERDPACK\", \"id\": \"ab123c45-678d-9012-efg3-45hi6jkl7890\", \"displayName\": \"MyAwesomeNerdpack\", \"description\": \"Nerdpack my-awesome-nerdpack\" } my-awesome-nerdpack/nr1.json Copy Then, look up your visualization ID from my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json: { \"schemaType\": \"VISUALIZATION\", \"id\": \"my-awesome-visualization\", \"displayName\": \"MyAwesomeVisualization\", \"description\": \"\", \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"account-id\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] } my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json Copy Set your visualization widget's visualization.id to the form {NERDPACK-ID}.{VISUALIZATION-ID}: { \"title\": \"My Awesome Visualization\", \"visualization\": { \"id\": \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, \"rawConfiguration\": {} } Copy Step 4 of 5 In my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json, review your configuration options: { \"schemaType\": \"VISUALIZATION\", \"id\": \"my-awesome-visualization\", \"displayName\": \"MyAwesomeVisualization\", \"description\": \"\", \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"account-id\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] } my-awesome-nerdpack/visualizations/my-awesome-visualization/nr1.json Copy The name fields in configuration are important for describing your visualization widget. Step 5 of 5 Using the name field for every configuration object in your visualization's nr1.json file, build a rawConfiguration for your widget: { \"title\": \"My Awesome Visualization\", \"visualization\": { \"id\": \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, \"rawConfiguration\": { \"nrqlQueries\": [ { \"accountId\": 1234567, \"query\": \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], \"fill\": \"pink\", \"stroke\": \"green\" } } Copy Here, you've created a rawConfiguration by supplying values for each configuration option in nr1.json. Note that nrqlQueries is an array because its type is collection. The other values are strings. Learn more about these configuration options in Configure your custom visualization. Now that you've described your visualization widget in JSON, you can add your configured visualization to a dashboard. In the next section, you'll learn how to create a new dashboard with your visualization. If you already have one ready, skip ahead to add your visualization to your existing dashboard. Create a new dashboard with your visualization If you want to create a new dashboard for your visualization widget, use NerdGraph's dashboardCreate() mutation. The NerdGraph dashboardCreate() mutation takes the following fields: Field Type Description accountId Integer The ID for the account for which you want to create your dashboard dashboard JSON The details of the dashboard you're creating dashboard.name String The name of your dashboard dashboard.permissions Enum: PRIVATE, PUBLIC_READ_ONLY, PUBLIC_READ_WRITE The access control of your dashboard dashboard.pages Array: JSON The details of your dashboard's pages dashboard.pages[].name String The name of the dashboard page dashboard.pages[].widgets Array: JSON The widgets to add to the dashboard page Tip You can also pass more fields to dashboardCreate() to add details, widgets, and more. Explore the API on your own with our NerdGraph explorer! In this guide, you create a dashboard with a single page that contains a single widget—the visualization widget you described in the last section. Step 1 of 5 Build out a GraphQL mutation template based on the fields you need to describe your dashboard in dashboardCreate(): mutation { dashboardCreate( accountId: 0, dashboard: { name: \"\", pages: [ { name: \"\", widgets: [] }, ], permissions: PRIVATE } ) } Copy Here, you've defined the template for a private dashboard. Now, it's time to fill in the details. Step 2 of 5 Look up your account ID and enter it for your accountId: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"\", pages: [ { name: \"\", widgets: [] }, ], permissions: PRIVATE } ) } Copy Step 3 of 5 Select a name for your dashboard and its page: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"My Awesome Dashboard\", pages: [ { name: \"One Page to Rule Them All\", widgets: [] }, ], permissions: PRIVATE } ) } Copy Step 4 of 5 In widgets, place the widget object you created in the last section: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"My Awesome Dashboard\", pages: [ { name: \"One Page to Rule Them All\", widgets: [ { title: \"My Awesome Visualization\", visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } } ] }, ], permissions: PRIVATE } ) } Copy Step 5 of 5 Finally, add the return fields to your mutation: mutation { dashboardCreate( accountId: 1234567, dashboard: { name: \"My Awesome Dashboard\", pages: [ { name: \"One Page to Rule Them All\", widgets: [ { title: \"My Awesome Visualization\", visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } } ] }, ], permissions: PRIVATE } ) { entityResult { guid } } } Copy Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. Now, you have a mutation ready to send to NerdGraph to create single-page dashboard with a widget for your custom visualization. As a result, you'll see the new dashboard's entity GUID. In the next section, you'll learn how to add your visualization to an existing dashboard. If that's not relevant to your goals, skip ahead to send your request to NerdGraph. Add your visualization to an existing dashboard To add your visualization widget to an existing dashboard, use NerdGraph's dashboardAddWidgetsToPage() mutation. The NerdGraph dashboardAddWidgetsToPage() mutation takes the following fields: Field Type Description guid String The entity GUID for the dashboard to which you're adding your widgets widgets Array: JSON The widgets to add to the dashboard page Tip You can also pass more fields to dashboardAddWidgetsToPage() to add details, widgets, and more. Explore the API on your own with our NerdGraph explorer! Step 1 of 4 Build out a GraphQL mutation template based on the fields you need to describe your dashboard in dashboardAddWidgetsToPage(): mutation { dashboardAddWidgetsToPage( guid: \"\" widgets: [] ) { errors { description } } } Copy Step 2 of 4 Look up your dashboard's GUID and enter it for guid: mutation { dashboardAddWidgetsToPage( guid: \"AbCdEFghIJkLMNo1PQRSTUVWXYZAbCD2Ef34GHI\" widgets: [] ) { errors { description } } } Copy Step 3 of 4 In widgets, place the widget object you created in Describe your visualization options with JSON: mutation { dashboardAddWidgetsToPage( guid: \"AbCdEFghIJkLMNo1PQRSTUVWXYZAbCD2Ef34GHI\" widgets: [ { visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } }, ] ) } Copy Step 4 of 4 Finally, add the return fields to your mutation: mutation { dashboardAddWidgetsToPage( guid: \"AbCdEFghIJkLMNo1PQRSTUVWXYZAbCD2Ef34GHI\" widgets: [ { visualization: { id: \"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\" }, rawConfiguration: { nrqlQueries: [ { accountId: 1234567, query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" } ], fill: \"pink\", stroke: \"green\" } }, ] ) { errors { description } } } Copy Now, you have a mutation ready to send to NerdGraph to add your custom visualization to an existing dashboard. As a result, you'll see descriptions of any thrown errors to help you debug issues. The last thing you need to do is actually send your request to NerdGraph. Send your request to NerdGraph Send an HTTP request to NerdGraph with the payload you built in previous sections for the mutation that best suits your needs. There are many tools you can use to send an HTTP request, but in this guide, you learn how to communicate with NerdGraph using three specific tools: NerdGraph API explorer cURL New Relic CLI If you use another, you can adapt these methods for your favorite development tool. NerdGraph API explorer The NerdGraph API explorer is an implementation of GraphiQL that lets you explore the NerdGraph APIs. Step 1 of 4 Go to the NerdGraph API explorer. Step 2 of 4 Select or create a new API key: Step 3 of 4 In the center console, paste your mutation query: Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. Step 4 of 4 Press Execute Query and see the results in the right pane: If you successfully created a new dashboard, your response has an entity GUID. If you don't have an entity GUID, the response contains error messages to help you debug your query. If you added your visualization to an existing dashboard, you won't see errors in the response. If you do see error messages, use them to debug your query. Explore The NerdGraph API explorer lets you see other fields and change your query without typing everything manually. Use the left pane to explore NerdGraph. cURL cURL is a command line utility for making HTTP requests. Step 1 of 2 Select or create a New Relic user key. Copy this key, because you use it in the next step. Step 2 of 2 Make a request to NerdGraph, using cURL: bash Copy $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: <YOUR-USER-KEY>' \\ > --data-binary '{\"query\": \"mutation {dashboardCreate(dashboard: {name: \\\"My Awesome Dashboard\\\", pages: [{name: \\\"One Page to Rule Them All\\\", widgets: [{title: \\\"My Awesome Visualization\\\", visualization: {id: \\\"ab123c45-678d-9012-efg3-45hi6jkl7890.my-awesome-visualization\\\"}, rawConfiguration: {nrqlQueries: [{accountId: 3014918, query: \\\"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\\\"}], fill: \\\"pink\\\", stroke: \\\"green\\\"}}]}], permissions: PRIVATE}, accountId: <YOUR-ACCOUNT-ID>) { entityResult { guid }}}\", \"variables\": \"\"}' Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. Here, you send a request to NerdGraph that has two headers, Content-Type and API-Key, and a binary message body containing one of the mutation queries you built in previous sections. If you prefer to use a UI-based client, like Postman, you can adapt this method to a format that your client supports. New Relic CLI The newrelic is a command line interface for reading and writing New Relic data. Step 1 of 2 If you haven't already, install newrelic by following the first two steps of our Get started with the New Relic CLI guide. Once you've done that, you will have newrelic installed and configured for making NerdGraph requests. Step 2 of 2 Make a NerdGraph request using newrelic nerdgraph query: bash Copy $ newrelic nerdgraph query 'mutation { $ dashboardCreate( $ accountId: 1234567, $ dashboard: { $ name: \"My Awesome Dashboard\", $ pages: [ $ { $ name: \"One Page to Rule Them All\", $ widgets: [ $ { $ title: \"My Awesome Visualization\", $ visualization: { $ id: \"de0b4768-1504-4818-a898-da7cd14f0bfb.my-awesome-visualization\" $ }, $ rawConfiguration: { $ nrqlQueries: [ $ { $ accountId: <YOUR-ACCOUNT-ID>, $ query: \"FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago\" $ } $ ], $ fill: \"pink\", $ stroke: \"green\" $ } $ } $ ] $ }, $ ], $ permissions: PRIVATE $ } $ ) { $ entityResult { $ guid $ } $ } $ }' Important Make sure you replace the IDs in your mutation query with ones that match your account, Nerdpack, and visualization. View your new dashboard Now that you've built a dashboard with NerdGraph, it's time to check your work! Step 1 of 4 Go to New Relic. Step 2 of 4 Navigate to Dashboards: Step 3 of 4 Select your new dashboard: Step 4 of 4 View your dashboard: The dashboard you created has the name you passed in your mutation, \"My Awesome Dashboard\". It also has the configuration you sent in rawConfiguration, from the NRQL data query to the fill and stroke colors. Summary Congratulations! In this guide, you used NerdGraph, New Relic's GraphQL API, to add your custom visualization to a dashboard.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.0925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard with NerdGraph",
        "sections": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard with NerdGraph",
        "info": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard with NerdGraph",
        "body": "Add <em>your</em> <em>custom</em> <em>visualization</em> to a new or existing dashboard, programmatically, with New Relic&#x27;s GraphQL API, NerdGraph. Before you begin If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the first four steps in the nr1 quick start to install and <em>configure</em> the CLI"
      },
      "id": "609dd7f0e7b9d2ae61c3eb13"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.81686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>custom</em> <em>visualizations</em>",
        "sections": "Build <em>your</em> <em>custom</em> <em>visualization</em>",
        "info": "Introduction to <em>custom</em> <em>visualizations</em>",
        "tags": "<em>custom</em> <em>visualizations</em>",
        "body": " (Documentation) Customize visualizations with configuration (Guide) Configuring <em>custom</em> visualizations for dashboards (Video) Use <em>your</em> <em>custom</em> <em>visualization</em> During development, you can serve <em>your</em> <em>visualization</em> locally. Under Apps &gt; <em>Custom</em> Visualizations, you can view and <em>configure</em> <em>your</em> <em>visualization</em>"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.3213,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> <em>your</em> <em>visualization</em> with <em>configuration</em> options",
        "body": " 20 min Add a time picker to a sample application Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack Add <em>your</em> <em>custom</em> <em>visualization</em> to a dashboard 10 min Add <em>your</em> <em>custom</em> <em>visualization</em> to a New Relic dashboard Attach <em>your</em> Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Optimize your cloud spend",
        "1. Deploy the New Relic Infrastructure agent",
        "2. Create dashboard charts for cloud performance",
        "3. Configure the Amazon AWS integration",
        "4. Set up billing budgets in AWS",
        "5. Add cloud spend and budget widgets to Insights dashboard",
        "6. Create dashboards for every level of your organization",
        "Dashboards for developers",
        "Dashboards for DevOps",
        "Dashboards for executives",
        "7. Set up alerts",
        "Configure a baseline query using the forecasted amount"
      ],
      "title": "Optimize your cloud spend",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "7a0ac1127aee1ef0668e8aad47af8813f0ed7259",
      "image": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-your-cloud-spend/images/NRQL-Alert.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-your-cloud-spend/",
      "published_at": "2021-08-03T00:32:26Z",
      "updated_at": "2021-08-03T00:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Now that you are using cloud-hosted infrastructure and services, it is important to start looking very early and very closely at your cloud spend: Make sure that your assumptions about your cloud spend are playing out as expected. Quickly catch and correct any unexpected spikes in spending. Start fine-tuning the usage of your cloud-based resources. For example, if you have a set of 20 instances all running at 10% CPU, you can think about using smaller instances or consolidating more work onto those instances. This kind of thinking about your cloud spend helps you optimize and save money quickly. New Relic can help you monitor all this. From a data perspective, it is really just another metric that our platform can collect for you. As with any other metric, you can visualize, report, and alert on your cloud spend data, just like you can with any data New Relic can help you collect. New Relic can help you learn about your cloud spending or about any of your performance data. 1. Deploy the New Relic Infrastructure agent Review the requirements for the New Relic Infrastructure agent and follow the documentation for instructions on installing the agent. After you install the Infrastructure agent on your hosts, you immediately have access to the broad spectrum of metrics that the agent receives automatically. Then, you can set up the cloud integration to start collecting billing information. 2. Create dashboard charts for cloud performance New Relic Dashboards is the product that you use to write powerful custom queries about your data, and then visualize the results in charts that you collect on a dashboard. You can also feed the results of your dashboard queries directly into New Relic Alerts, where you can get notifications on any deviations that you specify. Include charts for various Infrastructure metrics related to performance and usage; for example: CPU Memory Disk Database You may also want to include charts that represent the application using this cloud infrastructure. In this way you can correlate the cloud infrastructure performance with that of the application. As you right-size your cloud infrastructure, you will want to monitor application performance to make sure you are achieving any targets. 3. Configure the Amazon AWS integration New Relic Infrastructure comes with several types of integrations, including Amazon Web Services (AWS), Microsoft Azure, and on-host integrations. This tutorial focuses on the AWS Billing integration. First, configure the integration with your AWS account, and then you can set up the AWS Billing integration. 4. Set up billing budgets in AWS The Amazon AWS Billing integration requires some additional configuration on the AWS side. Specifically, you need to go into your AWS Billing dashboard and set up Budgets. Our documentation provide walk-throughs of this process. When creating Budgets, be sure to: Fill in an application name. Decide whether you are doing cost or service-based budgeting. Decide if your budget is open-ended or has a definite ending date. 5. Add cloud spend and budget widgets to Insights dashboard New Relic Insights is the product that you use to write powerful custom queries about your data, and then visualize the results in widgets that you collect on a dashboard. You can also feed the results of your Insights queries directly into New Relic Alerts, where you can get notifications on any deviations that you specify. 6. Create dashboards for every level of your organization Whether you are a developer, in DevOps, or an executive, having information about your cloud spend can help you optimize your cloud environment. Here are a few ways dashboards can help at each level of your organization: Dashboards for developers Understanding how much applications cost to run helps developers properly configure applications to use more efficient services. For example, could developers save cloud costs using Amazon AWS Lambda or properly sized instances instead of randomly selecting an instance? Dashboards for DevOps Monitoring application costs allows operators to catch possible overruns due to misconfigured services. For example, is the DevOps team’s auto-scaling configuration not scaling down properly? Are they spending money on instances that are not being used? Dashboards for executives An overall view of both forecasted and actual cloud spends for individual applications on a per region basis, as well as total costs, helps executives make better business decisions. Use New Relic to keep control of your cloud spending costs, and get your teams alerted when you go over your budgets. 7. Set up alerts After you write queries on your data in Insights, you can easily use them to create alert conditions. New Relic gives you the ability to write baseline queries against your data. A baseline query is a query that you write without setting hard limits on the results and instead let New Relic Applied Intelligence “machine-learn” your performance data. New Relic alerts you when you go too far outside of your baseline numbers. Configure a baseline query using the forecasted amount Configuring a baseline query using a forecasted amount is a great starting point for monitoring any cloud budget, as you grow to understand what your cloud spend will be over time. New Relic notifies you if something spikes beyond your forecasted trend. That query looks like this: SELECT latest(`provider.forecastedAmount`) FROM FinanceSample WHERE provider = 'BillingBudget' and `provider.budgetName` = 'NAME_OF_YOUR_CLOUD_BUDGET' Copy When you create a baseline query and alert on it, you decide how restrictively Applied Intelligence should analyze your data using a simple slider and visualization based on your recent performance. The slider either increases or decreases the gray band around your budget threshold (the blue line): alerts.newrelic.com > Alert policies > (select a policy) > Alert conditions: Create alert conditions based on your NRQL queries and Insights data. This example would have resulted in zero violations based on recent data, and that is exactly what you are looking for. However, if that blue line spikes up out of the gray band, New Relic notifies you. For more detailed information about creating, managing, and using alerts, view these New Relic University tutorials: Intro to alerting Alert policies Alerting incident lifecycle Notification channels",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.87769,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Optimize <em>your</em> cloud spend",
        "sections": "3. <em>Configure</em> the Amazon AWS integration",
        "body": " that you use to write powerful <em>custom</em> queries about <em>your</em> data, and then visualize the results in charts that you collect on a dashboard. You can also feed the results of <em>your</em> dashboard queries directly into New Relic Alerts, where you can get notifications on any deviations that you specify. Include"
      },
      "id": "60445c4928ccbcd0132c6094"
    }
  ],
  "/build-apps/advanced-config": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 6304.833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Enable</em> <em>advanced</em> <em>configurations</em> <em>for</em> <em>your</em> <em>Nerdpack</em>",
        "body": " 20 min Add a time picker to a sample application <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>   <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em> Add <em>your</em> custom visualization to a dashboard 10 min Add <em>your</em> custom visualization to a New Relic dashboard Attach <em>your</em> Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 3447.159,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Advanced</em> <em>configurations</em>",
        "tags": "<em>Nerdpack</em> file structure",
        "body": " is up-to-date: bash Copy $ nr1 update For additional details about setting up <em>your</em> environment, see Set up <em>your</em> development environment and <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build <em>your</em> apps. Create"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Build your first custom visualization",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Serve your visualization locally",
        "Publish and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "title": "Build your first custom visualization",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "be115d80204c5e956b1f6bd8b0435b38fef31ac1",
      "image": "https://developer.newrelic.com/static/735776d76029c3d1c3f7a3965380a80e/ba3ac/opaque-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/build-visualization/",
      "published_at": "2021-08-03T01:43:03Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a custom data view and add it to a dashboard",
      "body": "Query data from any source and display it on your New Relic dashboard with custom visualizations. In this guide, you learn how to: Use the nr1 CLI to generate a default visualization Run your visualization locally where you can quickly test and iterate Publish your visualization to the New Relic One catalog Add your visualization to a dashboard Before you begin If you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create a new visualization Use nr1 to generate the boilerplate for a new visualization. Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called my-awesome-visualization, in a Nerdpack, called my-awesome-nerdpack: bash Copy $ nr1 create --type visualization --name my-awesome-visualization ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ... my-awesome-nerdpack ✔ nerdpack created successfully! nerdpack my-awesome-nerdpack is available at \"./my-awesome-nerdpack\" ✔ visualization created successfully! visualization my-awesome-visualization is available at \"./my-awesome-nerdpack/visualizations/my-awesome-visualization\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/my-awesome-visualization directory in my-awesome-nerdpack: bash Copy $ ls my-awesome-nerdpack/visualizations/my-awesome-visualization index.js nr1.json styles.scss The top-level visualizations directory holds all of your Nerdpack's visualizations. The visualization you created is called my-awesome-visualization, and it has its own directory. The files in this directory provide an example visualization—a RadarChart populated by a basic NRQL query. Files nr1.json provides metadata for your visualization. The configuration key in this metadata defines the prop-input fields to be shown in the UI. To learn more about the options available under the configuration key, check out the Configure your custom visualization article. index.js defines the React component that receives the props defined in nr1.json and renders your visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. styles.scss defines the Sass styles for your visualization Serve your visualization locally Serve your visualization locally, and view it in Apps > Custom Visualizations. There, you can quickly test changes to your code. Step 1 of 4 From the root directory of your Nerdpack, start a local Node server: bash Copy $ cd my-awesome-nerdpack $ nr1 nerdpack:serve While it's running, your local server recognizes changes to certain files, such as index.js and automatically refreshes your visualization. However, it doesn't recognize changes to nr1.json or styles.scss. Therefore, some changes, such as those to the definition of the configuration field in nr1.json, won't be reflected in your visualization until you restart your server. To see changes to those files, stop the server, with CTRL+C, and start it back up with nr1 nerdpack:serve. Step 2 of 4 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ my-awesome-visualization https://one.nr/012ab3cd4Ef Step 3 of 4 Update the fields under Configure visualization properties, and watch your visualization update automatically: To add more of these properties, update the configuration field in nr1.json, and restart your local server. Configuring these properties is one way to update your visualization. Changing your React code is another. Step 4 of 4 In index.js, change your component's Radar.fillOpacity: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 export default class MyAwesomeVisualizationVisualization extends React.Component { 13 // Custom props you wish to be configurable in the UI must also be defined in 14 // the nr1.json file for the visualization. See docs for more details. 15 static propTypes = { 16 /** 17 * A fill color to override the default fill color. This is an example of 18 * a custom chart configuration. 19 */ 20 fill: PropTypes.string, 21 22 /** 23 * A stroke color to override the default stroke color. This is an example of 24 * a custom chart configuration. 25 */ 26 stroke: PropTypes.string, 27 /** 28 * An array of objects consisting of a nrql `query` and `accountId`. 29 * This should be a standard prop for any NRQL based visualizations. 30 */ 31 nrqlQueries: PropTypes.arrayOf( 32 PropTypes.shape({ 33 accountId: PropTypes.number, 34 query: PropTypes.string, 35 }) 36 ), 37 }; 38 39 /** 40 * Restructure the data for a non-time-series, facet-based NRQL query into a 41 * form accepted by the Recharts library's RadarChart. 42 * (https://recharts.org/api/RadarChart). 43 */ 44 transformData = (rawData) => { 45 return rawData.map((entry) => ({ 46 name: entry.metadata.name, 47 // Only grabbing the first data value because this is not time-series data. 48 value: entry.data[0].y, 49 })); 50 }; 51 52 /** 53 * Format the given axis tick's numeric value into a string for display. 54 */ 55 formatTick = (value) => { 56 return value.toLocaleString(); 57 }; 58 59 render() { 60 const {nrqlQueries, stroke, fill} = this.props; 61 62 const nrqlQueryPropsAvailable = 63 nrqlQueries && 64 nrqlQueries[0] && 65 nrqlQueries[0].accountId && 66 nrqlQueries[0].query; 67 68 if (!nrqlQueryPropsAvailable) { 69 return <EmptyState />; 70 } 71 72 return ( 73 <AutoSizer> 74 {({width, height}) => ( 75 <NrqlQuery 76 query={nrqlQueries[0].query} 77 accountId={parseInt(nrqlQueries[0].accountId)} 78 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 79 > 80 {({data, loading, error}) => { 81 if (loading) { 82 return <Spinner />; 83 } 84 85 if (error) { 86 return <ErrorState />; 87 } 88 89 const transformedData = this.transformData(data); 90 91 return ( 92 <RadarChart 93 width={width} 94 height={height} 95 data={transformedData} 96 > 97 <PolarGrid /> 98 <PolarAngleAxis dataKey=\"name\" /> 99 <PolarRadiusAxis tickFormatter={this.formatTick} /> 100 <Radar 101 dataKey=\"value\" 102 stroke={stroke || '#51C9B7'} 103 fill={fill || '#51C9B7'} 104 fillOpacity={1.0} 105 /> 106 </RadarChart> 107 ); 108 }} 109 </NrqlQuery> 110 )} 111 </AutoSizer> 112 ); 113 } 114 } 115 116 const EmptyState = () => ( 117 <Card className=\"EmptyState\"> 118 <CardBody className=\"EmptyState-cardBody\"> 119 <HeadingText 120 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 121 type={HeadingText.TYPE.HEADING_3} 122 > 123 Please provide at least one NRQL query & account ID pair 124 </HeadingText> 125 <HeadingText 126 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 127 type={HeadingText.TYPE.HEADING_4} 128 > 129 An example NRQL query you can try is: 130 </HeadingText> 131 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 132 </CardBody> 133 </Card> 134 ); 135 136 const ErrorState = () => ( 137 <Card className=\"ErrorState\"> 138 <CardBody className=\"ErrorState-cardBody\"> 139 <HeadingText 140 className=\"ErrorState-headingText\" 141 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 142 type={HeadingText.TYPE.HEADING_3} 143 > 144 Oops! Something went wrong. 145 </HeadingText> 146 </CardBody> 147 </Card> 148 ); visualizations/my-awesome-visualization/index.js Copy Look at your visualization in the New Relic platform to see the change: Now you've seen how to: Serve your visualization locally View it in New Relic platform Update the visualization with configurable properties and code changes Once you've developed and configured a chart to show your data in an effective way, you can save that instance of the chart, complete with your configurations and the data or query, in a dashboard. However, you can't do this with a locally served visualization. You need to publish your visualization, first. Publish and use your visualization To add an instance of your visualization to a dashboard, you first need to publish your Nerdpack. Step 1 of 9 Publish your Nerdpack from its root directory: bash Copy $ nr1 nerdpack:publish Look for a success message in your output: bash Copy ✔ Nerdpack published successfully! ✔ Tagged 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 version 1.0.0 as STABLE. This means that your Nerdpack was published to the New Relic One catalog that you can find under Apps. Step 2 of 9 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe Subscribed account 3014918 to the nerdpack 5f4c2af8-3b27-40b5-954c-356d1ef88dd0 on the STABLE channel. Now, you're subscribed to your Nerdpack and can build an instance of a visualization in New Relic. Step 3 of 9 Once again, open the Apps page at New Relic: Here, you don't need to use the ?nerdpacks=local query string because you're looking for a visualization that you've published and subscribed to, rather than one that is locally served. Step 4 of 9 Go to Custom Visualizations: Step 5 of 9 Find and click your published visualization: You may have to refresh your browser page if you can't find your visualization. Notice that this new tile no longer has a </ > Local label. This is because you're looking at the visualization you published and subscribed to in the previous steps. If you're still serving your Nerdpack locally, you might see two tiles here, one with the label and one without it. Step 6 of 9 Configure your visualization the same way you did when it was locally served: Step 7 of 9 Click Add to dashboard: Follow the prompts to add your visualization to a dashboard. Step 8 of 9 From the homepage, go to Dashboards: Step 9 of 9 Select the dashboard you added your visualization to and see your visualization in it: Summary Congratulations on building your first visualization! In this guide, you learned how to: Create a visualization Serve your visualization locally Iterate on visualization code changes and customizations in Custom Visualizations Publish your visualization Subscribe to your visualization Add your visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1087.5999,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>your</em> first custom visualization",
        "sections": "Build <em>your</em> first custom visualization",
        "body": " <em>configurations</em> in <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>. As a result, you have a new visualizations&#x2F;my-awesome-visualization directory in my-awesome-<em>nerdpack</em>: bash Copy $ ls my-awesome-<em>nerdpack</em>&#x2F;visualizations&#x2F;my-awesome-visualization index.js nr1.json styles.scss The top-level"
      },
      "id": "6091fa3928ccbc3d26a268ec"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-08-03T01:40:59Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.45773,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize <em>your</em> visualization with SDK components",
        "sections": "Customize <em>your</em> visualization with SDK components",
        "info": "Customize <em>your</em> visualization",
        "body": " this and other <em>advanced</em> <em>configurations</em> in <em>Enable</em> <em>advanced</em> <em>configurations</em> for <em>your</em> <em>Nerdpack</em>. As a result, you have a new visualizations&#x2F;radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations&#x2F;radar-or-treemap index.js nr1.json styles.scss Set up <em>your</em> component"
      },
      "id": "6091fa3b196a679beed52a6b"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.69731,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to <em>your</em> <em>Nerdpack</em>",
        "sections": "Serve, publish, and subscribe to <em>your</em> <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether <em>your</em> <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to <em>your</em> <em>nerdpack</em> Update <em>your</em> <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    }
  ],
  "/build-apps/publish-deploy/serve": [
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.12978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Serve</em>, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "<em>Serve</em>, publish, and subscribe to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to <em>serve</em>, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to <em>serve</em>, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.9612,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user <em>Serve</em> Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.6417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " contains a default component to help you get started. <em>Serve</em> your visualization locally: bash Copy $ cd my-first-viz $ nr1 <em>nerdpack:serve</em> Open the link to your visualization that&#x27;s shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https:&#x2F;&#x2F;one.nr&#x2F;012ab3cd4Ef"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.55096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " arrow-keys. Return to submit. <em>nerdpack</em> ❯ nerdlet - create a&#x2F;an Nerdlet <em>Nerdpack</em> item inside your <em>Nerdpack</em>. launcher catalog visualization In the next lesson, you&#x27;ll learn how to <em>serve</em> your <em>Nerdpack</em> locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Serve</em> your New Relic One application."
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:53:28Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.144104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up your <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> commands",
        "body": " <em>Nerdpack</em>&#x2F;Nerdlet templates Locally <em>serve</em> Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application"
      },
      "id": "6091fa9864441feb412f36d4"
    }
  ],
  "/ab-test": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.96063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>a</em> Nerdpack",
        "sections": "Create <em>a</em> Nerdpack",
        "info": "Create <em>a</em> Nerdpack",
        "body": "&#x27;s displayName to &quot;A&#x2F;<em>B</em> <em>Test</em>&quot; and set the description to &quot;A&#x2F;<em>B</em> <em>test</em> your <em>application</em> using New Relic One&quot;: { &quot;schemaType&quot;: &quot;NERDPACK&quot;, &quot;id&quot;: &quot;311bcd0c-f7eb-4285-afed-4219179bf91d&quot;, &quot;displayName&quot;: &quot;A&#x2F;<em>B</em> <em>Test</em>&quot;, &quot;description&quot;: &quot;A&#x2F;<em>B</em> <em>test</em> your <em>application</em> using New Relic One.&quot; } nr1.json Copy It&#x27;s good to describe"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-08-02T10:03:05Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.2446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Build</em> <em>a</em> custom New Relic One <em>application</em> ",
        "sections": "<em>Build</em> <em>a</em> custom New Relic One <em>application</em>",
        "tags": "<em>Build</em> on New Relic One",
        "body": " to <em>build</em> New Relic One, you can <em>build</em> custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an <em>application</em> will take you only a few minutes. Check out these guides for help building"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:26Z",
      "title": "Add a section to end your test",
      "updated_at": "2021-05-05T01:54:58Z",
      "type": "developer",
      "external_id": "b6a72d3fa08cce5a0edcacd34e8fa438dcfeaede",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a section to end your test",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 Go to https://one.newrelic.com?nerdpacks=local, and view your application under Apps > Your apps: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.37643,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>a</em> section to end your <em>test</em>",
        "sections": "<em>Add</em> <em>a</em> section to end your <em>test</em>",
        "info": "<em>Add</em> <em>a</em> section to end your <em>test</em>",
        "body": ", before starting this one. In this course, you’re building an A&#x2F;<em>B</em> <em>test</em> <em>application</em> in New Relic. The <em>application</em> presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which"
      },
      "id": "6091faf228ccbcbf1fa268ea"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-08-03T01:49:51Z",
      "title": "Add pie charts",
      "updated_at": "2021-05-05T01:56:20Z",
      "type": "developer",
      "external_id": "cd10196320620683a525a97cc3770662466e5134",
      "document_type": "page",
      "popularity": 1,
      "info": "Add pie charts",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.65951,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> pie charts",
        "sections": "<em>Add</em> pie charts",
        "info": "<em>Add</em> pie charts",
        "body": " starting this one. You’ve begun building your A&#x2F;<em>B</em> <em>test</em> <em>application</em>. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll <em>build</em> in this lesson, review the design guide"
      },
      "id": "6091fb44e7b9d280165068d6"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/",
      "sections": [
        "Add chart components to your A/B test application",
        "Course"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Add chart components to your A/B test application",
      "updated_at": "2021-05-05T01:53:29Z",
      "type": "developer",
      "external_id": "02161afd9e7762a927a1e95b6119f5b5fa6f7b9a",
      "document_type": "page",
      "popularity": 1,
      "info": "Add chart components to your A/B test application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Serve your New Relic One application, before starting this one. The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add your first chart.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.34495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> chart components to your <em>A</em>&#x2F;<em>B</em> <em>test</em> <em>application</em>",
        "sections": "<em>Add</em> chart components to your <em>A</em>&#x2F;<em>B</em> <em>test</em> <em>application</em>",
        "info": "<em>Add</em> chart components to your <em>A</em>&#x2F;<em>B</em> <em>test</em> <em>application</em>",
        "body": " <em>application</em>, before starting this one. The New Relic One <em>application</em> that you&#x27;re building throughout this course allows developers to A&#x2F;<em>B</em> <em>test</em> their websites. To run a successful A&#x2F;<em>B</em> <em>test</em>, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers"
      },
      "id": "6091fa99e7b9d20804506901"
    }
  ],
  "/explore-docs/custom-viz/build-visualization": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 573.14087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic <em>One</em> <em>CLI</em> (<em>nr1</em>). If you haven&#x27;t already: Sign up for a New Relic account Install Node.js Complete the <em>CLI</em> quick start Finally, make sure your <em>nr1</em>"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Add your custom visualization to a dashboard",
        "Course",
        "Tip",
        "Important",
        "Delete your visualization",
        "Summary"
      ],
      "title": "Add your custom visualization to a dashboard",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9b921ffb6df768ca5f63cb65ca55a644ab283997",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/",
      "published_at": "2021-08-03T01:41:57Z",
      "updated_at": "2021-05-05T01:49:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add your custom visualization to a New Relic dashboard",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize visualizations with configuration, before starting this one. In the previous lesson, you added a configuration option to your visualization that allows you to choose how you want to represent your data. This was different from the previous version of your code because, while you can still choose your chart type, you can now only do it before you create an instance of your visualization. But what does it mean to create an instance of your visualization? How do you use a visualization once you've configured it? In this lesson, you'll learn how to create an instance of your visualization and add that instance to dashboard. Tip If you got lost in the previous steps and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step 1 of 7 From the root directory of your Nerdpack, publish and subscribe to your visualization: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe Important To publish a Nerdpack you must be a Full user with the Nerdpacks “modify” privilege (this is granted by default). Read our Nerdpacks privileges documentation to learn more. Next, find your published visualization in the New Relic One app catalog. Step 2 of 7 From the New Relic homepage, select the Apps button in the top right navigation bar: Step 3 of 7 From the Apps page, click the Custom Visualizations launcher: Step 4 of 7 Select RadarOrTreemap: Step 5 of 7 In the previous lesson, you changed your visualization to use the platform configurations panel for selecting a chart type. Use this panel to configure your chart: Step 6 of 7 Click Add to dashboard. Then, select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select an account and a name: Click Add to dashboard. Step 7 of 7 Go to your dashboard to see your custom visualization: Note that you can create another version of the visualization with the other chart type and add it to the same dashboard. That's why we call these instances of your visualization. Delete your visualization Once you've added your visualization to a dashboard, you can't edit it. You can't change the underyling query, account ID, chart type, or any other previously configurable option. So, if you're not happy with your visualization, delete it from your dashboard and walk through the steps in this guide again to add a new instance. Step 1 of 2 Click the ellipses button in the right-hand corner of the visualization, and click Delete: Step 2 of 2 Confirm that you want to delete your visualization: Summary Now you know how to: Create new custom visualizations with the New Relic One SDK Configure your visualizations using the SDK and configuration options Add your visualizations to a dashboards To learn more about custom visualizations, check out the following resources: New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library Or, to learn more about other cool things you can build with the New Relic One SDK, check out our apps course! Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 378.36966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add your custom <em>visualization</em> to a dashboard",
        "sections": "Add your custom <em>visualization</em> to a dashboard",
        "info": "Add your custom <em>visualization</em> to a New Relic dashboard",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " and would like to see what your files should look like to start this lesson, check out the course project on Github. Add your custom visualization to a dashboard Step <em>1</em> of 7 From the root directory of your Nerdpack, publish and <em>subscribe</em> to your visualization: bash Copy $ <em>nr1</em> nerdpack:publish $ <em>nr1</em>"
      },
      "id": "6091f9c864441f61d62f370a"
    },
    {
      "image": "https://developer.newrelic.com/static/f3ea1bf0bea3a13e7773cb1e1da690c6/0086b/your-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-08-03T01:48:25Z",
      "title": "Subscribe to your New Relic One application",
      "updated_at": "2021-05-05T01:56:19Z",
      "type": "developer",
      "external_id": "3741cc4f9fcbf1e63c151f2f0f7244648e26dd81",
      "document_type": "page",
      "popularity": 1,
      "info": "Subscribe to your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.35226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "info": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " serving it locally! Tip If you don&#x27;t see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application"
      },
      "id": "6091fb4464441f42962f3737"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/advanced-config/",
      "sections": [
        "Enable advanced configurations for your Nerdpack",
        "Before you begin",
        "Extend your webpack configuration",
        "Add extra certificates"
      ],
      "published_at": "2021-08-03T01:40:49Z",
      "title": "Enable advanced configurations for your Nerdpack",
      "updated_at": "2021-05-21T01:42:22Z",
      "type": "developer",
      "external_id": "0579a1163b031fda6f8fc80d4dc5ef885bba45ff",
      "document_type": "page",
      "popularity": 1,
      "info": "Enable advanced configurations for your Nerdpack",
      "body": "Most of the time, the nr1 CLI commands will just work, requiring no extra configuration. You'll be able to create Nerdpacks, Nerdlets, launchers, and visualizations without a hitch. But sometimes, you need something special for your setup. In this guide, you'll learn how you can enable advanced configurations for your Nerdpack. Before you begin Make sure you have the latest version of the nr1 CLI: bash Copy $ nr1 update Extend your webpack configuration You can use our .extended-webpackrc.js file to extend your webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Add extra certificates When working with nr1 behind a corporate proxy, you may see a RequestError: bash Copy $ nr1 create --type nerdpack --name new-nerdpack RequestError: Error: self signed certificate in certificate chain Node uses its own certificate chain. So, if you're getting this error, you need to add your corporate certificate to Node's \"root\" CAs: bash Copy $ export NODE_EXTRA_CA_CERTS=[cert]",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.57877,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Most of the time, the <em>nr1</em> <em>CLI</em> commands will just work, requiring no extra configuration. You&#x27;ll be able to create Nerdpacks, Nerdlets, launchers, and <em>visualizations</em> without a hitch. But sometimes, you need something special for your setup. In this guide, you&#x27;ll learn how you can enable advanced"
      },
      "id": "6091f9c828ccbcf8fea268f1"
    },
    {
      "sections": [
        "Subscribe to a Nerdpack",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Tip",
        "Subscribe from the command line",
        "Technical detail",
        "Unsubscribe from a Nerdpack",
        "Unsubscribe using the command line",
        "Resolve issues with accessing your published Nerdpack",
        "Tag your Nerdpack version",
        "Subscribe with the web UI"
      ],
      "title": "Subscribe to a Nerdpack",
      "type": "developer",
      "tags": [
        "nerdpack",
        "subscribe"
      ],
      "external_id": "1e44b2ed6ab9788b17cd19ca10ae4b4cfd4c2fe1",
      "image": "https://developer.newrelic.com/static/157cec05491eea35b82fe9066d24f004/0086b/subscribe-to-account-maturity-app.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/subscribe/",
      "published_at": "2021-08-03T01:47:20Z",
      "updated_at": "2021-05-21T01:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to subscribe to a Nerdpack",
      "body": "Subscribe to a Nerdpack to use it in the New Relic platform. Unsubscribe from Nerdpacks you no longer use. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To subscribe to a Nerdpack, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can subscribe to them: Publish your Nerdpack Tag your Nerdpack if it's published and doesn't yet have a tag Subscribe to a Nerdpack Subscribe to a published Nerdpack, with either the web UI or the nr1 CLI, to use it in your account. Subscribing allows you to select the tagged version you want to use as well as the account you want to subscribe with. This lets you control what Nerdpacks you use in your account. Tip When the tag you've subscribed to gets an update, New Relic updates your Nerdpack automatically. Step 1 of 7 Go to New Relic: Step 2 of 7 Navigate to Apps: Step 3 of 7 Find your published Nerdpack under New Relic One catalog: All published Nerdpacks are shown in the New Relic One catalog. However, the one you're looking for maybe filtered out. Adjust the filter to find the Nerdpack you're looking for: Step 4 of 7 Select the Nerdpack you want to add to your New Relic account: Step 5 of 7 Click Add this app: This button says Manage access if you're already subscribed to the Nerdpack. Step 6 of 7 Select the account to subscribe with and the tagged version to subscribe to. Then, update your account(s): Tip In the web UI, and some places in the CLI, we refer to tags as channels. This is a relic of a past implementation of Nerdpack versioning. Ignoring historical and implementation details, consider them to be synonyms. Now you, and members of the accounts you've subscribed with, can launch the Nerdpack from New Relic. Step 7 of 7 If you subscribed to an app, find it under Your apps: If you subscribed to a visualization, find it under Custom visualizations: Subscribe from the command line If you've published your own Nerdpack, it may be quicker to subscribe to your Nerdpack with the nr1 CLI. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack For simplicity, this guide refers to your Nerdpack as my-awesome-nerdpack. Step 2 of 3 Ensure that your Nerdpack was published and tagged: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------------- ------ 1.0.0 a few seconds ago STABLE You should see at least one published version with a tag. It doesn't have to be STABLE. You can subscribe to any tagged version. Step 3 of 3 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe --channel=STABLE Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the STABLE channel Here, you've subscribed to the STABLE tag. You can also subscribe to DEV and BETA tags from the CLI, but the subscription command doesn't allow for arbitrary tags. To subscribe to any other tagged version, you need to use the web UI. Similar to the web UI, the term channel nr1 nerdpack:subscribe is a reference to an older implementation of Nerdpack versions. Technical detail nr1 nerdpack:subscribe is an alias for nr1 subscription:set. Read the nr1 subscription:set documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:set --help Unsubscribe from a Nerdpack Unsubscribe from a Nerdpack to remove it from your account. Step 1 of 5 Go to New Relic: Step 2 of 5 Navigate to Apps: Step 3 of 5 Click the \"i\" icon next to the Nerdpack you're subscribed to: This opens the detail page. Step 4 of 5 Click Manage access: Step 5 of 5 Deselect the accounts you want to unsubscribe with. Then, update those accounts: Unsubscribe using the command line Quickly unsubscribe your CLI profile from Nerdpacks. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack Step 2 of 3 View your profile's subscriptions: bash Copy $ nr1 subscription:list Listing subscribed deployed nerdpacks on your account: Version UUID Name Date User ------- ------------------------------------ ---------------- ----------- ------- 0.6.4 384de6e5-8e57-4d56-9d13-299ee7ae8641 Account Maturity a month ago 2774472 Step 3 of 3 Unsubscribe from the Nerdpack with the UUID: bash Copy $ nr1 nerdpack:unsubscribe --nerdpack-id=384de6e5-8e57-4d56-9d13-299ee7ae8641 Unsubscribed account 1234567 from the nerdpack 384de6e5-8e57-4d56-9d13-299ee7ae8641 on the STABLE channel. Tip nr1 nerdpack:unsubscribe is an alias for nr1 subscription:unset. Read the nr1 subscription:unset documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:unset --help Resolve issues with accessing your published Nerdpack Sometimes, when you subscribe to a Nerdpack, you may run into issues. Whether you can't subscribe or see duplicate subscriptions in your account, consider some common solutions for resolving these issues. Tag your Nerdpack version When you subscribe to an Nerdpack, you choose a specific tag. So, if the Nerdpack you're trying to subscribe to isn't tagged, or doesn't have the tag you're targeting, tag your release version: bash Copy $ nr1 nerdpack:subscribe --channel=DEV › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel DEV. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED $ nr1 nerdpack:tag --tag=DEV ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as DEV. $ nr1 nerdpack:subscribe --channel=DEV Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the DEV channel. If you subscribe without a --channel argument, the default channel is STABLE, so make sure you have a STABLE version in this case: bash Copy $ nr1 nerdpack:subscribe › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel STABLE. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED Subscribe with the web UI When you subscribe with the CLI, you pass a --channel argument to select a tag. A channel is, for all intents and purposes, a tag. This term is a relic of a past implementation of Nerdpack versioning. However, while the terms are synonymous, using --channel is limited in the CLI. When you subscribe with a --channel, you can only choose between DEV, BETA, and STABLE. So, to subscribe to a different tag, use the web UI: bash Copy $ nr1 nerdpack:subscribe --channel=QA › Error: Expected --channel=QA to be one of: DEV, BETA, STABLE › See more help with --help › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.81601,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Subscribe</em> to a Nerdpack",
        "sections": "<em>Subscribe</em> to a Nerdpack",
        "info": "Learn to <em>subscribe</em> to a Nerdpack",
        "tags": "<em>subscribe</em>",
        "body": " of a past implementation of Nerdpack versioning. However, while the terms are synonymous, using --channel is limited in the <em>CLI</em>. When you <em>subscribe</em> with a --channel, you can only choose between DEV, BETA, and STABLE. So, to <em>subscribe</em> to a different tag, use the web UI: bash Copy $ <em>nr1</em> nerdpack:<em>subscribe</em> --channel=QA › Error: Expected --channel=QA to be <em>one</em> of: DEV, BETA, STABLE › See more help with --help › Code: UNKNOWN"
      },
      "id": "609c8686196a67beaed52a2c"
    }
  ],
  "/explore-docs/custom-viz/add-to-dashboard-nerdgraph": [
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-08-03T01:41:02Z",
      "updated_at": "2021-08-02T22:59:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Add muting rules to suppress notifications Manage notification channels Customize loss of signal and gap filling The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 611.5468,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro <em>to</em> using <em>Alerts</em> via <em>NerdGraph</em> <em>API</em>",
        "sections": "Intro <em>to</em> using <em>Alerts</em> via <em>NerdGraph</em> <em>API</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Nerdgraph</em>",
        "body": "You can manage <em>your</em> policies, conditions, and muting rules programmatically using our <em>Graph</em>QL <em>NerdGraph</em> API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with <em>NerdGraph</em> Here&#x27;s what you can do in <em>NerdGraph</em>: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "NerdGraph tutorial: Understand entity relationships and dependencies",
        "Relationship types",
        "Read relationships of an entity"
      ],
      "title": "NerdGraph tutorial: Understand entity relationships and dependencies",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "3699777ea1a7bf17213ccdaad3b44793e1561948",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-relationships-api-tutorial/",
      "published_at": "2021-08-03T06:45:39Z",
      "updated_at": "2021-08-03T06:45:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to understand how your monitored entities relate to each other is using our NerdGraph API. You can use the relatedEntities field to see how pairs of entities interact and how they're related. This can help troubleshoot upstream and downstream services and understand how minor issues may have larger repercussions, similar to how service maps can be used. Relationship types Relationship types provide additional information about how two entities are related. The supported relationship types are: Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source in addition to the one you are currently viewing. Read relationships of an entity You can use NerdGraph to return the relationships between your monitored entities. The following example shows how to query an entity by its specific GUID, using the NerdGraph GraphiQL explorer. For more information, see Use NerdGraph to query entities. query{ actor{ entity(guid: YOUR_ENTITY_GUID){ name relatedEntities { results { source { entity { guid name } } target { entity { guid name } } type } } } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 508.06918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Understand entity relationships <em>and</em> dependencies",
        "sections": "<em>NerdGraph</em> tutorial: Understand entity relationships <em>and</em> dependencies",
        "tags": "<em>NerdGraph</em>",
        "body": "One way to understand how <em>your</em> monitored entities relate to each other is using our <em>NerdGraph</em> API. You can use the relatedEntities field to see how pairs of entities interact and how they&#x27;re related. This can help troubleshoot upstream and downstream services and understand how minor issues may"
      },
      "id": "603ec1c664441fb7ff4e8852"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-08-02T03:52:39Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 487.33292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Insights <em>Dashboard</em> <em>API</em>",
        "sections": "Insights <em>Dashboard</em> <em>API</em>",
        "tags": "Insights <em>API</em>",
        "body": " and DELETE endpoints are not available. To make the transition from the Insights <em>Dashboard</em> API to the New Relic One Dashboards API, see our migration guide. For more information, see the <em>NerdGraph</em> dashboards tutorial and Explorers Hub post. Requirements If <em>your</em> account hosts data in the EU data center"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-08-03T06:47:30Z",
      "updated_at": "2021-07-27T11:27:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 484.03076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "sections": "Introduction <em>to</em> New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "tags": "<em>NerdGraph</em>",
        "body": " <em>Add</em> and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights <em>Dashboard</em> API to <em>NerdGraph</em> Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 475.9428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Add</em> <em>your</em> <em>custom</em> <em>visualization</em> <em>to</em> <em>a</em> <em>dashboard</em>",
        "body": " 20 min <em>Add</em> a time picker to a sample application Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack <em>Add</em> <em>your</em> <em>custom</em> <em>visualization</em> to a <em>dashboard</em> 10 min <em>Add</em> <em>your</em> <em>custom</em> <em>visualization</em> to a New Relic <em>dashboard</em> Attach <em>your</em> Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    }
  ],
  "/build-apps/publish-deploy/tag": [
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.87558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "<em>Tag</em> your <em>Nerdpack&#x27;s</em> release version",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, <em>tag</em>, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.57495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes <em>Tag</em> Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "sections": [
        "Publish your Nerdpack",
        "Update your CLI",
        "Check your permissions",
        "Update your package version",
        "Tip",
        "Generate a UUID for your Nerdpack",
        "Resolve issues with accessing your published Nerdpack",
        "Debug your command",
        "Reveal your published Nerdpack information",
        "Check your local profile"
      ],
      "title": "Publish your Nerdpack",
      "type": "developer",
      "tags": [
        "nerdpack",
        "publish"
      ],
      "external_id": "704a9f40ffddfa111e7b295ddafcc99336e4eb1d",
      "image": "https://developer.newrelic.com/static/4560bce9c6a1165799e6eaf9d10f4868/0086b/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/publish/",
      "published_at": "2021-08-03T01:47:21Z",
      "updated_at": "2021-05-21T01:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to publish your Nerdpack to the New Relic One catalog",
      "body": "Publish your Nerdpack, whether it's still in development, ready for testing, or stable, to share it with others. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions When you publish your Nerdpack, it's registered with the New Relic One catalog. From there, some users can subscribe to your Nerdpack. Subscribing users need to have: Access to the account that published the Nerdpack The necessary permissions for managing Nerdpacks Update your package version You can only publish a package version to the catalog one time. For example, you can't publish two instances of version 1.0.0. So, each time you want to deploy a new version of your code, you need to increment its version in the Nerdpack's package.json file: { \"private\": true, \"name\": \"demo-app\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"ab123c45-678d-9012-efg3-45hi6jkl7890\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } package.json Copy Tip Nerdpack versions follow semantic versioning. Read the documentation to learn more. Generate a UUID for your Nerdpack If you built your Nerdpack from scratch with nr1 create --type nerdpack, then your Nerdpack has a unique identifier. Find this identifier in the root directory's nr1.json file: { \"schemaType\": \"NERDPACK\", \"id\": \"ab123c45-678d-9012-efg3-45hi6jkl7890\", \"displayName\": \"DemoApp\", \"description\": \"Nerdpack demo-app\" } nr1.json Copy This ID must be unique to your Nerdpack when you publish it to the catalog. The platform will reject your Nerdpack if it recognizes the ID. So, if you cloned an existing Nerdpack or are otherwise using open source code, generate a new UUID: bash Copy $ nr1 nerdpack:uuid --generate --force Tip Read the nr1 nerdpack:uuid documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 nerdpack:uuid --help Publish your Nerdpack Step 1 of 4 In the root folder of your Nerdpack, run nr1 nerdpack:publish: bash Copy $ nr1 nerdpack:publish If you've successfully published your Nerdpack, you should see some success output, including: bash Copy ✔ Nerdpack published successfully! ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as STABLE. This output describes the published Nerdpack. First, it states the Nerdpack's ID (ab123c45-678d-9012-efg3-45hi6jkl7890). Then, its version (1.0.0). Finally, its version tag (STABLE). You already managed your Nerdpack's ID and version, but the version tag is new. To manage your Nerdpack's versions, you can tag them with an arbitrary tag. For example, if a version is still in development, you can tag it with a DEV tag. If the version moves to a QA phase, you can tag it with QA. If it's ready for production, you can tag it with STABLE. Tip Read our tag guide to learn more. Use the -t or --tag option to publish your Nerdpack with a tag: bash Copy $ nr1 nerdpack:publish --tag DEV As you saw in the nr1 nerdpack:publish output, if you don't pass a tag, nr1 applies the STABLE tag automatically. However, you can tell it to not apply any tags to a release with the -T or --skip-tag option: bash Copy $ nr1 nerdpack:publish --skip-tag You can also perform a dry run to make sure you publish your Nerdpack the way you want to: bash Copy $ nr1 nerdpack:publish --dry-run Step 2 of 4 Once you've successfully published your Nerdpack, go to New Relic: Because you're going to view a published Nerdpack, rather than a locally served one, you don't need to pass the ?nerdpacks=local query string. Step 3 of 4 Navigate to Apps: Whether you published a New Relic One application or a custom visualization, you'll find your project under Apps. Step 4 of 4 Find your published Nerdpack under New Relic One catalog: Notice the Custom indicator on its UI tile. Use this to distinguish between published Nerdpacks and locally-served Nerdpacks. Tip Only Nerdpacks with tagged versions are shown under New Relic One catalog. So, if you published without a tag or removed a tag from your published Nerdpack, you won't see it in the catalog. Resolve issues with accessing your published Nerdpack Sometimes, when you publish your Nerdpack, you may come across issues. Whether you can't publish your Nerdpack due to some issue with your code or you can't find your Nerdpack in the catalog, consider some common solutions for resolving these issues. Debug your command When you attempt to publish your Nerdpack, carefully read the output of your nr1 command. You may receive success output, including: bash Copy ✔ Nerdpack published successfully! ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as STABLE. However, the output may show some errors in your Nerdpack instead. For example: bash Copy Publishing Nerdpack DemoApp (ab123c45-678d-9012-efg3-45hi6jkl7890) › Error: There is already a Nerdpack with given id & version. › Code: 409 It may also help you to view more verbose output. Use the --verbose command to show more content: bash Copy $ nr1 nerdpack:publish --verbose Reveal your published Nerdpack information If you don't find your Nerdpack in New Relic, it may not be tagged. Remember, at least one version of your published Nerdpack must have a tag for it to show on the Apps page. See more information about your published Nerdpack with nr1 nerdpack:info: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 3014918 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------- ---- 1.0.0 3 hours ago In this example, there is one published version, but it isn't tagged. You can tag a published version with: bash Copy $ nr1 nerdpack:tag --from-version=1.0.0 --tag=DEV Now, if you refresh your browser page, you should see your Nerdpack on Apps. Tip Read our nr1 nerdpack:tag documentation to learn more. Check your local profile With nr1, you can set a default New Relic profile. This profile is used for all commands unless otherwise specified with the command's --profile option. When you publish your Nerdpack, only users who can access your account can see your published Nerdpack. So, if you don't find your Nerdpack in New Relic but you know it's published, compare your local profile with the profile you're using in the browser to make sure they're the same.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.05159,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Publish your <em>Nerdpack</em>",
        "sections": "Publish your <em>Nerdpack</em>",
        "info": "Learn to publish your <em>Nerdpack</em> to the New Relic One catalog",
        "tags": "<em>nerdpack</em>",
        "body": " the published <em>Nerdpack</em>. First, it states the <em>Nerdpack</em>&#x27;s ID (ab123c45-678d-9012-efg3-45hi6jkl7890). Then, its version (1.0.0). Finally, its version <em>tag</em> (STABLE). You already managed your <em>Nerdpack</em>&#x27;s ID and version, but the version <em>tag</em> is new. To manage your <em>Nerdpack</em>&#x27;s versions, you can <em>tag</em> them"
      },
      "id": "609c8686e7b9d262825068b9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-nerdpack/",
      "sections": [
        "New Relic One CLI Nerdpack commands",
        "Command details",
        "nr1 nerdpack:build",
        "Usage",
        "Options",
        "Description",
        "nr1 nerdpack:clean",
        "nr1 nerdpack:clone",
        "nr1 nerdpack:info",
        "nr1 nerdpack:publish",
        "nr1 nerdpack:serve",
        "nr1 nerdpack:tag",
        "Aliases",
        "nr1 nerdpack:untag",
        "nr1 nerdpack:uuid",
        "nr1 nerdpack:validate"
      ],
      "published_at": "2021-08-03T01:47:21Z",
      "title": "New Relic One CLI Nerdpack commands",
      "updated_at": "2021-05-05T01:53:29Z",
      "type": "developer",
      "external_id": "7c1050a6a8624664b90c15111f7c72e96b2fbe17",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to set up your New Relic One Nerdpacks.",
      "body": "To set up your Nerdpacks, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 nerdpack:build Builds a Nerdpack nr1 nerdpack:clean Removes all built artifacts nr1 nerdpack:clone Clones a Nerdpack from a git repository nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry nr1 nerdpack:publish Publish this Nerdpack nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes nr1 nerdpack:tag Tags a specific Nerdpack version nr1 nerdpack:untag Removes a tag from the registry nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack nr1 nerdpack:validate Validates artifacts inside your Nerdpack Command details nr1 nerdpack:build Builds a nerdpack Usage bash Copy $ nr1 nerdpack:build Options --extra-metadata-path=extra-metadata-path [default: extra-metadata.json] specify a json file path with extra metadata --prerelease=prerelease if specified, the value will be appended to the current version of generated files. ie: --prerelease=abc. Then the version will be \"1.2.3-abc\". --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description Runs a webpack process to assemble your Nerdpack into javascript and css bundles. As many other CLI commands, it should be run at the package.json level of your Nerdpack. It will search for nr1.json files in your subdirectories, validate them, and try to build them. This also runs nr1 nerdpack:validate before starting the build process. nr1 nerdpack:clean Removes all built artifacts Usage bash Copy $ nr1 nerdpack:clean Options --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description Cleans and removes the content and the development folders (dist/, tmp/) nr1 nerdpack:clone Clones a nerdpack from a git repository Usage bash Copy $ nr1 nerdpack:clone Options -f, --force Replace destination folder if it exists -p, --path=path Directory where to clone (defaults to the repository name) -r, --repo=repo (required) Repository location (either an HTTPS or SSH path) --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description Given a git repository, it performs all the actions so that you can start using it. This includes, in order: Clone the repository Set the repository as remote upstream Install all of its dependencies (using npm) Generate a new UUID using your profile, and commit it nr1 nerdpack:info Shows the state of your nerdpack in the new relic's registry Usage bash Copy $ nr1 nerdpack:info Options -a, --all show all versions -i, --nerdpack-id=nerdpack-id get info from the specified Nerdpack instead of local one --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description The default amount of versions shown is 10 but all versions can be shown if the --all (or -a) flag is used nr1 nerdpack:publish Publish this nerdpack Usage bash Copy $ nr1 nerdpack:publish Options -B, --skip-build skip the previous build process -T, --skip-tag do not tag the version -t, --tag=tag [default: STABLE] --dry-run publish process without actually publishing anything. --extra-metadata-path=extra-metadata-path [default: extra-metadata.json] specify a json file path with extra metadata --prerelease=prerelease if specified, the value will be appended to the current version of generated files. ie: --prerelease=abc. Then the version will be \"1.2.3-abc\". --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description This command will build and upload your Nerdpack to the registry. If no additional parameters are passed in, this command will automatically tag the nerdpack version as STABLE. If you want to disable this behavior, pass the --skip-tag flag to the command. See nr1 nerdpack:tag --help for more info on tags. nr1 nerdpack:serve Serves your nerdpack for testing and development purposes Usage bash Copy $ nr1 nerdpack:serve Options --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description Launches a server with your local code, ready to be tested live on the platform. nr1 nerdpack:tag Tags a specific nerdpack version Usage bash Copy $ nr1 nerdpack:tag Options -V, --from-version=from-version version to tag. If it's not provided will use the one in package.json -i, --nerdpack-id=nerdpack-id nerdpack uuid to deploy. If it's not provided will use the one in nr1.json -t, --tag=tag [default: STABLE] tag name --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description A single version may have several tags, but each tag can only be applied to one version. Tagging a different version with an existing tag will untag the previous one. We recommend using STABLE to tag the versions you want to show to your subscribers. See the command nr1 nerdpack:subscribe for more info. Aliases bash Copy $ $ nr1 nerdpack:deploy nr1 nerdpack:untag Removes a tag from the registry Usage bash Copy $ nr1 nerdpack:untag Options -i, --nerdpack-id=nerdpack-id nerdpack uuid to deploy. If it's not provided will use the one in nr1.json -t, --tag=tag [default: STABLE] tag name --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description Specified tag will be removed. No files will be actually deleted. Aliases bash Copy $ $ nr1 nerdpack:undeploy nr1 nerdpack:uuid Shows or regenerates the uuid of a nerdpack Usage bash Copy $ nr1 nerdpack:uuid Options -f, --force if present, it will override the existing UUID without asking -g, --generate generates a new UUID if not available --profile=profile the authentication profile you want to use --verbose adds extra information to the output Description By default, prints the Universal Unique ID of the specified package. It also enables generation (or regeneration) of the UUID of your package, depending on the flags passed. nr1 nerdpack:validate Validates artifacts inside your nerdpack Usage bash Copy $ nr1 nerdpack:validate Options -l, --force-local do not download new schema files -r, --force-remote force download of new schema files --profile=profile the authentication profile you want to use --verbose adds extra information to the output Aliases bash Copy $ nr1 nerdpack:ls bash Copy $ nr1 nerdpack:val",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.21241,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic One CLI <em>Nerdpack</em> commands",
        "sections": "New Relic One CLI <em>Nerdpack</em> commands",
        "info": "An overview of the CLI commands you can use to set up your New Relic One <em>Nerdpacks</em>.",
        "body": " repository nr1 <em>nerdpack</em>:info Shows the state of your <em>Nerdpack</em> in the New Relic&#x27;s registry nr1 <em>nerdpack</em>:publish Publish this <em>Nerdpack</em> nr1 <em>nerdpack</em>:serve Serves your <em>Nerdpack</em> for testing and development purposes nr1 <em>nerdpack:tag</em> Tags a specific <em>Nerdpack</em> version nr1 <em>nerdpack</em>:untag Removes a <em>tag</em> from"
      },
      "id": "6091fa9928ccbc7c92a268e4"
    },
    {
      "sections": [
        "Subscribe to a Nerdpack",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Tip",
        "Subscribe from the command line",
        "Technical detail",
        "Unsubscribe from a Nerdpack",
        "Unsubscribe using the command line",
        "Resolve issues with accessing your published Nerdpack",
        "Tag your Nerdpack version",
        "Subscribe with the web UI"
      ],
      "title": "Subscribe to a Nerdpack",
      "type": "developer",
      "tags": [
        "nerdpack",
        "subscribe"
      ],
      "external_id": "1e44b2ed6ab9788b17cd19ca10ae4b4cfd4c2fe1",
      "image": "https://developer.newrelic.com/static/157cec05491eea35b82fe9066d24f004/0086b/subscribe-to-account-maturity-app.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/subscribe/",
      "published_at": "2021-08-03T01:47:20Z",
      "updated_at": "2021-05-21T01:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to subscribe to a Nerdpack",
      "body": "Subscribe to a Nerdpack to use it in the New Relic platform. Unsubscribe from Nerdpacks you no longer use. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To subscribe to a Nerdpack, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can subscribe to them: Publish your Nerdpack Tag your Nerdpack if it's published and doesn't yet have a tag Subscribe to a Nerdpack Subscribe to a published Nerdpack, with either the web UI or the nr1 CLI, to use it in your account. Subscribing allows you to select the tagged version you want to use as well as the account you want to subscribe with. This lets you control what Nerdpacks you use in your account. Tip When the tag you've subscribed to gets an update, New Relic updates your Nerdpack automatically. Step 1 of 7 Go to New Relic: Step 2 of 7 Navigate to Apps: Step 3 of 7 Find your published Nerdpack under New Relic One catalog: All published Nerdpacks are shown in the New Relic One catalog. However, the one you're looking for maybe filtered out. Adjust the filter to find the Nerdpack you're looking for: Step 4 of 7 Select the Nerdpack you want to add to your New Relic account: Step 5 of 7 Click Add this app: This button says Manage access if you're already subscribed to the Nerdpack. Step 6 of 7 Select the account to subscribe with and the tagged version to subscribe to. Then, update your account(s): Tip In the web UI, and some places in the CLI, we refer to tags as channels. This is a relic of a past implementation of Nerdpack versioning. Ignoring historical and implementation details, consider them to be synonyms. Now you, and members of the accounts you've subscribed with, can launch the Nerdpack from New Relic. Step 7 of 7 If you subscribed to an app, find it under Your apps: If you subscribed to a visualization, find it under Custom visualizations: Subscribe from the command line If you've published your own Nerdpack, it may be quicker to subscribe to your Nerdpack with the nr1 CLI. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack For simplicity, this guide refers to your Nerdpack as my-awesome-nerdpack. Step 2 of 3 Ensure that your Nerdpack was published and tagged: bash Copy $ nr1 nerdpack:info Id: ab123c45-678d-9012-efg3-45hi6jkl7890 Region: us Account ID: 1234567 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ----------------- ------ 1.0.0 a few seconds ago STABLE You should see at least one published version with a tag. It doesn't have to be STABLE. You can subscribe to any tagged version. Step 3 of 3 Subscribe to your Nerdpack: bash Copy $ nr1 nerdpack:subscribe --channel=STABLE Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the STABLE channel Here, you've subscribed to the STABLE tag. You can also subscribe to DEV and BETA tags from the CLI, but the subscription command doesn't allow for arbitrary tags. To subscribe to any other tagged version, you need to use the web UI. Similar to the web UI, the term channel nr1 nerdpack:subscribe is a reference to an older implementation of Nerdpack versions. Technical detail nr1 nerdpack:subscribe is an alias for nr1 subscription:set. Read the nr1 subscription:set documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:set --help Unsubscribe from a Nerdpack Unsubscribe from a Nerdpack to remove it from your account. Step 1 of 5 Go to New Relic: Step 2 of 5 Navigate to Apps: Step 3 of 5 Click the \"i\" icon next to the Nerdpack you're subscribed to: This opens the detail page. Step 4 of 5 Click Manage access: Step 5 of 5 Deselect the accounts you want to unsubscribe with. Then, update those accounts: Unsubscribe using the command line Quickly unsubscribe your CLI profile from Nerdpacks. Step 1 of 3 Navigate to your Nerdpack's root directory: bash Copy $ cd my-awesome-nerdpack Step 2 of 3 View your profile's subscriptions: bash Copy $ nr1 subscription:list Listing subscribed deployed nerdpacks on your account: Version UUID Name Date User ------- ------------------------------------ ---------------- ----------- ------- 0.6.4 384de6e5-8e57-4d56-9d13-299ee7ae8641 Account Maturity a month ago 2774472 Step 3 of 3 Unsubscribe from the Nerdpack with the UUID: bash Copy $ nr1 nerdpack:unsubscribe --nerdpack-id=384de6e5-8e57-4d56-9d13-299ee7ae8641 Unsubscribed account 1234567 from the nerdpack 384de6e5-8e57-4d56-9d13-299ee7ae8641 on the STABLE channel. Tip nr1 nerdpack:unsubscribe is an alias for nr1 subscription:unset. Read the nr1 subscription:unset documentation to learn more. Or, view the nr1 help page: bash Copy $ nr1 subscription:unset --help Resolve issues with accessing your published Nerdpack Sometimes, when you subscribe to a Nerdpack, you may run into issues. Whether you can't subscribe or see duplicate subscriptions in your account, consider some common solutions for resolving these issues. Tag your Nerdpack version When you subscribe to an Nerdpack, you choose a specific tag. So, if the Nerdpack you're trying to subscribe to isn't tagged, or doesn't have the tag you're targeting, tag your release version: bash Copy $ nr1 nerdpack:subscribe --channel=DEV › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel DEV. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED $ nr1 nerdpack:tag --tag=DEV ✔ Tagged ab123c45-678d-9012-efg3-45hi6jkl7890 version 1.0.0 as DEV. $ nr1 nerdpack:subscribe --channel=DEV Subscribed account 1234567 to the nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 on the DEV channel. If you subscribe without a --channel argument, the default channel is STABLE, so make sure you have a STABLE version in this case: bash Copy $ nr1 nerdpack:subscribe › Error: Nerdpack ab123c45-678d-9012-efg3-45hi6jkl7890 is not deployed to channel STABLE. You have to deploy it first › Code: PACKAGE_NOT_DEPLOYED Subscribe with the web UI When you subscribe with the CLI, you pass a --channel argument to select a tag. A channel is, for all intents and purposes, a tag. This term is a relic of a past implementation of Nerdpack versioning. However, while the terms are synonymous, using --channel is limited in the CLI. When you subscribe with a --channel, you can only choose between DEV, BETA, and STABLE. So, to subscribe to a different tag, use the web UI: bash Copy $ nr1 nerdpack:subscribe --channel=QA › Error: Expected --channel=QA to be one of: DEV, BETA, STABLE › See more help with --help › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.30382,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Subscribe to a <em>Nerdpack</em>",
        "sections": "<em>Tag</em> your <em>Nerdpack</em> version",
        "info": "Learn to subscribe to a <em>Nerdpack</em>",
        "tags": "<em>nerdpack</em>",
        "body": " to the account that published it The necessary permissions for managing Nerdpacks Publish your <em>Nerdpack</em> You need to publish Nerdpacks that you create before you can subscribe to them: Publish your <em>Nerdpack</em> <em>Tag</em> your <em>Nerdpack</em> if it&#x27;s published and doesn&#x27;t yet have a <em>tag</em> Subscribe to a <em>Nerdpack</em> Subscribe"
      },
      "id": "609c8686196a67beaed52a2c"
    }
  ],
  "/build-apps/publish-deploy/publish": [
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.30756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, <em>publish</em>, and subscribe to your <em>Nerdpack</em>",
        "sections": "Serve, <em>publish</em>, and subscribe to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, <em>publish</em>, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, <em>publish</em>, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.24725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and subscribing accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user Serve Nerdpacks yes yes yes yes <em>Publish</em> Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.31772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enable advanced configurations for your <em>Nerdpack</em>",
        "body": " 20 min Add a time picker to a sample application Enable advanced configurations for your <em>Nerdpack</em>   Enable advanced configurations for your <em>Nerdpack</em> Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.4389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Publish</em> your application to New Relic",
        "info": "Build a &quot;Hello, World!&quot; app and <em>publish</em> it to New Relic One",
        "tags": "<em>Nerdpack</em> file structure",
        "body": " organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 <em>nerdpack:publish</em> Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.60562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to see how your data looks, but you can&#x27;t instantiate that chart and use it in your account: To do that, you need to <em>publish</em> it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are <em>Nerdpack</em> items, you <em>publish</em> and subscribe to them the same way you"
      },
      "id": "6091fa3928ccbc4136a268d5"
    }
  ],
  "/build-apps/attach-nerdlet-to-entities": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 5052.6113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Attach</em> <em>your</em> <em>Nerdlet</em> <em>to</em> <em>entities</em>",
        "body": " 20 min Add a time picker to a sample application Enable advanced configurations for <em>your</em> Nerdpack   Enable advanced configurations for <em>your</em> Nerdpack Add <em>your</em> custom visualization to a dashboard 10 min Add <em>your</em> custom visualization to a New Relic dashboard <em>Attach</em> <em>your</em> <em>Nerdlet</em> to <em>entities</em>   <em>Attach</em>"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "image": "https://developer.newrelic.com/static/fcc5c48e25ec18cb8ddf8518059586bb/0086b/new-message.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:21Z",
      "title": "Serve your New Relic One application",
      "updated_at": "2021-05-13T01:54:25Z",
      "type": "developer",
      "external_id": "79f6532d0c9e836788ebd0958c1158f062f0fd95",
      "document_type": "page",
      "popularity": 1,
      "info": "Locally serve your New Relic One application",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Tip Here, you've seen how to access your Nerdlet from a launcher. If you want your Nerdlet closer to your data, you can also attach your Nerdlet to New Relic entities. Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 938.5481,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve <em>your</em> New Relic One application",
        "sections": "Serve <em>your</em> New Relic One application",
        "info": "Locally serve <em>your</em> New Relic One application",
        "body": " to see <em>your</em> root <em>Nerdlet</em> and its default welcome message: Tip Here, you&#x27;ve seen how to access <em>your</em> <em>Nerdlet</em> from a launcher. If you want <em>your</em> <em>Nerdlet</em> closer to <em>your</em> data, you can also <em>attach</em> <em>your</em> <em>Nerdlet</em> to New Relic <em>entities</em>. Congratulations, you&#x27;ve served <em>your</em> first New Relic One application! Notice"
      },
      "id": "6091fb4428ccbcfe3fa268f1"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.6886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdlets</em>",
        "body": " launcher for <em>your</em> Nerdpack and called it &quot;ab-test-launcher&quot;. Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher&#x27;s metadata file Use &quot;A&#x2F;B Test Launcher&quot; for the launcher&#x27;s displayName and &quot;Open the A&#x2F;B test <em>Nerdlet</em>"
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "NerdGraph tutorial: Understand entity relationships and dependencies",
        "Relationship types",
        "Read relationships of an entity"
      ],
      "title": "NerdGraph tutorial: Understand entity relationships and dependencies",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "3699777ea1a7bf17213ccdaad3b44793e1561948",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-relationships-api-tutorial/",
      "published_at": "2021-08-03T06:45:39Z",
      "updated_at": "2021-08-03T06:45:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to understand how your monitored entities relate to each other is using our NerdGraph API. You can use the relatedEntities field to see how pairs of entities interact and how they're related. This can help troubleshoot upstream and downstream services and understand how minor issues may have larger repercussions, similar to how service maps can be used. Relationship types Relationship types provide additional information about how two entities are related. The supported relationship types are: Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source in addition to the one you are currently viewing. Read relationships of an entity You can use NerdGraph to return the relationships between your monitored entities. The following example shows how to query an entity by its specific GUID, using the NerdGraph GraphiQL explorer. For more information, see Use NerdGraph to query entities. query{ actor{ entity(guid: YOUR_ENTITY_GUID){ name relatedEntities { results { source { entity { guid name } } target { entity { guid name } } type } } } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.778465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph tutorial: Understand <em>entity</em> relationships and dependencies",
        "sections": "NerdGraph tutorial: Understand <em>entity</em> relationships and dependencies",
        "body": "One way to understand how <em>your</em> monitored <em>entities</em> relate to each other is using our NerdGraph API. You can use the related<em>Entities</em> field to see how pairs of <em>entities</em> interact and how they&#x27;re related. This can help troubleshoot upstream and downstream services and understand how minor issues may"
      },
      "id": "603ec1c664441fb7ff4e8852"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-08-03T01:45:10Z",
      "updated_at": "2021-05-13T01:48:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"context\": { \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }] }, \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.588066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdlet</em> file structure",
        "tags": "<em>nerdlets</em>",
        "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more <em>Nerdlet</em> files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a <em>Nerdlet</em>, and a launcher How to link a launcher file to a <em>Nerdlet</em> How to link <em>your</em>"
      },
      "id": "6091fa3928ccbc3197a268f1"
    }
  ],
  "/build-apps/publish-deploy/subscribe": [
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.5447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and <em>subscribe</em> to your <em>Nerdpack</em>",
        "sections": "Serve, publish, and <em>subscribe</em> to your <em>Nerdpack</em>",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, tag, and <em>subscribe</em> to it on the New Relic platform. Guides to serve, publish, and <em>subscribe</em> to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s catalog"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Nerdpack permissions",
        "Capabilities at a glance",
        "Original user model",
        "New Relic One user model",
        "Nerdpack permissions: Original user model",
        "Basic users",
        "Tip",
        "Full users",
        "Owner/Admin users",
        "Nerdpack permissions: New Relic One user model",
        "Master/Sub-account Capabilities"
      ],
      "title": "Nerdpack permissions",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "https://developer.newrelic.com/static/30af7dc53a2d58f2e173791d45d4c71f/b01d9/master-sub-accounts-nerdpacks.png",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-07-30T01:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for using and subscribing accounts to Nerdpacks",
      "body": "Understand the requirements for managing and using Nerdpacks in New Relic One. Capabilities at a glance Your ability to manage and use Nerdpacks depends on your user's: Model (original or New Relic One model) Type Role Whether you're on the original user model or the New Relic One user model, review the tables below for a summary of your Nerdpack capabilities. Original user model If your organization was created before July 30, 2020 and you haven't transitioned to our New Relic One pricing model, you're on the original pricing plan. Capabilities for our original user model differ from those of our new user model: Basic user Full user without the Nerdpack Manager add-on role Full user with the Nerdpack Manager add-on role Owner/Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes Subscribe to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets or visualizations created by your accounts no yes yes yes Use Nerdlets created by New Relic no* yes yes yes Use visualizations created by New Relic no yes yes yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. New Relic One user model If your organization is part of the New Relic One pricing model, the user types, privileges, and capabilities are different than those of our original user model: Basic user Full user Serve Nerdpacks yes yes Publish Nerdpacks no yes Subscribe to Nerdpacks no yes Tag Nerdpacks no yes Use Nerdlets or visualizations created by your accounts no yes Use Nerdlets created by New Relic no* yes Use visualizations created by New Relic no yes * There are a few Nerdlets that basic users are allowed to use. See Basic users for more information. Nerdpack permissions: Original user model Learn the differences between how basic users, full users, and admins can use and manage Nerdpacks in the original user model. Basic users If you're a basic user in the original user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the original user model, you either: Have the Nerdpack Manager add-on role Don't have the Nerdpack Manager add-on role The Nerdpack Manager role is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpack Manager role, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to a Nerdpack, an admin must upgrade you to a full user or grant you the Nerdpack Manager add-on role. Owner/Admin users If you're an owner or admin user, you can perform any of the Nerdpack capabilities. You can create, serve, publish, tag, subscribe to, and use any and all Nerdpack items, both Nerdlets and visualizations. This includes Nerdpacks built by New Relic or by one of your accounts. Nerdpack permissions: New Relic One user model Learn the differences between how basic users and full users can use and manage Nerdpacks in the New Relic One user model. Basic users If you're a basic user in the New Relic One user model, you're limited in your Nerdpack capabilities. You can only create and serve Nerdpacks locally. To publish, tag, subscribe to, and use your Nerdpacks, an admin must upgrade you to a full user. Tip If you're a basic user, you generally can't use any Nerdpacks. However, there are some Nerdlets that New Relic maintains that you can use. These are rare and there is currently no way for you to distinguish them in our web interface. And even if you can use a Nerdlet in a Nerdpack, you're never able to use custom visualizations. For this, you must be upgraded to a full user. Full users If you're a full user in the New Relic One user model, you either: Have the Nerdpacks \"modify\" privilege Don't have the Nerdpacks \"modify\" privilege The Nerdpacks \"modify\" privilege is required to publish, subscribe to, and tag Nerdpacks. So if you don't have the Nerdpacks \"modify\" privilege, you can only create and serve Nerdpacks locally and use Nerdpacks that your accounts have already been subscribed to. To publish, tag, or subscribe to your Nerdpack, an admin must grant you the Nerdpacks \"modify\" privilege. Tip The Nerdpacks \"modify\" privilege is included in both the User and Admin groups, the only groups available by default. So in most cases, you'll have the ability to manage Nerdpacks as a full user. However, if you're a full user assigned to a custom group that doesn't include the Nerdpacks \"modify\" privilege, you won't be able to manage Nerdpacks. Master/Sub-account Capabilities Some accounts, called master accounts, have sub-accounts that report data back up to them. This organizational hierarchy affects Nerdpack capabilities. In general, the flow of control moves downstream: In this example scenario A, the master account publishes a Nerdpack. This means that all three accounts, Master, Account 1, and Account 2, can subscribe to it. If you subscribe the master account to the Nerdpack, then users of all three accounts can use it. If you subscribe Account 1 to it, only Account 1 users can use it, because neither Master nor Account 2 is downstream in the hierarchy. In scenario B, the sub-account, Account 1, publishes a Nerdpack, so you can't use or subscribe to the Nerdpack from Master or Account 2.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.91808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> permissions",
        "sections": "<em>Nerdpack</em> permissions",
        "info": "Learn about permissions for using and <em>subscribing</em> accounts to <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> manager",
        "body": " of our new user model: Basic user Full user without the <em>Nerdpack</em> Manager add-on role Full user with the <em>Nerdpack</em> Manager add-on role Owner&#x2F;Admin user Serve Nerdpacks yes yes yes yes Publish Nerdpacks no no yes yes <em>Subscribe</em> to Nerdpacks no no yes yes Tag Nerdpacks no no yes yes Use Nerdlets"
      },
      "id": "6091fa39196a67a39ed52a4f"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.01381,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "tags": "<em>Subscribe</em> applications",
        "body": " to <em>subscribe</em> accounts to the application. Any user with the <em>NerdPack</em> manager or admin role can <em>subscribe</em> to an application from accounts that they have permission to manage. Step 1 of 3 If you&#x27;re not already displaying your application&#x27;s description page in the browser, click the launcher"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.98479,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to see how your data looks, but you can&#x27;t instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and <em>subscribe</em> to it from your account. Because custom visualizations are <em>Nerdpack</em> items, you publish and <em>subscribe</em> to them the same way you"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.79916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enable advanced configurations for your <em>Nerdpack</em>",
        "body": " 20 min Add a time picker to a sample application Enable advanced configurations for your <em>Nerdpack</em>   Enable advanced configurations for your <em>Nerdpack</em> Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach"
      },
      "id": "6091fa3964441f96032f3740"
    }
  ],
  "/build-apps/publish-deploy/catalog": [
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "sections": [
        "Serve, publish, and subscribe to your Nerdpack",
        "Guides to serve, publish, and subscribe to your nerdpack",
        "Update your Nerdpack's catalog information",
        "Publish your Nerdpack",
        "Serve your Nerdpack",
        "Tag your Nerdpack's release version",
        "Subscribe to a Nerdpack"
      ],
      "published_at": "2021-08-03T01:41:56Z",
      "title": "Serve, publish, and subscribe to your Nerdpack",
      "updated_at": "2021-08-03T01:41:56Z",
      "type": "developer",
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "document_type": "page",
      "popularity": 1,
      "info": "Share and use the Nerdpacks you build",
      "body": "Whether your Nerdpack includes launchers, Nerdlets, visualizations, or all of the above, you'll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your nerdpack Update your Nerdpack's catalog information 10 minutes Update catalog info Publish your Nerdpack   Publish your Nerdpack Serve your Nerdpack   Serve your Nerdpack locally Tag your Nerdpack's release version   Tag your Nerdpack's release version Subscribe to a Nerdpack   Subscribe to a Nerdpack",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.77432,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and subscribe to your <em>Nerdpack</em>",
        "sections": "Update your <em>Nerdpack&#x27;s</em> <em>catalog</em> information",
        "info": "Share and use the <em>Nerdpacks</em> you build",
        "body": "Whether your <em>Nerdpack</em> includes launchers, Nerdlets, visualizations, or all of the above, you&#x27;ll eventually need to know how to serve, publish, describe, tag, and subscribe to it on the New Relic platform. Guides to serve, publish, and subscribe to your <em>nerdpack</em> Update your <em>Nerdpack</em>&#x27;s <em>catalog</em>"
      },
      "id": "6091fa39e7b9d2e603506895"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advanced configurations",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-08-03T01:39:43Z",
      "updated_at": "2021-07-30T01:43:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin Developing applications requires a New Relic account and the New Relic One CLI (nr1). If you haven't already: Sign up for a New Relic account Install Node.js Complete the CLI quick start Finally, make sure your nr1 is up-to-date: bash Copy $ nr1 update For additional details about setting up your environment, see Set up your development environment and Enable advanced configurations for your Nerdpack. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two Nerdpack items: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advanced configurations If you're interested in advanced configurations for your Nerdpack, read Enable advanced configurations for your Nerdpack. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.16924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Nerdpack</em> file structure",
        "body": " organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 <em>nerdpack</em>:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One <em>catalog</em>, click the launcher for your new application"
      },
      "id": "6091f9c864441f70d82f36c4"
    },
    {
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "title": "Introduction to custom visualizations",
      "type": "developer",
      "tags": [
        "sdk",
        "nerdpack",
        "nr1",
        "custom visualizations"
      ],
      "external_id": "ff76c6ae12fc95ba98d750685df8886f04d5b51c",
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/",
      "published_at": "2021-08-03T01:46:13Z",
      "updated_at": "2021-07-30T01:50:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to custom visualizations",
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type visualization --name custom-viz ✔ You are attempting to create a nerdlet outside of a nerdpack. We will create a nerdpack for you. What would you like to name it? ...my-first-viz ✔ nerdpack created successfully! nerdpack my-first-viz is available at \"./my-first-viz\" ✔ visualization created successfully! visualization custom-viz is available at \"./my-first-viz/visualizations/custom-viz\" The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ cd my-first-viz $ nr1 nerdpack:serve Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ custom-viz https://one.nr/012ab3cd4Ef Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack items, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.79337,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>nerdpack</em>",
        "body": " to see how your data looks, but you can&#x27;t instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One <em>catalog</em> and subscribe to it from your account. Because custom visualizations are <em>Nerdpack</em> items, you publish and subscribe to them the same way you"
      },
      "id": "6091fa3928ccbc4136a268d5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-08-03T01:47:59Z",
      "title": "Create a Nerdpack",
      "updated_at": "2021-07-30T01:51:40Z",
      "type": "developer",
      "external_id": "e4223ca53574b4a7dccb8f244141fde3942d9c90",
      "document_type": "page",
      "popularity": 1,
      "info": "Create a Nerdpack",
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application or visualization. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet Nerdpack item inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.63503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create a <em>Nerdpack</em>",
        "sections": "Create a <em>Nerdpack</em>",
        "info": "Create a <em>Nerdpack</em>",
        "body": " arrow-keys. Return to submit. <em>nerdpack</em> ❯ nerdlet - create a&#x2F;an Nerdlet <em>Nerdpack</em> item inside your <em>Nerdpack</em>. launcher <em>catalog</em> visualization In the next lesson, you&#x27;ll learn how to serve your <em>Nerdpack</em> locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application."
      },
      "id": "6091faf2196a672632d52a22"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-08-03T01:41:56Z",
      "updated_at": "2021-05-05T01:53:28Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.20081,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up your <em>Nerdpacks</em>",
        "tags": "<em>nerdpack</em> commands",
        "body": " <em>Nerdpack</em>&#x2F;Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the <em>catalog</em> Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One <em>catalog</em> area, click the Build your own application"
      },
      "id": "6091fa9864441feb412f36d4"
    }
  ],
  "/build-apps/customize-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Enable advanced configurations for your Nerdpack",
        "Add your custom visualization to a dashboard",
        "Attach your Nerdlet to entities",
        "Create a \"Hello, World!\" application",
        "Customize open-source Nerdpacks",
        "Customize your visualization with configuration options",
        "Customize your visualization with SDK components",
        "Add a table to your app",
        "Nerdpack permissions",
        "Set up your development environment",
        "Create a custom map view"
      ],
      "published_at": "2021-08-03T01:38:37Z",
      "title": "Build apps",
      "updated_at": "2021-08-03T01:38:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Enable advanced configurations for your Nerdpack   Enable advanced configurations for your Nerdpack Add your custom visualization to a dashboard 10 min Add your custom visualization to a New Relic dashboard Attach your Nerdlet to entities   Attach your Nerdlet to entities Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Customize open-source Nerdpacks   Customize open-source Nerdpacks Customize your visualization with configuration options 10 min Customize your visualization using configuration Customize your visualization with SDK components 25 min Customize your visualization Add a table to your app 30 min Add a table to your New Relic One app Nerdpack permissions 10 minutes Learn about permissions for using and subscribing accounts to Nerdpacks Set up your development environment 20 min Prepare to build apps and contribute to this site Create a custom map view 30 min Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1934.8617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> <em>open</em>-<em>source</em> <em>Nerdpacks</em>",
        "body": " your Nerdlet to entities Create a &quot;Hello, World!&quot; application 15 min Build a &quot;Hello, World!&quot; app and publish it to New Relic One <em>Customize</em> <em>open</em>-<em>source</em> <em>Nerdpacks</em>   <em>Customize</em> <em>open</em>-<em>source</em> <em>Nerdpacks</em> <em>Customize</em> your visualization with configuration options 10 min <em>Customize</em> your visualization using"
      },
      "id": "6091fa3964441f96032f3740"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic APM agents",
        "How OpenTelemetry works with New Relic",
        "Important"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-08-02T09:08:40Z",
      "updated_at": "2021-08-02T09:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects (initially, traces and metrics are supported, followed by logs) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetry’s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss it directly with us at New Relic to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic APM agents In general, New Relic APM agents will collect more telemetry data for your services, and they offer a wide range configuration options and an extensive set of auto-instrumentation capabilities. APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemtry community to export your data to New Relic. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.54758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> telemetry integrations",
        "body": " instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into <em>Open</em>Telemetry or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which"
      },
      "id": "603e81ba196a67304da83dab"
    },
    {
      "sections": [
        "OpenCensus exporter",
        "Enable exporter",
        "Find your data",
        "Resources"
      ],
      "title": "OpenCensus exporter",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenCensus"
      ],
      "external_id": "032a667b90f9a608db4467c364ccbe39d69c48e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opencensus/opencensus-exporter/",
      "published_at": "2021-08-02T09:07:17Z",
      "updated_at": "2021-08-02T09:07:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenCensus is a set of libraries for various languages that allow you to collect application metrics and distributed traces, then transfer the data to a backend of your choice. New Relic's OpenCensus exporters send telemetry data from your OpenCensus-instrumented applications to your New Relic account. Enable exporter To enable a New Relic OpenCensus exporter: If you don't have one already, create a New Relic account. It's free, forever. Follow the install procedures: Go language exporter Python language exporter Optional: Instead of using the native OpenCensus trace sampling, you can enable our Infinite Tracing feature. If you do this, you will typically want to configure OpenCensus to send us all trace data (learn more about sampling). To enable Infinite Tracing: In the New Relic UI, set up a trace observer. Configure the exporter to send data to the trace observer: Go exporter: Set the SpansURLOverride field on the Config object with YOUR_TRACE_OBSERVER_URL when creating the Exporter. Python exporter: Pass the host parameter to the trace exporter using YOUR_TRACE_OBSERVER_HOST. Find your data To find your data, go to one.newrelic.com and go to Explorer. From the Entities screen, search for your service by name. From there, you can explore your metrics using the Data explorer and build dashboards using your metrics. If you're also sending distributed tracing data, the distributed tracing feature is available to query and view traces. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL. Resources Our OpenCensus exporter resources include: Go language exporter Python language exporter OpenCensus metric exporter specs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.53262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenCensus</em> exporter",
        "sections": "<em>OpenCensus</em> exporter",
        "tags": "<em>Open</em> <em>source</em> telemetry integrations",
        "body": "<em>Open</em>Census is a set of libraries for various languages that allow you to collect application metrics and distributed traces, then transfer the data to a backend of your choice. New Relic&#x27;s <em>Open</em>Census exporters send telemetry data from your <em>Open</em>Census-instrumented applications to your New Relic"
      },
      "id": "603e95ab196a6708e6a83dcb"
    },
    {
      "sections": [
        "Istio adapter",
        "Enable Istio adapter",
        "Find your data"
      ],
      "title": "Istio adapter",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "Istio"
      ],
      "external_id": "05c14aeaf5d07e0edcb4bd4bc4efcb2745627f00",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/istio/istio-adapter/",
      "published_at": "2021-08-02T10:43:17Z",
      "updated_at": "2021-08-02T10:43:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Istio provides a flexible model to enforce authorization policies and collect telemetry for the services in a mesh. New Relic's Istio adapter exports telemetry data from your Istio instance to your New Relic account. Resources for our Istio adapter: Enable Istio adapter To enable our Istio adapter: If you don't have one already, create a New Relic account. It's free, forever. Follow the Istio adapter install instructions. Optional: Instead of using the native Istio trace sampling, you can enable our Infinite Tracing feature. If you use this option, you will typically want to configure Istio to send us all trace data (learn more about sampling). To enable Infinite Tracing: In the New Relic UI, set up a trace observer. Configure our Istio adapter to send data to the trace observer: Set the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the Helm chart. Find your data To find your data, go to one.newrelic.com and go to Your applications > Explorer. From the Entities screen, search for your service by name. From there, you can explore your metrics using the Data explorer and build dashboards using your metrics. If you're sending distributed tracing data, the distributed tracing feature is available to query and view traces. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.48672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Open</em> <em>source</em> telemetry integrations"
      },
      "id": "603e81b464441fd2a54e8875"
    },
    {
      "sections": [
        "Dropwizard reporter",
        "Find your data"
      ],
      "title": "Dropwizard reporter",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "Dropwizard"
      ],
      "external_id": "a34e278ac53d2acc45f2d84f82de955a0d42c19d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter/",
      "published_at": "2021-08-02T10:41:04Z",
      "updated_at": "2021-08-02T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dropwizard is a Java framework for developing ops-friendly, high-performance, RESTful web services by providing metrics instrumentation out-of-the-box. New Relic's DropWizard reporter sends your Dropwizard metrics to your New Relic account. Want to try out our dropwizard reporter? Create a New Relic account for free! No credit card required. Resources for our Dropwizard reporter: README Integration specs Find your data To find your data, go to one.newrelic.com and go to Your applications > Explorer. From the entities screen, search for your service by name. From there, you can explore your metrics using the Data explorer and build dashboards using your metrics. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.46643,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Open</em> <em>source</em> telemetry integrations"
      },
      "id": "603e817de7b9d25f9a2a07c8"
    }
  ]
}